
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CategoryTranslation
 * 
 */
export type CategoryTranslation = $Result.DefaultSelection<Prisma.$CategoryTranslationPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagTranslation
 * 
 */
export type TagTranslation = $Result.DefaultSelection<Prisma.$TagTranslationPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model GameTranslation
 * 
 */
export type GameTranslation = $Result.DefaultSelection<Prisma.$GameTranslationPayload>
/**
 * Model GameTag
 * 
 */
export type GameTag = $Result.DefaultSelection<Prisma.$GameTagPayload>
/**
 * Model GameCategory
 * 
 */
export type GameCategory = $Result.DefaultSelection<Prisma.$GameCategoryPayload>
/**
 * Model PageType
 * 
 */
export type PageType = $Result.DefaultSelection<Prisma.$PageTypePayload>
/**
 * Model PageTypeTranslation
 * 
 */
export type PageTypeTranslation = $Result.DefaultSelection<Prisma.$PageTypeTranslationPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model LanguageTranslation
 * 
 */
export type LanguageTranslation = $Result.DefaultSelection<Prisma.$LanguageTranslationPayload>
/**
 * Model SiteConfig
 * 
 */
export type SiteConfig = $Result.DefaultSelection<Prisma.$SiteConfigPayload>
/**
 * Model SiteConfigTranslation
 * 
 */
export type SiteConfigTranslation = $Result.DefaultSelection<Prisma.$SiteConfigTranslationPayload>
/**
 * Model GameVote
 * 
 */
export type GameVote = $Result.DefaultSelection<Prisma.$GameVotePayload>
/**
 * Model AITask
 * 
 */
export type AITask = $Result.DefaultSelection<Prisma.$AITaskPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PageTypeEnum: {
  GAME_LIST: 'GAME_LIST',
  DISPLAY_PAGE: 'DISPLAY_PAGE',
  OTHER_PAGE: 'OTHER_PAGE'
};

export type PageTypeEnum = (typeof PageTypeEnum)[keyof typeof PageTypeEnum]


export const TextDirection: {
  LTR: 'LTR',
  RTL: 'RTL'
};

export type TextDirection = (typeof TextDirection)[keyof typeof TextDirection]


export const GameStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  MAINTENANCE: 'MAINTENANCE'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]


export const AITaskStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  WAITING_CONFIRM: 'WAITING_CONFIRM',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type AITaskStatus = (typeof AITaskStatus)[keyof typeof AITaskStatus]

}

export type PageTypeEnum = $Enums.PageTypeEnum

export const PageTypeEnum: typeof $Enums.PageTypeEnum

export type TextDirection = $Enums.TextDirection

export const TextDirection: typeof $Enums.TextDirection

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

export type AITaskStatus = $Enums.AITaskStatus

export const AITaskStatus: typeof $Enums.AITaskStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoryTranslation`: Exposes CRUD operations for the **CategoryTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryTranslations
    * const categoryTranslations = await prisma.categoryTranslation.findMany()
    * ```
    */
  get categoryTranslation(): Prisma.CategoryTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagTranslation`: Exposes CRUD operations for the **TagTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagTranslations
    * const tagTranslations = await prisma.tagTranslation.findMany()
    * ```
    */
  get tagTranslation(): Prisma.TagTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameTranslation`: Exposes CRUD operations for the **GameTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameTranslations
    * const gameTranslations = await prisma.gameTranslation.findMany()
    * ```
    */
  get gameTranslation(): Prisma.GameTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameTag`: Exposes CRUD operations for the **GameTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameTags
    * const gameTags = await prisma.gameTag.findMany()
    * ```
    */
  get gameTag(): Prisma.GameTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameCategory`: Exposes CRUD operations for the **GameCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameCategories
    * const gameCategories = await prisma.gameCategory.findMany()
    * ```
    */
  get gameCategory(): Prisma.GameCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageType`: Exposes CRUD operations for the **PageType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageTypes
    * const pageTypes = await prisma.pageType.findMany()
    * ```
    */
  get pageType(): Prisma.PageTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageTypeTranslation`: Exposes CRUD operations for the **PageTypeTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageTypeTranslations
    * const pageTypeTranslations = await prisma.pageTypeTranslation.findMany()
    * ```
    */
  get pageTypeTranslation(): Prisma.PageTypeTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languageTranslation`: Exposes CRUD operations for the **LanguageTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LanguageTranslations
    * const languageTranslations = await prisma.languageTranslation.findMany()
    * ```
    */
  get languageTranslation(): Prisma.LanguageTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteConfig`: Exposes CRUD operations for the **SiteConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteConfigs
    * const siteConfigs = await prisma.siteConfig.findMany()
    * ```
    */
  get siteConfig(): Prisma.SiteConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteConfigTranslation`: Exposes CRUD operations for the **SiteConfigTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteConfigTranslations
    * const siteConfigTranslations = await prisma.siteConfigTranslation.findMany()
    * ```
    */
  get siteConfigTranslation(): Prisma.SiteConfigTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameVote`: Exposes CRUD operations for the **GameVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameVotes
    * const gameVotes = await prisma.gameVote.findMany()
    * ```
    */
  get gameVote(): Prisma.GameVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aITask`: Exposes CRUD operations for the **AITask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AITasks
    * const aITasks = await prisma.aITask.findMany()
    * ```
    */
  get aITask(): Prisma.AITaskDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    CategoryTranslation: 'CategoryTranslation',
    Tag: 'Tag',
    TagTranslation: 'TagTranslation',
    Game: 'Game',
    GameTranslation: 'GameTranslation',
    GameTag: 'GameTag',
    GameCategory: 'GameCategory',
    PageType: 'PageType',
    PageTypeTranslation: 'PageTypeTranslation',
    Language: 'Language',
    LanguageTranslation: 'LanguageTranslation',
    SiteConfig: 'SiteConfig',
    SiteConfigTranslation: 'SiteConfigTranslation',
    GameVote: 'GameVote',
    AITask: 'AITask'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "category" | "categoryTranslation" | "tag" | "tagTranslation" | "game" | "gameTranslation" | "gameTag" | "gameCategory" | "pageType" | "pageTypeTranslation" | "language" | "languageTranslation" | "siteConfig" | "siteConfigTranslation" | "gameVote" | "aITask"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CategoryTranslation: {
        payload: Prisma.$CategoryTranslationPayload<ExtArgs>
        fields: Prisma.CategoryTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findFirst: {
            args: Prisma.CategoryTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findMany: {
            args: Prisma.CategoryTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          create: {
            args: Prisma.CategoryTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          createMany: {
            args: Prisma.CategoryTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          delete: {
            args: Prisma.CategoryTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          update: {
            args: Prisma.CategoryTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CategoryTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          upsert: {
            args: Prisma.CategoryTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          aggregate: {
            args: Prisma.CategoryTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryTranslation>
          }
          groupBy: {
            args: Prisma.CategoryTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryTranslationCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagTranslation: {
        payload: Prisma.$TagTranslationPayload<ExtArgs>
        fields: Prisma.TagTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          findFirst: {
            args: Prisma.TagTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          findMany: {
            args: Prisma.TagTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>[]
          }
          create: {
            args: Prisma.TagTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          createMany: {
            args: Prisma.TagTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>[]
          }
          delete: {
            args: Prisma.TagTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          update: {
            args: Prisma.TagTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          deleteMany: {
            args: Prisma.TagTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>[]
          }
          upsert: {
            args: Prisma.TagTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTranslationPayload>
          }
          aggregate: {
            args: Prisma.TagTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagTranslation>
          }
          groupBy: {
            args: Prisma.TagTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TagTranslationCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      GameTranslation: {
        payload: Prisma.$GameTranslationPayload<ExtArgs>
        fields: Prisma.GameTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          findFirst: {
            args: Prisma.GameTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          findMany: {
            args: Prisma.GameTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>[]
          }
          create: {
            args: Prisma.GameTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          createMany: {
            args: Prisma.GameTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>[]
          }
          delete: {
            args: Prisma.GameTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          update: {
            args: Prisma.GameTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          deleteMany: {
            args: Prisma.GameTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>[]
          }
          upsert: {
            args: Prisma.GameTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTranslationPayload>
          }
          aggregate: {
            args: Prisma.GameTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameTranslation>
          }
          groupBy: {
            args: Prisma.GameTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<GameTranslationCountAggregateOutputType> | number
          }
        }
      }
      GameTag: {
        payload: Prisma.$GameTagPayload<ExtArgs>
        fields: Prisma.GameTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          findFirst: {
            args: Prisma.GameTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          findMany: {
            args: Prisma.GameTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          create: {
            args: Prisma.GameTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          createMany: {
            args: Prisma.GameTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          delete: {
            args: Prisma.GameTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          update: {
            args: Prisma.GameTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          deleteMany: {
            args: Prisma.GameTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>[]
          }
          upsert: {
            args: Prisma.GameTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameTagPayload>
          }
          aggregate: {
            args: Prisma.GameTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameTag>
          }
          groupBy: {
            args: Prisma.GameTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameTagCountArgs<ExtArgs>
            result: $Utils.Optional<GameTagCountAggregateOutputType> | number
          }
        }
      }
      GameCategory: {
        payload: Prisma.$GameCategoryPayload<ExtArgs>
        fields: Prisma.GameCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          findFirst: {
            args: Prisma.GameCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          findMany: {
            args: Prisma.GameCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          create: {
            args: Prisma.GameCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          createMany: {
            args: Prisma.GameCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          delete: {
            args: Prisma.GameCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          update: {
            args: Prisma.GameCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          deleteMany: {
            args: Prisma.GameCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          upsert: {
            args: Prisma.GameCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          aggregate: {
            args: Prisma.GameCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameCategory>
          }
          groupBy: {
            args: Prisma.GameCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<GameCategoryCountAggregateOutputType> | number
          }
        }
      }
      PageType: {
        payload: Prisma.$PageTypePayload<ExtArgs>
        fields: Prisma.PageTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          findFirst: {
            args: Prisma.PageTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          findMany: {
            args: Prisma.PageTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>[]
          }
          create: {
            args: Prisma.PageTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          createMany: {
            args: Prisma.PageTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>[]
          }
          delete: {
            args: Prisma.PageTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          update: {
            args: Prisma.PageTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          deleteMany: {
            args: Prisma.PageTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>[]
          }
          upsert: {
            args: Prisma.PageTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypePayload>
          }
          aggregate: {
            args: Prisma.PageTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageType>
          }
          groupBy: {
            args: Prisma.PageTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PageTypeCountAggregateOutputType> | number
          }
        }
      }
      PageTypeTranslation: {
        payload: Prisma.$PageTypeTranslationPayload<ExtArgs>
        fields: Prisma.PageTypeTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageTypeTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageTypeTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          findFirst: {
            args: Prisma.PageTypeTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageTypeTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          findMany: {
            args: Prisma.PageTypeTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>[]
          }
          create: {
            args: Prisma.PageTypeTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          createMany: {
            args: Prisma.PageTypeTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageTypeTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>[]
          }
          delete: {
            args: Prisma.PageTypeTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          update: {
            args: Prisma.PageTypeTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PageTypeTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageTypeTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageTypeTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>[]
          }
          upsert: {
            args: Prisma.PageTypeTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTypeTranslationPayload>
          }
          aggregate: {
            args: Prisma.PageTypeTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageTypeTranslation>
          }
          groupBy: {
            args: Prisma.PageTypeTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageTypeTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageTypeTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<PageTypeTranslationCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      LanguageTranslation: {
        payload: Prisma.$LanguageTranslationPayload<ExtArgs>
        fields: Prisma.LanguageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          findFirst: {
            args: Prisma.LanguageTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          findMany: {
            args: Prisma.LanguageTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>[]
          }
          create: {
            args: Prisma.LanguageTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          createMany: {
            args: Prisma.LanguageTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>[]
          }
          delete: {
            args: Prisma.LanguageTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          update: {
            args: Prisma.LanguageTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.LanguageTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>[]
          }
          upsert: {
            args: Prisma.LanguageTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageTranslationPayload>
          }
          aggregate: {
            args: Prisma.LanguageTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageTranslation>
          }
          groupBy: {
            args: Prisma.LanguageTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageTranslationCountAggregateOutputType> | number
          }
        }
      }
      SiteConfig: {
        payload: Prisma.$SiteConfigPayload<ExtArgs>
        fields: Prisma.SiteConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findFirst: {
            args: Prisma.SiteConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findMany: {
            args: Prisma.SiteConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          create: {
            args: Prisma.SiteConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          createMany: {
            args: Prisma.SiteConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          delete: {
            args: Prisma.SiteConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          update: {
            args: Prisma.SiteConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          deleteMany: {
            args: Prisma.SiteConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          upsert: {
            args: Prisma.SiteConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          aggregate: {
            args: Prisma.SiteConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteConfig>
          }
          groupBy: {
            args: Prisma.SiteConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigCountAggregateOutputType> | number
          }
        }
      }
      SiteConfigTranslation: {
        payload: Prisma.$SiteConfigTranslationPayload<ExtArgs>
        fields: Prisma.SiteConfigTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteConfigTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteConfigTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          findFirst: {
            args: Prisma.SiteConfigTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteConfigTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          findMany: {
            args: Prisma.SiteConfigTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>[]
          }
          create: {
            args: Prisma.SiteConfigTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          createMany: {
            args: Prisma.SiteConfigTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteConfigTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>[]
          }
          delete: {
            args: Prisma.SiteConfigTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          update: {
            args: Prisma.SiteConfigTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          deleteMany: {
            args: Prisma.SiteConfigTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteConfigTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteConfigTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>[]
          }
          upsert: {
            args: Prisma.SiteConfigTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigTranslationPayload>
          }
          aggregate: {
            args: Prisma.SiteConfigTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteConfigTranslation>
          }
          groupBy: {
            args: Prisma.SiteConfigTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteConfigTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigTranslationCountAggregateOutputType> | number
          }
        }
      }
      GameVote: {
        payload: Prisma.$GameVotePayload<ExtArgs>
        fields: Prisma.GameVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          findFirst: {
            args: Prisma.GameVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          findMany: {
            args: Prisma.GameVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>[]
          }
          create: {
            args: Prisma.GameVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          createMany: {
            args: Prisma.GameVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>[]
          }
          delete: {
            args: Prisma.GameVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          update: {
            args: Prisma.GameVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          deleteMany: {
            args: Prisma.GameVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>[]
          }
          upsert: {
            args: Prisma.GameVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameVotePayload>
          }
          aggregate: {
            args: Prisma.GameVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameVote>
          }
          groupBy: {
            args: Prisma.GameVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameVoteCountArgs<ExtArgs>
            result: $Utils.Optional<GameVoteCountAggregateOutputType> | number
          }
        }
      }
      AITask: {
        payload: Prisma.$AITaskPayload<ExtArgs>
        fields: Prisma.AITaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AITaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AITaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          findFirst: {
            args: Prisma.AITaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AITaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          findMany: {
            args: Prisma.AITaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>[]
          }
          create: {
            args: Prisma.AITaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          createMany: {
            args: Prisma.AITaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AITaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>[]
          }
          delete: {
            args: Prisma.AITaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          update: {
            args: Prisma.AITaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          deleteMany: {
            args: Prisma.AITaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AITaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AITaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>[]
          }
          upsert: {
            args: Prisma.AITaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AITaskPayload>
          }
          aggregate: {
            args: Prisma.AITaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAITask>
          }
          groupBy: {
            args: Prisma.AITaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AITaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.AITaskCountArgs<ExtArgs>
            result: $Utils.Optional<AITaskCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    category?: CategoryOmit
    categoryTranslation?: CategoryTranslationOmit
    tag?: TagOmit
    tagTranslation?: TagTranslationOmit
    game?: GameOmit
    gameTranslation?: GameTranslationOmit
    gameTag?: GameTagOmit
    gameCategory?: GameCategoryOmit
    pageType?: PageTypeOmit
    pageTypeTranslation?: PageTypeTranslationOmit
    language?: LanguageOmit
    languageTranslation?: LanguageTranslationOmit
    siteConfig?: SiteConfigOmit
    siteConfigTranslation?: SiteConfigTranslationOmit
    gameVote?: GameVoteOmit
    aITask?: AITaskOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    translations: number
    subCategories: number
    gameSubCategories: number
    gameMainCategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | CategoryCountOutputTypeCountTranslationsArgs
    subCategories?: boolean | CategoryCountOutputTypeCountSubCategoriesArgs
    gameSubCategories?: boolean | CategoryCountOutputTypeCountGameSubCategoriesArgs
    gameMainCategories?: boolean | CategoryCountOutputTypeCountGameMainCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountGameSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountGameMainCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    games: number
    translations: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | TagCountOutputTypeCountGamesArgs
    translations?: boolean | TagCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagTranslationWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    gameCategories: number
    tags: number
    translations: number
    votes: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCategories?: boolean | GameCountOutputTypeCountGameCategoriesArgs
    tags?: boolean | GameCountOutputTypeCountTagsArgs
    translations?: boolean | GameCountOutputTypeCountTranslationsArgs
    votes?: boolean | GameCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCategoryWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTagWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTranslationWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameVoteWhereInput
  }


  /**
   * Count Type PageTypeCountOutputType
   */

  export type PageTypeCountOutputType = {
    translations: number
  }

  export type PageTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | PageTypeCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * PageTypeCountOutputType without action
   */
  export type PageTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeCountOutputType
     */
    select?: PageTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PageTypeCountOutputType without action
   */
  export type PageTypeCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTypeTranslationWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    translations: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | LanguageCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageTranslationWhereInput
  }


  /**
   * Count Type SiteConfigCountOutputType
   */

  export type SiteConfigCountOutputType = {
    translations: number
  }

  export type SiteConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | SiteConfigCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * SiteConfigCountOutputType without action
   */
  export type SiteConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigCountOutputType
     */
    select?: SiteConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteConfigCountOutputType without action
   */
  export type SiteConfigCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigTranslationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    icon: string | null
    sortOrder: number | null
    isEnabled: boolean | null
    parentId: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    icon: string | null
    sortOrder: number | null
    isEnabled: boolean | null
    parentId: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    slug: number
    icon: number
    sortOrder: number
    isEnabled: number
    parentId: number
    name: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    sortOrder?: true
    isEnabled?: true
    parentId?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    sortOrder?: true
    isEnabled?: true
    parentId?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    sortOrder?: true
    isEnabled?: true
    parentId?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    slug: string
    icon: string | null
    sortOrder: number
    isEnabled: boolean
    parentId: string | null
    name: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    sortOrder?: boolean
    isEnabled?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Category$translationsArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    gameSubCategories?: boolean | Category$gameSubCategoriesArgs<ExtArgs>
    gameMainCategories?: boolean | Category$gameMainCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    sortOrder?: boolean
    isEnabled?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    sortOrder?: boolean
    isEnabled?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    slug?: boolean
    icon?: boolean
    sortOrder?: boolean
    isEnabled?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "icon" | "sortOrder" | "isEnabled" | "parentId" | "name" | "description" | "metaTitle" | "metaDescription" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | Category$translationsArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    gameSubCategories?: boolean | Category$gameSubCategoriesArgs<ExtArgs>
    gameMainCategories?: boolean | Category$gameMainCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      translations: Prisma.$CategoryTranslationPayload<ExtArgs>[]
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      subCategories: Prisma.$CategoryPayload<ExtArgs>[]
      gameSubCategories: Prisma.$GameCategoryPayload<ExtArgs>[]
      gameMainCategories: Prisma.$GameCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      icon: string | null
      sortOrder: number
      isEnabled: boolean
      parentId: string | null
      name: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends Category$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subCategories<T extends Category$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameSubCategories<T extends Category$gameSubCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$gameSubCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameMainCategories<T extends Category$gameMainCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$gameMainCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly isEnabled: FieldRef<"Category", 'Boolean'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly metaTitle: FieldRef<"Category", 'String'>
    readonly metaDescription: FieldRef<"Category", 'String'>
    readonly keywords: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.translations
   */
  export type Category$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.subCategories
   */
  export type Category$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.gameSubCategories
   */
  export type Category$gameSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    where?: GameCategoryWhereInput
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    cursor?: GameCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * Category.gameMainCategories
   */
  export type Category$gameMainCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    where?: GameCategoryWhereInput
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    cursor?: GameCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model CategoryTranslation
   */

  export type AggregateCategoryTranslation = {
    _count: CategoryTranslationCountAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  export type CategoryTranslationMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    locale: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryTranslationMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    locale: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryTranslationCountAggregateOutputType = {
    id: number
    categoryId: number
    locale: number
    name: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryTranslationMinAggregateInputType = {
    id?: true
    categoryId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryTranslationMaxAggregateInputType = {
    id?: true
    categoryId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryTranslationCountAggregateInputType = {
    id?: true
    categoryId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslation to aggregate.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryTranslations
    **/
    _count?: true | CategoryTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type GetCategoryTranslationAggregateType<T extends CategoryTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryTranslation[P]>
      : GetScalarType<T[P], AggregateCategoryTranslation[P]>
  }




  export type CategoryTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithAggregationInput | CategoryTranslationOrderByWithAggregationInput[]
    by: CategoryTranslationScalarFieldEnum[] | CategoryTranslationScalarFieldEnum
    having?: CategoryTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryTranslationCountAggregateInputType | true
    _min?: CategoryTranslationMinAggregateInputType
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type CategoryTranslationGroupByOutputType = {
    id: string
    categoryId: string
    locale: string
    name: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryTranslationCountAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  type GetCategoryTranslationGroupByPayload<T extends CategoryTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CategoryTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectScalar = {
    id?: boolean
    categoryId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "locale" | "name" | "description" | "metaTitle" | "metaDescription" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["categoryTranslation"]>
  export type CategoryTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CategoryTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CategoryTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CategoryTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryTranslation"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      locale: string
      name: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryTranslation"]>
    composites: {}
  }

  type CategoryTranslationGetPayload<S extends boolean | null | undefined | CategoryTranslationDefaultArgs> = $Result.GetResult<Prisma.$CategoryTranslationPayload, S>

  type CategoryTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryTranslationCountAggregateInputType | true
    }

  export interface CategoryTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryTranslation'], meta: { name: 'CategoryTranslation' } }
    /**
     * Find zero or one CategoryTranslation that matches the filter.
     * @param {CategoryTranslationFindUniqueArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryTranslationFindUniqueArgs>(args: SelectSubset<T, CategoryTranslationFindUniqueArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryTranslationFindUniqueOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryTranslationFindFirstArgs>(args?: SelectSubset<T, CategoryTranslationFindFirstArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany()
     * 
     * // Get first 10 CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryTranslationFindManyArgs>(args?: SelectSubset<T, CategoryTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryTranslation.
     * @param {CategoryTranslationCreateArgs} args - Arguments to create a CategoryTranslation.
     * @example
     * // Create one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.create({
     *   data: {
     *     // ... data to create a CategoryTranslation
     *   }
     * })
     * 
     */
    create<T extends CategoryTranslationCreateArgs>(args: SelectSubset<T, CategoryTranslationCreateArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryTranslations.
     * @param {CategoryTranslationCreateManyArgs} args - Arguments to create many CategoryTranslations.
     * @example
     * // Create many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryTranslationCreateManyArgs>(args?: SelectSubset<T, CategoryTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryTranslations and returns the data saved in the database.
     * @param {CategoryTranslationCreateManyAndReturnArgs} args - Arguments to create many CategoryTranslations.
     * @example
     * // Create many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryTranslations and only return the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryTranslation.
     * @param {CategoryTranslationDeleteArgs} args - Arguments to delete one CategoryTranslation.
     * @example
     * // Delete one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.delete({
     *   where: {
     *     // ... filter to delete one CategoryTranslation
     *   }
     * })
     * 
     */
    delete<T extends CategoryTranslationDeleteArgs>(args: SelectSubset<T, CategoryTranslationDeleteArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryTranslation.
     * @param {CategoryTranslationUpdateArgs} args - Arguments to update one CategoryTranslation.
     * @example
     * // Update one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryTranslationUpdateArgs>(args: SelectSubset<T, CategoryTranslationUpdateArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryTranslations.
     * @param {CategoryTranslationDeleteManyArgs} args - Arguments to filter CategoryTranslations to delete.
     * @example
     * // Delete a few CategoryTranslations
     * const { count } = await prisma.categoryTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryTranslationDeleteManyArgs>(args?: SelectSubset<T, CategoryTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryTranslationUpdateManyArgs>(args: SelectSubset<T, CategoryTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryTranslations and returns the data updated in the database.
     * @param {CategoryTranslationUpdateManyAndReturnArgs} args - Arguments to update many CategoryTranslations.
     * @example
     * // Update many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryTranslations and only return the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryTranslation.
     * @param {CategoryTranslationUpsertArgs} args - Arguments to update or create a CategoryTranslation.
     * @example
     * // Update or create a CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.upsert({
     *   create: {
     *     // ... data to create a CategoryTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryTranslation we want to update
     *   }
     * })
     */
    upsert<T extends CategoryTranslationUpsertArgs>(args: SelectSubset<T, CategoryTranslationUpsertArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationCountArgs} args - Arguments to filter CategoryTranslations to count.
     * @example
     * // Count the number of CategoryTranslations
     * const count = await prisma.categoryTranslation.count({
     *   where: {
     *     // ... the filter for the CategoryTranslations we want to count
     *   }
     * })
    **/
    count<T extends CategoryTranslationCountArgs>(
      args?: Subset<T, CategoryTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryTranslationAggregateArgs>(args: Subset<T, CategoryTranslationAggregateArgs>): Prisma.PrismaPromise<GetCategoryTranslationAggregateType<T>>

    /**
     * Group by CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CategoryTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryTranslation model
   */
  readonly fields: CategoryTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryTranslation model
   */
  interface CategoryTranslationFieldRefs {
    readonly id: FieldRef<"CategoryTranslation", 'String'>
    readonly categoryId: FieldRef<"CategoryTranslation", 'String'>
    readonly locale: FieldRef<"CategoryTranslation", 'String'>
    readonly name: FieldRef<"CategoryTranslation", 'String'>
    readonly description: FieldRef<"CategoryTranslation", 'String'>
    readonly metaTitle: FieldRef<"CategoryTranslation", 'String'>
    readonly metaDescription: FieldRef<"CategoryTranslation", 'String'>
    readonly keywords: FieldRef<"CategoryTranslation", 'String'>
    readonly createdAt: FieldRef<"CategoryTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoryTranslation findUnique
   */
  export type CategoryTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation findUniqueOrThrow
   */
  export type CategoryTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation findFirst
   */
  export type CategoryTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation findFirstOrThrow
   */
  export type CategoryTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation findMany
   */
  export type CategoryTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslations to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation create
   */
  export type CategoryTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryTranslation.
     */
    data: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
  }

  /**
   * CategoryTranslation createMany
   */
  export type CategoryTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryTranslations.
     */
    data: CategoryTranslationCreateManyInput | CategoryTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryTranslation createManyAndReturn
   */
  export type CategoryTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryTranslations.
     */
    data: CategoryTranslationCreateManyInput | CategoryTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryTranslation update
   */
  export type CategoryTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryTranslation.
     */
    data: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
    /**
     * Choose, which CategoryTranslation to update.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation updateMany
   */
  export type CategoryTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryTranslations.
     */
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryTranslations to update
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to update.
     */
    limit?: number
  }

  /**
   * CategoryTranslation updateManyAndReturn
   */
  export type CategoryTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * The data used to update CategoryTranslations.
     */
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryTranslations to update
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryTranslation upsert
   */
  export type CategoryTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryTranslation to update in case it exists.
     */
    where: CategoryTranslationWhereUniqueInput
    /**
     * In case the CategoryTranslation found by the `where` argument doesn't exist, create a new CategoryTranslation with this data.
     */
    create: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
    /**
     * In case the CategoryTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
  }

  /**
   * CategoryTranslation delete
   */
  export type CategoryTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter which CategoryTranslation to delete.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation deleteMany
   */
  export type CategoryTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslations to delete
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to delete.
     */
    limit?: number
  }

  /**
   * CategoryTranslation without action
   */
  export type CategoryTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    slug: string | null
    icon: string | null
    isEnabled: boolean | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    icon: string | null
    isEnabled: boolean | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    slug: number
    icon: number
    isEnabled: number
    name: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    isEnabled?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    isEnabled?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    slug?: true
    icon?: true
    isEnabled?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    slug: string
    icon: string | null
    isEnabled: boolean
    name: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    isEnabled?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    games?: boolean | Tag$gamesArgs<ExtArgs>
    translations?: boolean | Tag$translationsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    isEnabled?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    icon?: boolean
    isEnabled?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    slug?: boolean
    icon?: boolean
    isEnabled?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "icon" | "isEnabled" | "name" | "description" | "metaTitle" | "metaDescription" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | Tag$gamesArgs<ExtArgs>
    translations?: boolean | Tag$translationsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      games: Prisma.$GameTagPayload<ExtArgs>[]
      translations: Prisma.$TagTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      icon: string | null
      isEnabled: boolean
      name: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends Tag$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends Tag$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly icon: FieldRef<"Tag", 'String'>
    readonly isEnabled: FieldRef<"Tag", 'Boolean'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly metaTitle: FieldRef<"Tag", 'String'>
    readonly metaDescription: FieldRef<"Tag", 'String'>
    readonly keywords: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.games
   */
  export type Tag$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    where?: GameTagWhereInput
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    cursor?: GameTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * Tag.translations
   */
  export type Tag$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    where?: TagTranslationWhereInput
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    cursor?: TagTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagTranslation
   */

  export type AggregateTagTranslation = {
    _count: TagTranslationCountAggregateOutputType | null
    _min: TagTranslationMinAggregateOutputType | null
    _max: TagTranslationMaxAggregateOutputType | null
  }

  export type TagTranslationMinAggregateOutputType = {
    id: string | null
    tagId: string | null
    locale: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagTranslationMaxAggregateOutputType = {
    id: string | null
    tagId: string | null
    locale: string | null
    name: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagTranslationCountAggregateOutputType = {
    id: number
    tagId: number
    locale: number
    name: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagTranslationMinAggregateInputType = {
    id?: true
    tagId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagTranslationMaxAggregateInputType = {
    id?: true
    tagId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagTranslationCountAggregateInputType = {
    id?: true
    tagId?: true
    locale?: true
    name?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTranslation to aggregate.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagTranslations
    **/
    _count?: true | TagTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagTranslationMaxAggregateInputType
  }

  export type GetTagTranslationAggregateType<T extends TagTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTagTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagTranslation[P]>
      : GetScalarType<T[P], AggregateTagTranslation[P]>
  }




  export type TagTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagTranslationWhereInput
    orderBy?: TagTranslationOrderByWithAggregationInput | TagTranslationOrderByWithAggregationInput[]
    by: TagTranslationScalarFieldEnum[] | TagTranslationScalarFieldEnum
    having?: TagTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagTranslationCountAggregateInputType | true
    _min?: TagTranslationMinAggregateInputType
    _max?: TagTranslationMaxAggregateInputType
  }

  export type TagTranslationGroupByOutputType = {
    id: string
    tagId: string
    locale: string
    name: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagTranslationCountAggregateOutputType | null
    _min: TagTranslationMinAggregateOutputType | null
    _max: TagTranslationMaxAggregateOutputType | null
  }

  type GetTagTranslationGroupByPayload<T extends TagTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TagTranslationGroupByOutputType[P]>
        }
      >
    >


  export type TagTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTranslation"]>

  export type TagTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTranslation"]>

  export type TagTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTranslation"]>

  export type TagTranslationSelectScalar = {
    id?: boolean
    tagId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagId" | "locale" | "name" | "description" | "metaTitle" | "metaDescription" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["tagTranslation"]>
  export type TagTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TagTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagTranslation"
    objects: {
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagId: string
      locale: string
      name: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tagTranslation"]>
    composites: {}
  }

  type TagTranslationGetPayload<S extends boolean | null | undefined | TagTranslationDefaultArgs> = $Result.GetResult<Prisma.$TagTranslationPayload, S>

  type TagTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagTranslationCountAggregateInputType | true
    }

  export interface TagTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagTranslation'], meta: { name: 'TagTranslation' } }
    /**
     * Find zero or one TagTranslation that matches the filter.
     * @param {TagTranslationFindUniqueArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagTranslationFindUniqueArgs>(args: SelectSubset<T, TagTranslationFindUniqueArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagTranslationFindUniqueOrThrowArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TagTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindFirstArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagTranslationFindFirstArgs>(args?: SelectSubset<T, TagTranslationFindFirstArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindFirstOrThrowArgs} args - Arguments to find a TagTranslation
     * @example
     * // Get one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TagTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagTranslations
     * const tagTranslations = await prisma.tagTranslation.findMany()
     * 
     * // Get first 10 TagTranslations
     * const tagTranslations = await prisma.tagTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagTranslationWithIdOnly = await prisma.tagTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagTranslationFindManyArgs>(args?: SelectSubset<T, TagTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagTranslation.
     * @param {TagTranslationCreateArgs} args - Arguments to create a TagTranslation.
     * @example
     * // Create one TagTranslation
     * const TagTranslation = await prisma.tagTranslation.create({
     *   data: {
     *     // ... data to create a TagTranslation
     *   }
     * })
     * 
     */
    create<T extends TagTranslationCreateArgs>(args: SelectSubset<T, TagTranslationCreateArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagTranslations.
     * @param {TagTranslationCreateManyArgs} args - Arguments to create many TagTranslations.
     * @example
     * // Create many TagTranslations
     * const tagTranslation = await prisma.tagTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagTranslationCreateManyArgs>(args?: SelectSubset<T, TagTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagTranslations and returns the data saved in the database.
     * @param {TagTranslationCreateManyAndReturnArgs} args - Arguments to create many TagTranslations.
     * @example
     * // Create many TagTranslations
     * const tagTranslation = await prisma.tagTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagTranslations and only return the `id`
     * const tagTranslationWithIdOnly = await prisma.tagTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TagTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagTranslation.
     * @param {TagTranslationDeleteArgs} args - Arguments to delete one TagTranslation.
     * @example
     * // Delete one TagTranslation
     * const TagTranslation = await prisma.tagTranslation.delete({
     *   where: {
     *     // ... filter to delete one TagTranslation
     *   }
     * })
     * 
     */
    delete<T extends TagTranslationDeleteArgs>(args: SelectSubset<T, TagTranslationDeleteArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagTranslation.
     * @param {TagTranslationUpdateArgs} args - Arguments to update one TagTranslation.
     * @example
     * // Update one TagTranslation
     * const tagTranslation = await prisma.tagTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagTranslationUpdateArgs>(args: SelectSubset<T, TagTranslationUpdateArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagTranslations.
     * @param {TagTranslationDeleteManyArgs} args - Arguments to filter TagTranslations to delete.
     * @example
     * // Delete a few TagTranslations
     * const { count } = await prisma.tagTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagTranslationDeleteManyArgs>(args?: SelectSubset<T, TagTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagTranslations
     * const tagTranslation = await prisma.tagTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagTranslationUpdateManyArgs>(args: SelectSubset<T, TagTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagTranslations and returns the data updated in the database.
     * @param {TagTranslationUpdateManyAndReturnArgs} args - Arguments to update many TagTranslations.
     * @example
     * // Update many TagTranslations
     * const tagTranslation = await prisma.tagTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagTranslations and only return the `id`
     * const tagTranslationWithIdOnly = await prisma.tagTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, TagTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagTranslation.
     * @param {TagTranslationUpsertArgs} args - Arguments to update or create a TagTranslation.
     * @example
     * // Update or create a TagTranslation
     * const tagTranslation = await prisma.tagTranslation.upsert({
     *   create: {
     *     // ... data to create a TagTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagTranslation we want to update
     *   }
     * })
     */
    upsert<T extends TagTranslationUpsertArgs>(args: SelectSubset<T, TagTranslationUpsertArgs<ExtArgs>>): Prisma__TagTranslationClient<$Result.GetResult<Prisma.$TagTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationCountArgs} args - Arguments to filter TagTranslations to count.
     * @example
     * // Count the number of TagTranslations
     * const count = await prisma.tagTranslation.count({
     *   where: {
     *     // ... the filter for the TagTranslations we want to count
     *   }
     * })
    **/
    count<T extends TagTranslationCountArgs>(
      args?: Subset<T, TagTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagTranslationAggregateArgs>(args: Subset<T, TagTranslationAggregateArgs>): Prisma.PrismaPromise<GetTagTranslationAggregateType<T>>

    /**
     * Group by TagTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagTranslationGroupByArgs['orderBy'] }
        : { orderBy?: TagTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagTranslation model
   */
  readonly fields: TagTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagTranslation model
   */
  interface TagTranslationFieldRefs {
    readonly id: FieldRef<"TagTranslation", 'String'>
    readonly tagId: FieldRef<"TagTranslation", 'String'>
    readonly locale: FieldRef<"TagTranslation", 'String'>
    readonly name: FieldRef<"TagTranslation", 'String'>
    readonly description: FieldRef<"TagTranslation", 'String'>
    readonly metaTitle: FieldRef<"TagTranslation", 'String'>
    readonly metaDescription: FieldRef<"TagTranslation", 'String'>
    readonly keywords: FieldRef<"TagTranslation", 'String'>
    readonly createdAt: FieldRef<"TagTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"TagTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagTranslation findUnique
   */
  export type TagTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where: TagTranslationWhereUniqueInput
  }

  /**
   * TagTranslation findUniqueOrThrow
   */
  export type TagTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where: TagTranslationWhereUniqueInput
  }

  /**
   * TagTranslation findFirst
   */
  export type TagTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTranslations.
     */
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }

  /**
   * TagTranslation findFirstOrThrow
   */
  export type TagTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslation to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTranslations.
     */
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }

  /**
   * TagTranslation findMany
   */
  export type TagTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TagTranslations to fetch.
     */
    where?: TagTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTranslations to fetch.
     */
    orderBy?: TagTranslationOrderByWithRelationInput | TagTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagTranslations.
     */
    cursor?: TagTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTranslations.
     */
    skip?: number
    distinct?: TagTranslationScalarFieldEnum | TagTranslationScalarFieldEnum[]
  }

  /**
   * TagTranslation create
   */
  export type TagTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a TagTranslation.
     */
    data: XOR<TagTranslationCreateInput, TagTranslationUncheckedCreateInput>
  }

  /**
   * TagTranslation createMany
   */
  export type TagTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagTranslations.
     */
    data: TagTranslationCreateManyInput | TagTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagTranslation createManyAndReturn
   */
  export type TagTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many TagTranslations.
     */
    data: TagTranslationCreateManyInput | TagTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagTranslation update
   */
  export type TagTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a TagTranslation.
     */
    data: XOR<TagTranslationUpdateInput, TagTranslationUncheckedUpdateInput>
    /**
     * Choose, which TagTranslation to update.
     */
    where: TagTranslationWhereUniqueInput
  }

  /**
   * TagTranslation updateMany
   */
  export type TagTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagTranslations.
     */
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TagTranslations to update
     */
    where?: TagTranslationWhereInput
    /**
     * Limit how many TagTranslations to update.
     */
    limit?: number
  }

  /**
   * TagTranslation updateManyAndReturn
   */
  export type TagTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * The data used to update TagTranslations.
     */
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TagTranslations to update
     */
    where?: TagTranslationWhereInput
    /**
     * Limit how many TagTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagTranslation upsert
   */
  export type TagTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the TagTranslation to update in case it exists.
     */
    where: TagTranslationWhereUniqueInput
    /**
     * In case the TagTranslation found by the `where` argument doesn't exist, create a new TagTranslation with this data.
     */
    create: XOR<TagTranslationCreateInput, TagTranslationUncheckedCreateInput>
    /**
     * In case the TagTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagTranslationUpdateInput, TagTranslationUncheckedUpdateInput>
  }

  /**
   * TagTranslation delete
   */
  export type TagTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
    /**
     * Filter which TagTranslation to delete.
     */
    where: TagTranslationWhereUniqueInput
  }

  /**
   * TagTranslation deleteMany
   */
  export type TagTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTranslations to delete
     */
    where?: TagTranslationWhereInput
    /**
     * Limit how many TagTranslations to delete.
     */
    limit?: number
  }

  /**
   * TagTranslation without action
   */
  export type TagTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTranslation
     */
    select?: TagTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTranslation
     */
    omit?: TagTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    playCount: number | null
    viewCount: number | null
    likes: number | null
    dislikes: number | null
    rating: number | null
    ratingCount: number | null
    qualityScore: number | null
  }

  export type GameSumAggregateOutputType = {
    playCount: number | null
    viewCount: number | null
    likes: number | null
    dislikes: number | null
    rating: number | null
    ratingCount: number | null
    qualityScore: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    thumbnail: string | null
    banner: string | null
    embedUrl: string | null
    gameUrl: string | null
    status: $Enums.GameStatus | null
    isFeatured: boolean | null
    playCount: number | null
    viewCount: number | null
    likes: number | null
    dislikes: number | null
    rating: number | null
    ratingCount: number | null
    qualityScore: number | null
    sourcePlatform: string | null
    sourcePlatformId: string | null
    developer: string | null
    developerUrl: string | null
    releaseDate: Date | null
    sourceUpdatedAt: Date | null
    importedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    thumbnail: string | null
    banner: string | null
    embedUrl: string | null
    gameUrl: string | null
    status: $Enums.GameStatus | null
    isFeatured: boolean | null
    playCount: number | null
    viewCount: number | null
    likes: number | null
    dislikes: number | null
    rating: number | null
    ratingCount: number | null
    qualityScore: number | null
    sourcePlatform: string | null
    sourcePlatformId: string | null
    developer: string | null
    developerUrl: string | null
    releaseDate: Date | null
    sourceUpdatedAt: Date | null
    importedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    keywords: number
    metaTitle: number
    metaDescription: number
    thumbnail: number
    banner: number
    screenshots: number
    videos: number
    embedUrl: number
    gameUrl: number
    dimensions: number
    status: number
    isFeatured: number
    playCount: number
    viewCount: number
    likes: number
    dislikes: number
    rating: number
    ratingCount: number
    qualityScore: number
    sourcePlatform: number
    sourcePlatformId: number
    developer: number
    developerUrl: number
    gameInfo: number
    releaseDate: number
    sourceUpdatedAt: number
    importedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    playCount?: true
    viewCount?: true
    likes?: true
    dislikes?: true
    rating?: true
    ratingCount?: true
    qualityScore?: true
  }

  export type GameSumAggregateInputType = {
    playCount?: true
    viewCount?: true
    likes?: true
    dislikes?: true
    rating?: true
    ratingCount?: true
    qualityScore?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    thumbnail?: true
    banner?: true
    embedUrl?: true
    gameUrl?: true
    status?: true
    isFeatured?: true
    playCount?: true
    viewCount?: true
    likes?: true
    dislikes?: true
    rating?: true
    ratingCount?: true
    qualityScore?: true
    sourcePlatform?: true
    sourcePlatformId?: true
    developer?: true
    developerUrl?: true
    releaseDate?: true
    sourceUpdatedAt?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    thumbnail?: true
    banner?: true
    embedUrl?: true
    gameUrl?: true
    status?: true
    isFeatured?: true
    playCount?: true
    viewCount?: true
    likes?: true
    dislikes?: true
    rating?: true
    ratingCount?: true
    qualityScore?: true
    sourcePlatform?: true
    sourcePlatformId?: true
    developer?: true
    developerUrl?: true
    releaseDate?: true
    sourceUpdatedAt?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    thumbnail?: true
    banner?: true
    screenshots?: true
    videos?: true
    embedUrl?: true
    gameUrl?: true
    dimensions?: true
    status?: true
    isFeatured?: true
    playCount?: true
    viewCount?: true
    likes?: true
    dislikes?: true
    rating?: true
    ratingCount?: true
    qualityScore?: true
    sourcePlatform?: true
    sourcePlatformId?: true
    developer?: true
    developerUrl?: true
    gameInfo?: true
    releaseDate?: true
    sourceUpdatedAt?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    thumbnail: string
    banner: string | null
    screenshots: string[]
    videos: string[]
    embedUrl: string
    gameUrl: string | null
    dimensions: JsonValue
    status: $Enums.GameStatus
    isFeatured: boolean
    playCount: number
    viewCount: number
    likes: number
    dislikes: number
    rating: number
    ratingCount: number
    qualityScore: number | null
    sourcePlatform: string | null
    sourcePlatformId: string | null
    developer: string | null
    developerUrl: string | null
    gameInfo: JsonValue | null
    releaseDate: Date | null
    sourceUpdatedAt: Date | null
    importedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    thumbnail?: boolean
    banner?: boolean
    screenshots?: boolean
    videos?: boolean
    embedUrl?: boolean
    gameUrl?: boolean
    dimensions?: boolean
    status?: boolean
    isFeatured?: boolean
    playCount?: boolean
    viewCount?: boolean
    likes?: boolean
    dislikes?: boolean
    rating?: boolean
    ratingCount?: boolean
    qualityScore?: boolean
    sourcePlatform?: boolean
    sourcePlatformId?: boolean
    developer?: boolean
    developerUrl?: boolean
    gameInfo?: boolean
    releaseDate?: boolean
    sourceUpdatedAt?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCategories?: boolean | Game$gameCategoriesArgs<ExtArgs>
    tags?: boolean | Game$tagsArgs<ExtArgs>
    translations?: boolean | Game$translationsArgs<ExtArgs>
    votes?: boolean | Game$votesArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    thumbnail?: boolean
    banner?: boolean
    screenshots?: boolean
    videos?: boolean
    embedUrl?: boolean
    gameUrl?: boolean
    dimensions?: boolean
    status?: boolean
    isFeatured?: boolean
    playCount?: boolean
    viewCount?: boolean
    likes?: boolean
    dislikes?: boolean
    rating?: boolean
    ratingCount?: boolean
    qualityScore?: boolean
    sourcePlatform?: boolean
    sourcePlatformId?: boolean
    developer?: boolean
    developerUrl?: boolean
    gameInfo?: boolean
    releaseDate?: boolean
    sourceUpdatedAt?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    thumbnail?: boolean
    banner?: boolean
    screenshots?: boolean
    videos?: boolean
    embedUrl?: boolean
    gameUrl?: boolean
    dimensions?: boolean
    status?: boolean
    isFeatured?: boolean
    playCount?: boolean
    viewCount?: boolean
    likes?: boolean
    dislikes?: boolean
    rating?: boolean
    ratingCount?: boolean
    qualityScore?: boolean
    sourcePlatform?: boolean
    sourcePlatformId?: boolean
    developer?: boolean
    developerUrl?: boolean
    gameInfo?: boolean
    releaseDate?: boolean
    sourceUpdatedAt?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    thumbnail?: boolean
    banner?: boolean
    screenshots?: boolean
    videos?: boolean
    embedUrl?: boolean
    gameUrl?: boolean
    dimensions?: boolean
    status?: boolean
    isFeatured?: boolean
    playCount?: boolean
    viewCount?: boolean
    likes?: boolean
    dislikes?: boolean
    rating?: boolean
    ratingCount?: boolean
    qualityScore?: boolean
    sourcePlatform?: boolean
    sourcePlatformId?: boolean
    developer?: boolean
    developerUrl?: boolean
    gameInfo?: boolean
    releaseDate?: boolean
    sourceUpdatedAt?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "description" | "keywords" | "metaTitle" | "metaDescription" | "thumbnail" | "banner" | "screenshots" | "videos" | "embedUrl" | "gameUrl" | "dimensions" | "status" | "isFeatured" | "playCount" | "viewCount" | "likes" | "dislikes" | "rating" | "ratingCount" | "qualityScore" | "sourcePlatform" | "sourcePlatformId" | "developer" | "developerUrl" | "gameInfo" | "releaseDate" | "sourceUpdatedAt" | "importedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCategories?: boolean | Game$gameCategoriesArgs<ExtArgs>
    tags?: boolean | Game$tagsArgs<ExtArgs>
    translations?: boolean | Game$translationsArgs<ExtArgs>
    votes?: boolean | Game$votesArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      gameCategories: Prisma.$GameCategoryPayload<ExtArgs>[]
      tags: Prisma.$GameTagPayload<ExtArgs>[]
      translations: Prisma.$GameTranslationPayload<ExtArgs>[]
      votes: Prisma.$GameVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string | null
      keywords: string | null
      metaTitle: string | null
      metaDescription: string | null
      thumbnail: string
      banner: string | null
      screenshots: string[]
      videos: string[]
      embedUrl: string
      gameUrl: string | null
      dimensions: Prisma.JsonValue
      status: $Enums.GameStatus
      isFeatured: boolean
      playCount: number
      viewCount: number
      likes: number
      dislikes: number
      rating: number
      ratingCount: number
      qualityScore: number | null
      sourcePlatform: string | null
      sourcePlatformId: string | null
      developer: string | null
      developerUrl: string | null
      gameInfo: Prisma.JsonValue | null
      releaseDate: Date | null
      sourceUpdatedAt: Date | null
      importedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCategories<T extends Game$gameCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Game$gameCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Game$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Game$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends Game$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Game$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Game$votesArgs<ExtArgs> = {}>(args?: Subset<T, Game$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly slug: FieldRef<"Game", 'String'>
    readonly title: FieldRef<"Game", 'String'>
    readonly description: FieldRef<"Game", 'String'>
    readonly keywords: FieldRef<"Game", 'String'>
    readonly metaTitle: FieldRef<"Game", 'String'>
    readonly metaDescription: FieldRef<"Game", 'String'>
    readonly thumbnail: FieldRef<"Game", 'String'>
    readonly banner: FieldRef<"Game", 'String'>
    readonly screenshots: FieldRef<"Game", 'String[]'>
    readonly videos: FieldRef<"Game", 'String[]'>
    readonly embedUrl: FieldRef<"Game", 'String'>
    readonly gameUrl: FieldRef<"Game", 'String'>
    readonly dimensions: FieldRef<"Game", 'Json'>
    readonly status: FieldRef<"Game", 'GameStatus'>
    readonly isFeatured: FieldRef<"Game", 'Boolean'>
    readonly playCount: FieldRef<"Game", 'Int'>
    readonly viewCount: FieldRef<"Game", 'Int'>
    readonly likes: FieldRef<"Game", 'Int'>
    readonly dislikes: FieldRef<"Game", 'Int'>
    readonly rating: FieldRef<"Game", 'Float'>
    readonly ratingCount: FieldRef<"Game", 'Int'>
    readonly qualityScore: FieldRef<"Game", 'Float'>
    readonly sourcePlatform: FieldRef<"Game", 'String'>
    readonly sourcePlatformId: FieldRef<"Game", 'String'>
    readonly developer: FieldRef<"Game", 'String'>
    readonly developerUrl: FieldRef<"Game", 'String'>
    readonly gameInfo: FieldRef<"Game", 'Json'>
    readonly releaseDate: FieldRef<"Game", 'DateTime'>
    readonly sourceUpdatedAt: FieldRef<"Game", 'DateTime'>
    readonly importedAt: FieldRef<"Game", 'DateTime'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.gameCategories
   */
  export type Game$gameCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    where?: GameCategoryWhereInput
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    cursor?: GameCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * Game.tags
   */
  export type Game$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    where?: GameTagWhereInput
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    cursor?: GameTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * Game.translations
   */
  export type Game$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    where?: GameTranslationWhereInput
    orderBy?: GameTranslationOrderByWithRelationInput | GameTranslationOrderByWithRelationInput[]
    cursor?: GameTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameTranslationScalarFieldEnum | GameTranslationScalarFieldEnum[]
  }

  /**
   * Game.votes
   */
  export type Game$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    where?: GameVoteWhereInput
    orderBy?: GameVoteOrderByWithRelationInput | GameVoteOrderByWithRelationInput[]
    cursor?: GameVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameVoteScalarFieldEnum | GameVoteScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model GameTranslation
   */

  export type AggregateGameTranslation = {
    _count: GameTranslationCountAggregateOutputType | null
    _min: GameTranslationMinAggregateOutputType | null
    _max: GameTranslationMaxAggregateOutputType | null
  }

  export type GameTranslationMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    locale: string | null
    title: string | null
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameTranslationMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    locale: string | null
    title: string | null
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameTranslationCountAggregateOutputType = {
    id: number
    gameId: number
    locale: number
    title: number
    description: number
    keywords: number
    metaTitle: number
    metaDescription: number
    translationInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameTranslationMinAggregateInputType = {
    id?: true
    gameId?: true
    locale?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameTranslationMaxAggregateInputType = {
    id?: true
    gameId?: true
    locale?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameTranslationCountAggregateInputType = {
    id?: true
    gameId?: true
    locale?: true
    title?: true
    description?: true
    keywords?: true
    metaTitle?: true
    metaDescription?: true
    translationInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTranslation to aggregate.
     */
    where?: GameTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTranslations to fetch.
     */
    orderBy?: GameTranslationOrderByWithRelationInput | GameTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameTranslations
    **/
    _count?: true | GameTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameTranslationMaxAggregateInputType
  }

  export type GetGameTranslationAggregateType<T extends GameTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateGameTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameTranslation[P]>
      : GetScalarType<T[P], AggregateGameTranslation[P]>
  }




  export type GameTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTranslationWhereInput
    orderBy?: GameTranslationOrderByWithAggregationInput | GameTranslationOrderByWithAggregationInput[]
    by: GameTranslationScalarFieldEnum[] | GameTranslationScalarFieldEnum
    having?: GameTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameTranslationCountAggregateInputType | true
    _min?: GameTranslationMinAggregateInputType
    _max?: GameTranslationMaxAggregateInputType
  }

  export type GameTranslationGroupByOutputType = {
    id: string
    gameId: string
    locale: string
    title: string
    description: string | null
    keywords: string | null
    metaTitle: string | null
    metaDescription: string | null
    translationInfo: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: GameTranslationCountAggregateOutputType | null
    _min: GameTranslationMinAggregateOutputType | null
    _max: GameTranslationMaxAggregateOutputType | null
  }

  type GetGameTranslationGroupByPayload<T extends GameTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], GameTranslationGroupByOutputType[P]>
        }
      >
    >


  export type GameTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    translationInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTranslation"]>

  export type GameTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    translationInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTranslation"]>

  export type GameTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    translationInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTranslation"]>

  export type GameTranslationSelectScalar = {
    id?: boolean
    gameId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    translationInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "locale" | "title" | "description" | "keywords" | "metaTitle" | "metaDescription" | "translationInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["gameTranslation"]>
  export type GameTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameTranslation"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      locale: string
      title: string
      description: string | null
      keywords: string | null
      metaTitle: string | null
      metaDescription: string | null
      translationInfo: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameTranslation"]>
    composites: {}
  }

  type GameTranslationGetPayload<S extends boolean | null | undefined | GameTranslationDefaultArgs> = $Result.GetResult<Prisma.$GameTranslationPayload, S>

  type GameTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameTranslationCountAggregateInputType | true
    }

  export interface GameTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameTranslation'], meta: { name: 'GameTranslation' } }
    /**
     * Find zero or one GameTranslation that matches the filter.
     * @param {GameTranslationFindUniqueArgs} args - Arguments to find a GameTranslation
     * @example
     * // Get one GameTranslation
     * const gameTranslation = await prisma.gameTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameTranslationFindUniqueArgs>(args: SelectSubset<T, GameTranslationFindUniqueArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameTranslationFindUniqueOrThrowArgs} args - Arguments to find a GameTranslation
     * @example
     * // Get one GameTranslation
     * const gameTranslation = await prisma.gameTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, GameTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationFindFirstArgs} args - Arguments to find a GameTranslation
     * @example
     * // Get one GameTranslation
     * const gameTranslation = await prisma.gameTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameTranslationFindFirstArgs>(args?: SelectSubset<T, GameTranslationFindFirstArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationFindFirstOrThrowArgs} args - Arguments to find a GameTranslation
     * @example
     * // Get one GameTranslation
     * const gameTranslation = await prisma.gameTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, GameTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameTranslations
     * const gameTranslations = await prisma.gameTranslation.findMany()
     * 
     * // Get first 10 GameTranslations
     * const gameTranslations = await prisma.gameTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameTranslationWithIdOnly = await prisma.gameTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameTranslationFindManyArgs>(args?: SelectSubset<T, GameTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameTranslation.
     * @param {GameTranslationCreateArgs} args - Arguments to create a GameTranslation.
     * @example
     * // Create one GameTranslation
     * const GameTranslation = await prisma.gameTranslation.create({
     *   data: {
     *     // ... data to create a GameTranslation
     *   }
     * })
     * 
     */
    create<T extends GameTranslationCreateArgs>(args: SelectSubset<T, GameTranslationCreateArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameTranslations.
     * @param {GameTranslationCreateManyArgs} args - Arguments to create many GameTranslations.
     * @example
     * // Create many GameTranslations
     * const gameTranslation = await prisma.gameTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameTranslationCreateManyArgs>(args?: SelectSubset<T, GameTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameTranslations and returns the data saved in the database.
     * @param {GameTranslationCreateManyAndReturnArgs} args - Arguments to create many GameTranslations.
     * @example
     * // Create many GameTranslations
     * const gameTranslation = await prisma.gameTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameTranslations and only return the `id`
     * const gameTranslationWithIdOnly = await prisma.gameTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, GameTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameTranslation.
     * @param {GameTranslationDeleteArgs} args - Arguments to delete one GameTranslation.
     * @example
     * // Delete one GameTranslation
     * const GameTranslation = await prisma.gameTranslation.delete({
     *   where: {
     *     // ... filter to delete one GameTranslation
     *   }
     * })
     * 
     */
    delete<T extends GameTranslationDeleteArgs>(args: SelectSubset<T, GameTranslationDeleteArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameTranslation.
     * @param {GameTranslationUpdateArgs} args - Arguments to update one GameTranslation.
     * @example
     * // Update one GameTranslation
     * const gameTranslation = await prisma.gameTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameTranslationUpdateArgs>(args: SelectSubset<T, GameTranslationUpdateArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameTranslations.
     * @param {GameTranslationDeleteManyArgs} args - Arguments to filter GameTranslations to delete.
     * @example
     * // Delete a few GameTranslations
     * const { count } = await prisma.gameTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameTranslationDeleteManyArgs>(args?: SelectSubset<T, GameTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameTranslations
     * const gameTranslation = await prisma.gameTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameTranslationUpdateManyArgs>(args: SelectSubset<T, GameTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTranslations and returns the data updated in the database.
     * @param {GameTranslationUpdateManyAndReturnArgs} args - Arguments to update many GameTranslations.
     * @example
     * // Update many GameTranslations
     * const gameTranslation = await prisma.gameTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameTranslations and only return the `id`
     * const gameTranslationWithIdOnly = await prisma.gameTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, GameTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameTranslation.
     * @param {GameTranslationUpsertArgs} args - Arguments to update or create a GameTranslation.
     * @example
     * // Update or create a GameTranslation
     * const gameTranslation = await prisma.gameTranslation.upsert({
     *   create: {
     *     // ... data to create a GameTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameTranslation we want to update
     *   }
     * })
     */
    upsert<T extends GameTranslationUpsertArgs>(args: SelectSubset<T, GameTranslationUpsertArgs<ExtArgs>>): Prisma__GameTranslationClient<$Result.GetResult<Prisma.$GameTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationCountArgs} args - Arguments to filter GameTranslations to count.
     * @example
     * // Count the number of GameTranslations
     * const count = await prisma.gameTranslation.count({
     *   where: {
     *     // ... the filter for the GameTranslations we want to count
     *   }
     * })
    **/
    count<T extends GameTranslationCountArgs>(
      args?: Subset<T, GameTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameTranslationAggregateArgs>(args: Subset<T, GameTranslationAggregateArgs>): Prisma.PrismaPromise<GetGameTranslationAggregateType<T>>

    /**
     * Group by GameTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameTranslationGroupByArgs['orderBy'] }
        : { orderBy?: GameTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameTranslation model
   */
  readonly fields: GameTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameTranslation model
   */
  interface GameTranslationFieldRefs {
    readonly id: FieldRef<"GameTranslation", 'String'>
    readonly gameId: FieldRef<"GameTranslation", 'String'>
    readonly locale: FieldRef<"GameTranslation", 'String'>
    readonly title: FieldRef<"GameTranslation", 'String'>
    readonly description: FieldRef<"GameTranslation", 'String'>
    readonly keywords: FieldRef<"GameTranslation", 'String'>
    readonly metaTitle: FieldRef<"GameTranslation", 'String'>
    readonly metaDescription: FieldRef<"GameTranslation", 'String'>
    readonly translationInfo: FieldRef<"GameTranslation", 'Json'>
    readonly createdAt: FieldRef<"GameTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"GameTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameTranslation findUnique
   */
  export type GameTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GameTranslation to fetch.
     */
    where: GameTranslationWhereUniqueInput
  }

  /**
   * GameTranslation findUniqueOrThrow
   */
  export type GameTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GameTranslation to fetch.
     */
    where: GameTranslationWhereUniqueInput
  }

  /**
   * GameTranslation findFirst
   */
  export type GameTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GameTranslation to fetch.
     */
    where?: GameTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTranslations to fetch.
     */
    orderBy?: GameTranslationOrderByWithRelationInput | GameTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTranslations.
     */
    cursor?: GameTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTranslations.
     */
    distinct?: GameTranslationScalarFieldEnum | GameTranslationScalarFieldEnum[]
  }

  /**
   * GameTranslation findFirstOrThrow
   */
  export type GameTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GameTranslation to fetch.
     */
    where?: GameTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTranslations to fetch.
     */
    orderBy?: GameTranslationOrderByWithRelationInput | GameTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTranslations.
     */
    cursor?: GameTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTranslations.
     */
    distinct?: GameTranslationScalarFieldEnum | GameTranslationScalarFieldEnum[]
  }

  /**
   * GameTranslation findMany
   */
  export type GameTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter, which GameTranslations to fetch.
     */
    where?: GameTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTranslations to fetch.
     */
    orderBy?: GameTranslationOrderByWithRelationInput | GameTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameTranslations.
     */
    cursor?: GameTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTranslations.
     */
    skip?: number
    distinct?: GameTranslationScalarFieldEnum | GameTranslationScalarFieldEnum[]
  }

  /**
   * GameTranslation create
   */
  export type GameTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a GameTranslation.
     */
    data: XOR<GameTranslationCreateInput, GameTranslationUncheckedCreateInput>
  }

  /**
   * GameTranslation createMany
   */
  export type GameTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameTranslations.
     */
    data: GameTranslationCreateManyInput | GameTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameTranslation createManyAndReturn
   */
  export type GameTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many GameTranslations.
     */
    data: GameTranslationCreateManyInput | GameTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameTranslation update
   */
  export type GameTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a GameTranslation.
     */
    data: XOR<GameTranslationUpdateInput, GameTranslationUncheckedUpdateInput>
    /**
     * Choose, which GameTranslation to update.
     */
    where: GameTranslationWhereUniqueInput
  }

  /**
   * GameTranslation updateMany
   */
  export type GameTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameTranslations.
     */
    data: XOR<GameTranslationUpdateManyMutationInput, GameTranslationUncheckedUpdateManyInput>
    /**
     * Filter which GameTranslations to update
     */
    where?: GameTranslationWhereInput
    /**
     * Limit how many GameTranslations to update.
     */
    limit?: number
  }

  /**
   * GameTranslation updateManyAndReturn
   */
  export type GameTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * The data used to update GameTranslations.
     */
    data: XOR<GameTranslationUpdateManyMutationInput, GameTranslationUncheckedUpdateManyInput>
    /**
     * Filter which GameTranslations to update
     */
    where?: GameTranslationWhereInput
    /**
     * Limit how many GameTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameTranslation upsert
   */
  export type GameTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the GameTranslation to update in case it exists.
     */
    where: GameTranslationWhereUniqueInput
    /**
     * In case the GameTranslation found by the `where` argument doesn't exist, create a new GameTranslation with this data.
     */
    create: XOR<GameTranslationCreateInput, GameTranslationUncheckedCreateInput>
    /**
     * In case the GameTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameTranslationUpdateInput, GameTranslationUncheckedUpdateInput>
  }

  /**
   * GameTranslation delete
   */
  export type GameTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
    /**
     * Filter which GameTranslation to delete.
     */
    where: GameTranslationWhereUniqueInput
  }

  /**
   * GameTranslation deleteMany
   */
  export type GameTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTranslations to delete
     */
    where?: GameTranslationWhereInput
    /**
     * Limit how many GameTranslations to delete.
     */
    limit?: number
  }

  /**
   * GameTranslation without action
   */
  export type GameTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTranslation
     */
    select?: GameTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTranslation
     */
    omit?: GameTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTranslationInclude<ExtArgs> | null
  }


  /**
   * Model GameTag
   */

  export type AggregateGameTag = {
    _count: GameTagCountAggregateOutputType | null
    _min: GameTagMinAggregateOutputType | null
    _max: GameTagMaxAggregateOutputType | null
  }

  export type GameTagMinAggregateOutputType = {
    gameId: string | null
    tagId: string | null
  }

  export type GameTagMaxAggregateOutputType = {
    gameId: string | null
    tagId: string | null
  }

  export type GameTagCountAggregateOutputType = {
    gameId: number
    tagId: number
    _all: number
  }


  export type GameTagMinAggregateInputType = {
    gameId?: true
    tagId?: true
  }

  export type GameTagMaxAggregateInputType = {
    gameId?: true
    tagId?: true
  }

  export type GameTagCountAggregateInputType = {
    gameId?: true
    tagId?: true
    _all?: true
  }

  export type GameTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTag to aggregate.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameTags
    **/
    _count?: true | GameTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameTagMaxAggregateInputType
  }

  export type GetGameTagAggregateType<T extends GameTagAggregateArgs> = {
        [P in keyof T & keyof AggregateGameTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameTag[P]>
      : GetScalarType<T[P], AggregateGameTag[P]>
  }




  export type GameTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameTagWhereInput
    orderBy?: GameTagOrderByWithAggregationInput | GameTagOrderByWithAggregationInput[]
    by: GameTagScalarFieldEnum[] | GameTagScalarFieldEnum
    having?: GameTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameTagCountAggregateInputType | true
    _min?: GameTagMinAggregateInputType
    _max?: GameTagMaxAggregateInputType
  }

  export type GameTagGroupByOutputType = {
    gameId: string
    tagId: string
    _count: GameTagCountAggregateOutputType | null
    _min: GameTagMinAggregateOutputType | null
    _max: GameTagMaxAggregateOutputType | null
  }

  type GetGameTagGroupByPayload<T extends GameTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameTagGroupByOutputType[P]>
            : GetScalarType<T[P], GameTagGroupByOutputType[P]>
        }
      >
    >


  export type GameTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gameId?: boolean
    tagId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gameId?: boolean
    tagId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gameId?: boolean
    tagId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameTag"]>

  export type GameTagSelectScalar = {
    gameId?: boolean
    tagId?: boolean
  }

  export type GameTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"gameId" | "tagId", ExtArgs["result"]["gameTag"]>
  export type GameTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type GameTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type GameTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $GameTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameTag"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      gameId: string
      tagId: string
    }, ExtArgs["result"]["gameTag"]>
    composites: {}
  }

  type GameTagGetPayload<S extends boolean | null | undefined | GameTagDefaultArgs> = $Result.GetResult<Prisma.$GameTagPayload, S>

  type GameTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameTagCountAggregateInputType | true
    }

  export interface GameTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameTag'], meta: { name: 'GameTag' } }
    /**
     * Find zero or one GameTag that matches the filter.
     * @param {GameTagFindUniqueArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameTagFindUniqueArgs>(args: SelectSubset<T, GameTagFindUniqueArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameTagFindUniqueOrThrowArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameTagFindUniqueOrThrowArgs>(args: SelectSubset<T, GameTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindFirstArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameTagFindFirstArgs>(args?: SelectSubset<T, GameTagFindFirstArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindFirstOrThrowArgs} args - Arguments to find a GameTag
     * @example
     * // Get one GameTag
     * const gameTag = await prisma.gameTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameTagFindFirstOrThrowArgs>(args?: SelectSubset<T, GameTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameTags
     * const gameTags = await prisma.gameTag.findMany()
     * 
     * // Get first 10 GameTags
     * const gameTags = await prisma.gameTag.findMany({ take: 10 })
     * 
     * // Only select the `gameId`
     * const gameTagWithGameIdOnly = await prisma.gameTag.findMany({ select: { gameId: true } })
     * 
     */
    findMany<T extends GameTagFindManyArgs>(args?: SelectSubset<T, GameTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameTag.
     * @param {GameTagCreateArgs} args - Arguments to create a GameTag.
     * @example
     * // Create one GameTag
     * const GameTag = await prisma.gameTag.create({
     *   data: {
     *     // ... data to create a GameTag
     *   }
     * })
     * 
     */
    create<T extends GameTagCreateArgs>(args: SelectSubset<T, GameTagCreateArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameTags.
     * @param {GameTagCreateManyArgs} args - Arguments to create many GameTags.
     * @example
     * // Create many GameTags
     * const gameTag = await prisma.gameTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameTagCreateManyArgs>(args?: SelectSubset<T, GameTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameTags and returns the data saved in the database.
     * @param {GameTagCreateManyAndReturnArgs} args - Arguments to create many GameTags.
     * @example
     * // Create many GameTags
     * const gameTag = await prisma.gameTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameTags and only return the `gameId`
     * const gameTagWithGameIdOnly = await prisma.gameTag.createManyAndReturn({
     *   select: { gameId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameTagCreateManyAndReturnArgs>(args?: SelectSubset<T, GameTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameTag.
     * @param {GameTagDeleteArgs} args - Arguments to delete one GameTag.
     * @example
     * // Delete one GameTag
     * const GameTag = await prisma.gameTag.delete({
     *   where: {
     *     // ... filter to delete one GameTag
     *   }
     * })
     * 
     */
    delete<T extends GameTagDeleteArgs>(args: SelectSubset<T, GameTagDeleteArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameTag.
     * @param {GameTagUpdateArgs} args - Arguments to update one GameTag.
     * @example
     * // Update one GameTag
     * const gameTag = await prisma.gameTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameTagUpdateArgs>(args: SelectSubset<T, GameTagUpdateArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameTags.
     * @param {GameTagDeleteManyArgs} args - Arguments to filter GameTags to delete.
     * @example
     * // Delete a few GameTags
     * const { count } = await prisma.gameTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameTagDeleteManyArgs>(args?: SelectSubset<T, GameTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameTags
     * const gameTag = await prisma.gameTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameTagUpdateManyArgs>(args: SelectSubset<T, GameTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameTags and returns the data updated in the database.
     * @param {GameTagUpdateManyAndReturnArgs} args - Arguments to update many GameTags.
     * @example
     * // Update many GameTags
     * const gameTag = await prisma.gameTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameTags and only return the `gameId`
     * const gameTagWithGameIdOnly = await prisma.gameTag.updateManyAndReturn({
     *   select: { gameId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameTagUpdateManyAndReturnArgs>(args: SelectSubset<T, GameTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameTag.
     * @param {GameTagUpsertArgs} args - Arguments to update or create a GameTag.
     * @example
     * // Update or create a GameTag
     * const gameTag = await prisma.gameTag.upsert({
     *   create: {
     *     // ... data to create a GameTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameTag we want to update
     *   }
     * })
     */
    upsert<T extends GameTagUpsertArgs>(args: SelectSubset<T, GameTagUpsertArgs<ExtArgs>>): Prisma__GameTagClient<$Result.GetResult<Prisma.$GameTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagCountArgs} args - Arguments to filter GameTags to count.
     * @example
     * // Count the number of GameTags
     * const count = await prisma.gameTag.count({
     *   where: {
     *     // ... the filter for the GameTags we want to count
     *   }
     * })
    **/
    count<T extends GameTagCountArgs>(
      args?: Subset<T, GameTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameTagAggregateArgs>(args: Subset<T, GameTagAggregateArgs>): Prisma.PrismaPromise<GetGameTagAggregateType<T>>

    /**
     * Group by GameTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameTagGroupByArgs['orderBy'] }
        : { orderBy?: GameTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameTag model
   */
  readonly fields: GameTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameTag model
   */
  interface GameTagFieldRefs {
    readonly gameId: FieldRef<"GameTag", 'String'>
    readonly tagId: FieldRef<"GameTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GameTag findUnique
   */
  export type GameTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag findUniqueOrThrow
   */
  export type GameTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag findFirst
   */
  export type GameTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTags.
     */
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag findFirstOrThrow
   */
  export type GameTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTag to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameTags.
     */
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag findMany
   */
  export type GameTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter, which GameTags to fetch.
     */
    where?: GameTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameTags to fetch.
     */
    orderBy?: GameTagOrderByWithRelationInput | GameTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameTags.
     */
    cursor?: GameTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameTags.
     */
    skip?: number
    distinct?: GameTagScalarFieldEnum | GameTagScalarFieldEnum[]
  }

  /**
   * GameTag create
   */
  export type GameTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The data needed to create a GameTag.
     */
    data: XOR<GameTagCreateInput, GameTagUncheckedCreateInput>
  }

  /**
   * GameTag createMany
   */
  export type GameTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameTags.
     */
    data: GameTagCreateManyInput | GameTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameTag createManyAndReturn
   */
  export type GameTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * The data used to create many GameTags.
     */
    data: GameTagCreateManyInput | GameTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameTag update
   */
  export type GameTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The data needed to update a GameTag.
     */
    data: XOR<GameTagUpdateInput, GameTagUncheckedUpdateInput>
    /**
     * Choose, which GameTag to update.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag updateMany
   */
  export type GameTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameTags.
     */
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyInput>
    /**
     * Filter which GameTags to update
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to update.
     */
    limit?: number
  }

  /**
   * GameTag updateManyAndReturn
   */
  export type GameTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * The data used to update GameTags.
     */
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyInput>
    /**
     * Filter which GameTags to update
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameTag upsert
   */
  export type GameTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * The filter to search for the GameTag to update in case it exists.
     */
    where: GameTagWhereUniqueInput
    /**
     * In case the GameTag found by the `where` argument doesn't exist, create a new GameTag with this data.
     */
    create: XOR<GameTagCreateInput, GameTagUncheckedCreateInput>
    /**
     * In case the GameTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameTagUpdateInput, GameTagUncheckedUpdateInput>
  }

  /**
   * GameTag delete
   */
  export type GameTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
    /**
     * Filter which GameTag to delete.
     */
    where: GameTagWhereUniqueInput
  }

  /**
   * GameTag deleteMany
   */
  export type GameTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameTags to delete
     */
    where?: GameTagWhereInput
    /**
     * Limit how many GameTags to delete.
     */
    limit?: number
  }

  /**
   * GameTag without action
   */
  export type GameTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameTag
     */
    select?: GameTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameTag
     */
    omit?: GameTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameTagInclude<ExtArgs> | null
  }


  /**
   * Model GameCategory
   */

  export type AggregateGameCategory = {
    _count: GameCategoryCountAggregateOutputType | null
    _avg: GameCategoryAvgAggregateOutputType | null
    _sum: GameCategorySumAggregateOutputType | null
    _min: GameCategoryMinAggregateOutputType | null
    _max: GameCategoryMaxAggregateOutputType | null
  }

  export type GameCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type GameCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type GameCategoryMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    categoryId: string | null
    mainCategoryId: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCategoryMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    categoryId: string | null
    mainCategoryId: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCategoryCountAggregateOutputType = {
    id: number
    gameId: number
    categoryId: number
    mainCategoryId: number
    isPrimary: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type GameCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type GameCategoryMinAggregateInputType = {
    id?: true
    gameId?: true
    categoryId?: true
    mainCategoryId?: true
    isPrimary?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCategoryMaxAggregateInputType = {
    id?: true
    gameId?: true
    categoryId?: true
    mainCategoryId?: true
    isPrimary?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCategoryCountAggregateInputType = {
    id?: true
    gameId?: true
    categoryId?: true
    mainCategoryId?: true
    isPrimary?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCategory to aggregate.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameCategories
    **/
    _count?: true | GameCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameCategoryMaxAggregateInputType
  }

  export type GetGameCategoryAggregateType<T extends GameCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGameCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameCategory[P]>
      : GetScalarType<T[P], AggregateGameCategory[P]>
  }




  export type GameCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCategoryWhereInput
    orderBy?: GameCategoryOrderByWithAggregationInput | GameCategoryOrderByWithAggregationInput[]
    by: GameCategoryScalarFieldEnum[] | GameCategoryScalarFieldEnum
    having?: GameCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCategoryCountAggregateInputType | true
    _avg?: GameCategoryAvgAggregateInputType
    _sum?: GameCategorySumAggregateInputType
    _min?: GameCategoryMinAggregateInputType
    _max?: GameCategoryMaxAggregateInputType
  }

  export type GameCategoryGroupByOutputType = {
    id: string
    gameId: string
    categoryId: string
    mainCategoryId: string
    isPrimary: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: GameCategoryCountAggregateOutputType | null
    _avg: GameCategoryAvgAggregateOutputType | null
    _sum: GameCategorySumAggregateOutputType | null
    _min: GameCategoryMinAggregateOutputType | null
    _max: GameCategoryMaxAggregateOutputType | null
  }

  type GetGameCategoryGroupByPayload<T extends GameCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], GameCategoryGroupByOutputType[P]>
        }
      >
    >


  export type GameCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    categoryId?: boolean
    mainCategoryId?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    categoryId?: boolean
    mainCategoryId?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    categoryId?: boolean
    mainCategoryId?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectScalar = {
    id?: boolean
    gameId?: boolean
    categoryId?: boolean
    mainCategoryId?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "categoryId" | "mainCategoryId" | "isPrimary" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["gameCategory"]>
  export type GameCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type GameCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type GameCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    mainCategory?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $GameCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameCategory"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      mainCategory: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      categoryId: string
      mainCategoryId: string
      isPrimary: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameCategory"]>
    composites: {}
  }

  type GameCategoryGetPayload<S extends boolean | null | undefined | GameCategoryDefaultArgs> = $Result.GetResult<Prisma.$GameCategoryPayload, S>

  type GameCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCategoryCountAggregateInputType | true
    }

  export interface GameCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameCategory'], meta: { name: 'GameCategory' } }
    /**
     * Find zero or one GameCategory that matches the filter.
     * @param {GameCategoryFindUniqueArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameCategoryFindUniqueArgs>(args: SelectSubset<T, GameCategoryFindUniqueArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameCategoryFindUniqueOrThrowArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GameCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindFirstArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameCategoryFindFirstArgs>(args?: SelectSubset<T, GameCategoryFindFirstArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindFirstOrThrowArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GameCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameCategories
     * const gameCategories = await prisma.gameCategory.findMany()
     * 
     * // Get first 10 GameCategories
     * const gameCategories = await prisma.gameCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameCategoryFindManyArgs>(args?: SelectSubset<T, GameCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameCategory.
     * @param {GameCategoryCreateArgs} args - Arguments to create a GameCategory.
     * @example
     * // Create one GameCategory
     * const GameCategory = await prisma.gameCategory.create({
     *   data: {
     *     // ... data to create a GameCategory
     *   }
     * })
     * 
     */
    create<T extends GameCategoryCreateArgs>(args: SelectSubset<T, GameCategoryCreateArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameCategories.
     * @param {GameCategoryCreateManyArgs} args - Arguments to create many GameCategories.
     * @example
     * // Create many GameCategories
     * const gameCategory = await prisma.gameCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCategoryCreateManyArgs>(args?: SelectSubset<T, GameCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameCategories and returns the data saved in the database.
     * @param {GameCategoryCreateManyAndReturnArgs} args - Arguments to create many GameCategories.
     * @example
     * // Create many GameCategories
     * const gameCategory = await prisma.gameCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameCategories and only return the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameCategory.
     * @param {GameCategoryDeleteArgs} args - Arguments to delete one GameCategory.
     * @example
     * // Delete one GameCategory
     * const GameCategory = await prisma.gameCategory.delete({
     *   where: {
     *     // ... filter to delete one GameCategory
     *   }
     * })
     * 
     */
    delete<T extends GameCategoryDeleteArgs>(args: SelectSubset<T, GameCategoryDeleteArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameCategory.
     * @param {GameCategoryUpdateArgs} args - Arguments to update one GameCategory.
     * @example
     * // Update one GameCategory
     * const gameCategory = await prisma.gameCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameCategoryUpdateArgs>(args: SelectSubset<T, GameCategoryUpdateArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameCategories.
     * @param {GameCategoryDeleteManyArgs} args - Arguments to filter GameCategories to delete.
     * @example
     * // Delete a few GameCategories
     * const { count } = await prisma.gameCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameCategoryDeleteManyArgs>(args?: SelectSubset<T, GameCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameCategories
     * const gameCategory = await prisma.gameCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameCategoryUpdateManyArgs>(args: SelectSubset<T, GameCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameCategories and returns the data updated in the database.
     * @param {GameCategoryUpdateManyAndReturnArgs} args - Arguments to update many GameCategories.
     * @example
     * // Update many GameCategories
     * const gameCategory = await prisma.gameCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameCategories and only return the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GameCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameCategory.
     * @param {GameCategoryUpsertArgs} args - Arguments to update or create a GameCategory.
     * @example
     * // Update or create a GameCategory
     * const gameCategory = await prisma.gameCategory.upsert({
     *   create: {
     *     // ... data to create a GameCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameCategory we want to update
     *   }
     * })
     */
    upsert<T extends GameCategoryUpsertArgs>(args: SelectSubset<T, GameCategoryUpsertArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryCountArgs} args - Arguments to filter GameCategories to count.
     * @example
     * // Count the number of GameCategories
     * const count = await prisma.gameCategory.count({
     *   where: {
     *     // ... the filter for the GameCategories we want to count
     *   }
     * })
    **/
    count<T extends GameCategoryCountArgs>(
      args?: Subset<T, GameCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameCategoryAggregateArgs>(args: Subset<T, GameCategoryAggregateArgs>): Prisma.PrismaPromise<GetGameCategoryAggregateType<T>>

    /**
     * Group by GameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameCategoryGroupByArgs['orderBy'] }
        : { orderBy?: GameCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameCategory model
   */
  readonly fields: GameCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mainCategory<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameCategory model
   */
  interface GameCategoryFieldRefs {
    readonly id: FieldRef<"GameCategory", 'String'>
    readonly gameId: FieldRef<"GameCategory", 'String'>
    readonly categoryId: FieldRef<"GameCategory", 'String'>
    readonly mainCategoryId: FieldRef<"GameCategory", 'String'>
    readonly isPrimary: FieldRef<"GameCategory", 'Boolean'>
    readonly sortOrder: FieldRef<"GameCategory", 'Int'>
    readonly createdAt: FieldRef<"GameCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"GameCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameCategory findUnique
   */
  export type GameCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory findUniqueOrThrow
   */
  export type GameCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory findFirst
   */
  export type GameCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCategories.
     */
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory findFirstOrThrow
   */
  export type GameCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCategories.
     */
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory findMany
   */
  export type GameCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategories to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory create
   */
  export type GameCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GameCategory.
     */
    data: XOR<GameCategoryCreateInput, GameCategoryUncheckedCreateInput>
  }

  /**
   * GameCategory createMany
   */
  export type GameCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameCategories.
     */
    data: GameCategoryCreateManyInput | GameCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameCategory createManyAndReturn
   */
  export type GameCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many GameCategories.
     */
    data: GameCategoryCreateManyInput | GameCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameCategory update
   */
  export type GameCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GameCategory.
     */
    data: XOR<GameCategoryUpdateInput, GameCategoryUncheckedUpdateInput>
    /**
     * Choose, which GameCategory to update.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory updateMany
   */
  export type GameCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameCategories.
     */
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GameCategories to update
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to update.
     */
    limit?: number
  }

  /**
   * GameCategory updateManyAndReturn
   */
  export type GameCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * The data used to update GameCategories.
     */
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GameCategories to update
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameCategory upsert
   */
  export type GameCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GameCategory to update in case it exists.
     */
    where: GameCategoryWhereUniqueInput
    /**
     * In case the GameCategory found by the `where` argument doesn't exist, create a new GameCategory with this data.
     */
    create: XOR<GameCategoryCreateInput, GameCategoryUncheckedCreateInput>
    /**
     * In case the GameCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameCategoryUpdateInput, GameCategoryUncheckedUpdateInput>
  }

  /**
   * GameCategory delete
   */
  export type GameCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter which GameCategory to delete.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory deleteMany
   */
  export type GameCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCategories to delete
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to delete.
     */
    limit?: number
  }

  /**
   * GameCategory without action
   */
  export type GameCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
  }


  /**
   * Model PageType
   */

  export type AggregatePageType = {
    _count: PageTypeCountAggregateOutputType | null
    _avg: PageTypeAvgAggregateOutputType | null
    _sum: PageTypeSumAggregateOutputType | null
    _min: PageTypeMinAggregateOutputType | null
    _max: PageTypeMaxAggregateOutputType | null
  }

  export type PageTypeAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PageTypeSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PageTypeMinAggregateOutputType = {
    id: string | null
    slug: string | null
    type: $Enums.PageTypeEnum | null
    icon: string | null
    isEnabled: boolean | null
    sortOrder: number | null
    title: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTypeMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    type: $Enums.PageTypeEnum | null
    icon: string | null
    isEnabled: boolean | null
    sortOrder: number | null
    title: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTypeCountAggregateOutputType = {
    id: number
    slug: number
    type: number
    icon: number
    isEnabled: number
    sortOrder: number
    title: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    pageInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageTypeAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PageTypeSumAggregateInputType = {
    sortOrder?: true
  }

  export type PageTypeMinAggregateInputType = {
    id?: true
    slug?: true
    type?: true
    icon?: true
    isEnabled?: true
    sortOrder?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTypeMaxAggregateInputType = {
    id?: true
    slug?: true
    type?: true
    icon?: true
    isEnabled?: true
    sortOrder?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTypeCountAggregateInputType = {
    id?: true
    slug?: true
    type?: true
    icon?: true
    isEnabled?: true
    sortOrder?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    pageInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageType to aggregate.
     */
    where?: PageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypes to fetch.
     */
    orderBy?: PageTypeOrderByWithRelationInput | PageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageTypes
    **/
    _count?: true | PageTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageTypeMaxAggregateInputType
  }

  export type GetPageTypeAggregateType<T extends PageTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePageType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageType[P]>
      : GetScalarType<T[P], AggregatePageType[P]>
  }




  export type PageTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTypeWhereInput
    orderBy?: PageTypeOrderByWithAggregationInput | PageTypeOrderByWithAggregationInput[]
    by: PageTypeScalarFieldEnum[] | PageTypeScalarFieldEnum
    having?: PageTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageTypeCountAggregateInputType | true
    _avg?: PageTypeAvgAggregateInputType
    _sum?: PageTypeSumAggregateInputType
    _min?: PageTypeMinAggregateInputType
    _max?: PageTypeMaxAggregateInputType
  }

  export type PageTypeGroupByOutputType = {
    id: string
    slug: string
    type: $Enums.PageTypeEnum
    icon: string | null
    isEnabled: boolean
    sortOrder: number
    title: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    pageInfo: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PageTypeCountAggregateOutputType | null
    _avg: PageTypeAvgAggregateOutputType | null
    _sum: PageTypeSumAggregateOutputType | null
    _min: PageTypeMinAggregateOutputType | null
    _max: PageTypeMaxAggregateOutputType | null
  }

  type GetPageTypeGroupByPayload<T extends PageTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PageTypeGroupByOutputType[P]>
        }
      >
    >


  export type PageTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    type?: boolean
    icon?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | PageType$translationsArgs<ExtArgs>
    _count?: boolean | PageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageType"]>

  export type PageTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    type?: boolean
    icon?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pageType"]>

  export type PageTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    type?: boolean
    icon?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pageType"]>

  export type PageTypeSelectScalar = {
    id?: boolean
    slug?: boolean
    type?: boolean
    icon?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "type" | "icon" | "isEnabled" | "sortOrder" | "title" | "description" | "metaTitle" | "metaDescription" | "keywords" | "pageInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["pageType"]>
  export type PageTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | PageType$translationsArgs<ExtArgs>
    _count?: boolean | PageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PageTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PageTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PageTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageType"
    objects: {
      translations: Prisma.$PageTypeTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      type: $Enums.PageTypeEnum
      icon: string | null
      isEnabled: boolean
      sortOrder: number
      title: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      pageInfo: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pageType"]>
    composites: {}
  }

  type PageTypeGetPayload<S extends boolean | null | undefined | PageTypeDefaultArgs> = $Result.GetResult<Prisma.$PageTypePayload, S>

  type PageTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageTypeCountAggregateInputType | true
    }

  export interface PageTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageType'], meta: { name: 'PageType' } }
    /**
     * Find zero or one PageType that matches the filter.
     * @param {PageTypeFindUniqueArgs} args - Arguments to find a PageType
     * @example
     * // Get one PageType
     * const pageType = await prisma.pageType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageTypeFindUniqueArgs>(args: SelectSubset<T, PageTypeFindUniqueArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageTypeFindUniqueOrThrowArgs} args - Arguments to find a PageType
     * @example
     * // Get one PageType
     * const pageType = await prisma.pageType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PageTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeFindFirstArgs} args - Arguments to find a PageType
     * @example
     * // Get one PageType
     * const pageType = await prisma.pageType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageTypeFindFirstArgs>(args?: SelectSubset<T, PageTypeFindFirstArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeFindFirstOrThrowArgs} args - Arguments to find a PageType
     * @example
     * // Get one PageType
     * const pageType = await prisma.pageType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PageTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageTypes
     * const pageTypes = await prisma.pageType.findMany()
     * 
     * // Get first 10 PageTypes
     * const pageTypes = await prisma.pageType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageTypeWithIdOnly = await prisma.pageType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageTypeFindManyArgs>(args?: SelectSubset<T, PageTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageType.
     * @param {PageTypeCreateArgs} args - Arguments to create a PageType.
     * @example
     * // Create one PageType
     * const PageType = await prisma.pageType.create({
     *   data: {
     *     // ... data to create a PageType
     *   }
     * })
     * 
     */
    create<T extends PageTypeCreateArgs>(args: SelectSubset<T, PageTypeCreateArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageTypes.
     * @param {PageTypeCreateManyArgs} args - Arguments to create many PageTypes.
     * @example
     * // Create many PageTypes
     * const pageType = await prisma.pageType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageTypeCreateManyArgs>(args?: SelectSubset<T, PageTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageTypes and returns the data saved in the database.
     * @param {PageTypeCreateManyAndReturnArgs} args - Arguments to create many PageTypes.
     * @example
     * // Create many PageTypes
     * const pageType = await prisma.pageType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageTypes and only return the `id`
     * const pageTypeWithIdOnly = await prisma.pageType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PageTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageType.
     * @param {PageTypeDeleteArgs} args - Arguments to delete one PageType.
     * @example
     * // Delete one PageType
     * const PageType = await prisma.pageType.delete({
     *   where: {
     *     // ... filter to delete one PageType
     *   }
     * })
     * 
     */
    delete<T extends PageTypeDeleteArgs>(args: SelectSubset<T, PageTypeDeleteArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageType.
     * @param {PageTypeUpdateArgs} args - Arguments to update one PageType.
     * @example
     * // Update one PageType
     * const pageType = await prisma.pageType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageTypeUpdateArgs>(args: SelectSubset<T, PageTypeUpdateArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageTypes.
     * @param {PageTypeDeleteManyArgs} args - Arguments to filter PageTypes to delete.
     * @example
     * // Delete a few PageTypes
     * const { count } = await prisma.pageType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageTypeDeleteManyArgs>(args?: SelectSubset<T, PageTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageTypes
     * const pageType = await prisma.pageType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageTypeUpdateManyArgs>(args: SelectSubset<T, PageTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTypes and returns the data updated in the database.
     * @param {PageTypeUpdateManyAndReturnArgs} args - Arguments to update many PageTypes.
     * @example
     * // Update many PageTypes
     * const pageType = await prisma.pageType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageTypes and only return the `id`
     * const pageTypeWithIdOnly = await prisma.pageType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PageTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageType.
     * @param {PageTypeUpsertArgs} args - Arguments to update or create a PageType.
     * @example
     * // Update or create a PageType
     * const pageType = await prisma.pageType.upsert({
     *   create: {
     *     // ... data to create a PageType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageType we want to update
     *   }
     * })
     */
    upsert<T extends PageTypeUpsertArgs>(args: SelectSubset<T, PageTypeUpsertArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeCountArgs} args - Arguments to filter PageTypes to count.
     * @example
     * // Count the number of PageTypes
     * const count = await prisma.pageType.count({
     *   where: {
     *     // ... the filter for the PageTypes we want to count
     *   }
     * })
    **/
    count<T extends PageTypeCountArgs>(
      args?: Subset<T, PageTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageTypeAggregateArgs>(args: Subset<T, PageTypeAggregateArgs>): Prisma.PrismaPromise<GetPageTypeAggregateType<T>>

    /**
     * Group by PageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageTypeGroupByArgs['orderBy'] }
        : { orderBy?: PageTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageType model
   */
  readonly fields: PageTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends PageType$translationsArgs<ExtArgs> = {}>(args?: Subset<T, PageType$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageType model
   */
  interface PageTypeFieldRefs {
    readonly id: FieldRef<"PageType", 'String'>
    readonly slug: FieldRef<"PageType", 'String'>
    readonly type: FieldRef<"PageType", 'PageTypeEnum'>
    readonly icon: FieldRef<"PageType", 'String'>
    readonly isEnabled: FieldRef<"PageType", 'Boolean'>
    readonly sortOrder: FieldRef<"PageType", 'Int'>
    readonly title: FieldRef<"PageType", 'String'>
    readonly description: FieldRef<"PageType", 'String'>
    readonly metaTitle: FieldRef<"PageType", 'String'>
    readonly metaDescription: FieldRef<"PageType", 'String'>
    readonly keywords: FieldRef<"PageType", 'String'>
    readonly pageInfo: FieldRef<"PageType", 'Json'>
    readonly createdAt: FieldRef<"PageType", 'DateTime'>
    readonly updatedAt: FieldRef<"PageType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageType findUnique
   */
  export type PageTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter, which PageType to fetch.
     */
    where: PageTypeWhereUniqueInput
  }

  /**
   * PageType findUniqueOrThrow
   */
  export type PageTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter, which PageType to fetch.
     */
    where: PageTypeWhereUniqueInput
  }

  /**
   * PageType findFirst
   */
  export type PageTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter, which PageType to fetch.
     */
    where?: PageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypes to fetch.
     */
    orderBy?: PageTypeOrderByWithRelationInput | PageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTypes.
     */
    cursor?: PageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTypes.
     */
    distinct?: PageTypeScalarFieldEnum | PageTypeScalarFieldEnum[]
  }

  /**
   * PageType findFirstOrThrow
   */
  export type PageTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter, which PageType to fetch.
     */
    where?: PageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypes to fetch.
     */
    orderBy?: PageTypeOrderByWithRelationInput | PageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTypes.
     */
    cursor?: PageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTypes.
     */
    distinct?: PageTypeScalarFieldEnum | PageTypeScalarFieldEnum[]
  }

  /**
   * PageType findMany
   */
  export type PageTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter, which PageTypes to fetch.
     */
    where?: PageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypes to fetch.
     */
    orderBy?: PageTypeOrderByWithRelationInput | PageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageTypes.
     */
    cursor?: PageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypes.
     */
    skip?: number
    distinct?: PageTypeScalarFieldEnum | PageTypeScalarFieldEnum[]
  }

  /**
   * PageType create
   */
  export type PageTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PageType.
     */
    data: XOR<PageTypeCreateInput, PageTypeUncheckedCreateInput>
  }

  /**
   * PageType createMany
   */
  export type PageTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageTypes.
     */
    data: PageTypeCreateManyInput | PageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageType createManyAndReturn
   */
  export type PageTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PageTypes.
     */
    data: PageTypeCreateManyInput | PageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageType update
   */
  export type PageTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PageType.
     */
    data: XOR<PageTypeUpdateInput, PageTypeUncheckedUpdateInput>
    /**
     * Choose, which PageType to update.
     */
    where: PageTypeWhereUniqueInput
  }

  /**
   * PageType updateMany
   */
  export type PageTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageTypes.
     */
    data: XOR<PageTypeUpdateManyMutationInput, PageTypeUncheckedUpdateManyInput>
    /**
     * Filter which PageTypes to update
     */
    where?: PageTypeWhereInput
    /**
     * Limit how many PageTypes to update.
     */
    limit?: number
  }

  /**
   * PageType updateManyAndReturn
   */
  export type PageTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * The data used to update PageTypes.
     */
    data: XOR<PageTypeUpdateManyMutationInput, PageTypeUncheckedUpdateManyInput>
    /**
     * Filter which PageTypes to update
     */
    where?: PageTypeWhereInput
    /**
     * Limit how many PageTypes to update.
     */
    limit?: number
  }

  /**
   * PageType upsert
   */
  export type PageTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PageType to update in case it exists.
     */
    where: PageTypeWhereUniqueInput
    /**
     * In case the PageType found by the `where` argument doesn't exist, create a new PageType with this data.
     */
    create: XOR<PageTypeCreateInput, PageTypeUncheckedCreateInput>
    /**
     * In case the PageType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageTypeUpdateInput, PageTypeUncheckedUpdateInput>
  }

  /**
   * PageType delete
   */
  export type PageTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
    /**
     * Filter which PageType to delete.
     */
    where: PageTypeWhereUniqueInput
  }

  /**
   * PageType deleteMany
   */
  export type PageTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTypes to delete
     */
    where?: PageTypeWhereInput
    /**
     * Limit how many PageTypes to delete.
     */
    limit?: number
  }

  /**
   * PageType.translations
   */
  export type PageType$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    where?: PageTypeTranslationWhereInput
    orderBy?: PageTypeTranslationOrderByWithRelationInput | PageTypeTranslationOrderByWithRelationInput[]
    cursor?: PageTypeTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTypeTranslationScalarFieldEnum | PageTypeTranslationScalarFieldEnum[]
  }

  /**
   * PageType without action
   */
  export type PageTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageType
     */
    select?: PageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageType
     */
    omit?: PageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeInclude<ExtArgs> | null
  }


  /**
   * Model PageTypeTranslation
   */

  export type AggregatePageTypeTranslation = {
    _count: PageTypeTranslationCountAggregateOutputType | null
    _min: PageTypeTranslationMinAggregateOutputType | null
    _max: PageTypeTranslationMaxAggregateOutputType | null
  }

  export type PageTypeTranslationMinAggregateOutputType = {
    id: string | null
    pageTypeId: string | null
    locale: string | null
    title: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTypeTranslationMaxAggregateOutputType = {
    id: string | null
    pageTypeId: string | null
    locale: string | null
    title: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTypeTranslationCountAggregateOutputType = {
    id: number
    pageTypeId: number
    locale: number
    title: number
    description: number
    metaTitle: number
    metaDescription: number
    keywords: number
    pageInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageTypeTranslationMinAggregateInputType = {
    id?: true
    pageTypeId?: true
    locale?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTypeTranslationMaxAggregateInputType = {
    id?: true
    pageTypeId?: true
    locale?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTypeTranslationCountAggregateInputType = {
    id?: true
    pageTypeId?: true
    locale?: true
    title?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    pageInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageTypeTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTypeTranslation to aggregate.
     */
    where?: PageTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypeTranslations to fetch.
     */
    orderBy?: PageTypeTranslationOrderByWithRelationInput | PageTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageTypeTranslations
    **/
    _count?: true | PageTypeTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageTypeTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageTypeTranslationMaxAggregateInputType
  }

  export type GetPageTypeTranslationAggregateType<T extends PageTypeTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregatePageTypeTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageTypeTranslation[P]>
      : GetScalarType<T[P], AggregatePageTypeTranslation[P]>
  }




  export type PageTypeTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTypeTranslationWhereInput
    orderBy?: PageTypeTranslationOrderByWithAggregationInput | PageTypeTranslationOrderByWithAggregationInput[]
    by: PageTypeTranslationScalarFieldEnum[] | PageTypeTranslationScalarFieldEnum
    having?: PageTypeTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageTypeTranslationCountAggregateInputType | true
    _min?: PageTypeTranslationMinAggregateInputType
    _max?: PageTypeTranslationMaxAggregateInputType
  }

  export type PageTypeTranslationGroupByOutputType = {
    id: string
    pageTypeId: string
    locale: string
    title: string
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    keywords: string | null
    pageInfo: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PageTypeTranslationCountAggregateOutputType | null
    _min: PageTypeTranslationMinAggregateOutputType | null
    _max: PageTypeTranslationMaxAggregateOutputType | null
  }

  type GetPageTypeTranslationGroupByPayload<T extends PageTypeTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageTypeTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageTypeTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageTypeTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PageTypeTranslationGroupByOutputType[P]>
        }
      >
    >


  export type PageTypeTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageTypeId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageTypeTranslation"]>

  export type PageTypeTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageTypeId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageTypeTranslation"]>

  export type PageTypeTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageTypeId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageTypeTranslation"]>

  export type PageTypeTranslationSelectScalar = {
    id?: boolean
    pageTypeId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    pageInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageTypeTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageTypeId" | "locale" | "title" | "description" | "metaTitle" | "metaDescription" | "keywords" | "pageInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["pageTypeTranslation"]>
  export type PageTypeTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }
  export type PageTypeTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }
  export type PageTypeTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageType?: boolean | PageTypeDefaultArgs<ExtArgs>
  }

  export type $PageTypeTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageTypeTranslation"
    objects: {
      pageType: Prisma.$PageTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageTypeId: string
      locale: string
      title: string
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      keywords: string | null
      pageInfo: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pageTypeTranslation"]>
    composites: {}
  }

  type PageTypeTranslationGetPayload<S extends boolean | null | undefined | PageTypeTranslationDefaultArgs> = $Result.GetResult<Prisma.$PageTypeTranslationPayload, S>

  type PageTypeTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageTypeTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageTypeTranslationCountAggregateInputType | true
    }

  export interface PageTypeTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageTypeTranslation'], meta: { name: 'PageTypeTranslation' } }
    /**
     * Find zero or one PageTypeTranslation that matches the filter.
     * @param {PageTypeTranslationFindUniqueArgs} args - Arguments to find a PageTypeTranslation
     * @example
     * // Get one PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageTypeTranslationFindUniqueArgs>(args: SelectSubset<T, PageTypeTranslationFindUniqueArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageTypeTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageTypeTranslationFindUniqueOrThrowArgs} args - Arguments to find a PageTypeTranslation
     * @example
     * // Get one PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageTypeTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, PageTypeTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageTypeTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationFindFirstArgs} args - Arguments to find a PageTypeTranslation
     * @example
     * // Get one PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageTypeTranslationFindFirstArgs>(args?: SelectSubset<T, PageTypeTranslationFindFirstArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageTypeTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationFindFirstOrThrowArgs} args - Arguments to find a PageTypeTranslation
     * @example
     * // Get one PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageTypeTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, PageTypeTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageTypeTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageTypeTranslations
     * const pageTypeTranslations = await prisma.pageTypeTranslation.findMany()
     * 
     * // Get first 10 PageTypeTranslations
     * const pageTypeTranslations = await prisma.pageTypeTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageTypeTranslationWithIdOnly = await prisma.pageTypeTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageTypeTranslationFindManyArgs>(args?: SelectSubset<T, PageTypeTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageTypeTranslation.
     * @param {PageTypeTranslationCreateArgs} args - Arguments to create a PageTypeTranslation.
     * @example
     * // Create one PageTypeTranslation
     * const PageTypeTranslation = await prisma.pageTypeTranslation.create({
     *   data: {
     *     // ... data to create a PageTypeTranslation
     *   }
     * })
     * 
     */
    create<T extends PageTypeTranslationCreateArgs>(args: SelectSubset<T, PageTypeTranslationCreateArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageTypeTranslations.
     * @param {PageTypeTranslationCreateManyArgs} args - Arguments to create many PageTypeTranslations.
     * @example
     * // Create many PageTypeTranslations
     * const pageTypeTranslation = await prisma.pageTypeTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageTypeTranslationCreateManyArgs>(args?: SelectSubset<T, PageTypeTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageTypeTranslations and returns the data saved in the database.
     * @param {PageTypeTranslationCreateManyAndReturnArgs} args - Arguments to create many PageTypeTranslations.
     * @example
     * // Create many PageTypeTranslations
     * const pageTypeTranslation = await prisma.pageTypeTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageTypeTranslations and only return the `id`
     * const pageTypeTranslationWithIdOnly = await prisma.pageTypeTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageTypeTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, PageTypeTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageTypeTranslation.
     * @param {PageTypeTranslationDeleteArgs} args - Arguments to delete one PageTypeTranslation.
     * @example
     * // Delete one PageTypeTranslation
     * const PageTypeTranslation = await prisma.pageTypeTranslation.delete({
     *   where: {
     *     // ... filter to delete one PageTypeTranslation
     *   }
     * })
     * 
     */
    delete<T extends PageTypeTranslationDeleteArgs>(args: SelectSubset<T, PageTypeTranslationDeleteArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageTypeTranslation.
     * @param {PageTypeTranslationUpdateArgs} args - Arguments to update one PageTypeTranslation.
     * @example
     * // Update one PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageTypeTranslationUpdateArgs>(args: SelectSubset<T, PageTypeTranslationUpdateArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageTypeTranslations.
     * @param {PageTypeTranslationDeleteManyArgs} args - Arguments to filter PageTypeTranslations to delete.
     * @example
     * // Delete a few PageTypeTranslations
     * const { count } = await prisma.pageTypeTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageTypeTranslationDeleteManyArgs>(args?: SelectSubset<T, PageTypeTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTypeTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageTypeTranslations
     * const pageTypeTranslation = await prisma.pageTypeTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageTypeTranslationUpdateManyArgs>(args: SelectSubset<T, PageTypeTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTypeTranslations and returns the data updated in the database.
     * @param {PageTypeTranslationUpdateManyAndReturnArgs} args - Arguments to update many PageTypeTranslations.
     * @example
     * // Update many PageTypeTranslations
     * const pageTypeTranslation = await prisma.pageTypeTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageTypeTranslations and only return the `id`
     * const pageTypeTranslationWithIdOnly = await prisma.pageTypeTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageTypeTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, PageTypeTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageTypeTranslation.
     * @param {PageTypeTranslationUpsertArgs} args - Arguments to update or create a PageTypeTranslation.
     * @example
     * // Update or create a PageTypeTranslation
     * const pageTypeTranslation = await prisma.pageTypeTranslation.upsert({
     *   create: {
     *     // ... data to create a PageTypeTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageTypeTranslation we want to update
     *   }
     * })
     */
    upsert<T extends PageTypeTranslationUpsertArgs>(args: SelectSubset<T, PageTypeTranslationUpsertArgs<ExtArgs>>): Prisma__PageTypeTranslationClient<$Result.GetResult<Prisma.$PageTypeTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageTypeTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationCountArgs} args - Arguments to filter PageTypeTranslations to count.
     * @example
     * // Count the number of PageTypeTranslations
     * const count = await prisma.pageTypeTranslation.count({
     *   where: {
     *     // ... the filter for the PageTypeTranslations we want to count
     *   }
     * })
    **/
    count<T extends PageTypeTranslationCountArgs>(
      args?: Subset<T, PageTypeTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageTypeTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageTypeTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageTypeTranslationAggregateArgs>(args: Subset<T, PageTypeTranslationAggregateArgs>): Prisma.PrismaPromise<GetPageTypeTranslationAggregateType<T>>

    /**
     * Group by PageTypeTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTypeTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageTypeTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageTypeTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PageTypeTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageTypeTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageTypeTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageTypeTranslation model
   */
  readonly fields: PageTypeTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageTypeTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageTypeTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pageType<T extends PageTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PageTypeDefaultArgs<ExtArgs>>): Prisma__PageTypeClient<$Result.GetResult<Prisma.$PageTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageTypeTranslation model
   */
  interface PageTypeTranslationFieldRefs {
    readonly id: FieldRef<"PageTypeTranslation", 'String'>
    readonly pageTypeId: FieldRef<"PageTypeTranslation", 'String'>
    readonly locale: FieldRef<"PageTypeTranslation", 'String'>
    readonly title: FieldRef<"PageTypeTranslation", 'String'>
    readonly description: FieldRef<"PageTypeTranslation", 'String'>
    readonly metaTitle: FieldRef<"PageTypeTranslation", 'String'>
    readonly metaDescription: FieldRef<"PageTypeTranslation", 'String'>
    readonly keywords: FieldRef<"PageTypeTranslation", 'String'>
    readonly pageInfo: FieldRef<"PageTypeTranslation", 'Json'>
    readonly createdAt: FieldRef<"PageTypeTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"PageTypeTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageTypeTranslation findUnique
   */
  export type PageTypeTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTypeTranslation to fetch.
     */
    where: PageTypeTranslationWhereUniqueInput
  }

  /**
   * PageTypeTranslation findUniqueOrThrow
   */
  export type PageTypeTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTypeTranslation to fetch.
     */
    where: PageTypeTranslationWhereUniqueInput
  }

  /**
   * PageTypeTranslation findFirst
   */
  export type PageTypeTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTypeTranslation to fetch.
     */
    where?: PageTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypeTranslations to fetch.
     */
    orderBy?: PageTypeTranslationOrderByWithRelationInput | PageTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTypeTranslations.
     */
    cursor?: PageTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTypeTranslations.
     */
    distinct?: PageTypeTranslationScalarFieldEnum | PageTypeTranslationScalarFieldEnum[]
  }

  /**
   * PageTypeTranslation findFirstOrThrow
   */
  export type PageTypeTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTypeTranslation to fetch.
     */
    where?: PageTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypeTranslations to fetch.
     */
    orderBy?: PageTypeTranslationOrderByWithRelationInput | PageTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTypeTranslations.
     */
    cursor?: PageTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypeTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTypeTranslations.
     */
    distinct?: PageTypeTranslationScalarFieldEnum | PageTypeTranslationScalarFieldEnum[]
  }

  /**
   * PageTypeTranslation findMany
   */
  export type PageTypeTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PageTypeTranslations to fetch.
     */
    where?: PageTypeTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTypeTranslations to fetch.
     */
    orderBy?: PageTypeTranslationOrderByWithRelationInput | PageTypeTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageTypeTranslations.
     */
    cursor?: PageTypeTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTypeTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTypeTranslations.
     */
    skip?: number
    distinct?: PageTypeTranslationScalarFieldEnum | PageTypeTranslationScalarFieldEnum[]
  }

  /**
   * PageTypeTranslation create
   */
  export type PageTypeTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a PageTypeTranslation.
     */
    data: XOR<PageTypeTranslationCreateInput, PageTypeTranslationUncheckedCreateInput>
  }

  /**
   * PageTypeTranslation createMany
   */
  export type PageTypeTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageTypeTranslations.
     */
    data: PageTypeTranslationCreateManyInput | PageTypeTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageTypeTranslation createManyAndReturn
   */
  export type PageTypeTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many PageTypeTranslations.
     */
    data: PageTypeTranslationCreateManyInput | PageTypeTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageTypeTranslation update
   */
  export type PageTypeTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a PageTypeTranslation.
     */
    data: XOR<PageTypeTranslationUpdateInput, PageTypeTranslationUncheckedUpdateInput>
    /**
     * Choose, which PageTypeTranslation to update.
     */
    where: PageTypeTranslationWhereUniqueInput
  }

  /**
   * PageTypeTranslation updateMany
   */
  export type PageTypeTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageTypeTranslations.
     */
    data: XOR<PageTypeTranslationUpdateManyMutationInput, PageTypeTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PageTypeTranslations to update
     */
    where?: PageTypeTranslationWhereInput
    /**
     * Limit how many PageTypeTranslations to update.
     */
    limit?: number
  }

  /**
   * PageTypeTranslation updateManyAndReturn
   */
  export type PageTypeTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * The data used to update PageTypeTranslations.
     */
    data: XOR<PageTypeTranslationUpdateManyMutationInput, PageTypeTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PageTypeTranslations to update
     */
    where?: PageTypeTranslationWhereInput
    /**
     * Limit how many PageTypeTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageTypeTranslation upsert
   */
  export type PageTypeTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the PageTypeTranslation to update in case it exists.
     */
    where: PageTypeTranslationWhereUniqueInput
    /**
     * In case the PageTypeTranslation found by the `where` argument doesn't exist, create a new PageTypeTranslation with this data.
     */
    create: XOR<PageTypeTranslationCreateInput, PageTypeTranslationUncheckedCreateInput>
    /**
     * In case the PageTypeTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageTypeTranslationUpdateInput, PageTypeTranslationUncheckedUpdateInput>
  }

  /**
   * PageTypeTranslation delete
   */
  export type PageTypeTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
    /**
     * Filter which PageTypeTranslation to delete.
     */
    where: PageTypeTranslationWhereUniqueInput
  }

  /**
   * PageTypeTranslation deleteMany
   */
  export type PageTypeTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTypeTranslations to delete
     */
    where?: PageTypeTranslationWhereInput
    /**
     * Limit how many PageTypeTranslations to delete.
     */
    limit?: number
  }

  /**
   * PageTypeTranslation without action
   */
  export type PageTypeTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageTypeTranslation
     */
    select?: PageTypeTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageTypeTranslation
     */
    omit?: PageTypeTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTypeTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type LanguageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    flag: string | null
    localeCode: string | null
    direction: $Enums.TextDirection | null
    isDefault: boolean | null
    isEnabled: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    flag: string | null
    localeCode: string | null
    direction: $Enums.TextDirection | null
    isDefault: boolean | null
    isEnabled: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nativeName: number
    flag: number
    localeCode: number
    direction: number
    isDefault: number
    isEnabled: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type LanguageSumAggregateInputType = {
    sortOrder?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    flag?: true
    localeCode?: true
    direction?: true
    isDefault?: true
    isEnabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    flag?: true
    localeCode?: true
    direction?: true
    isDefault?: true
    isEnabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    flag?: true
    localeCode?: true
    direction?: true
    isDefault?: true
    isEnabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    code: string
    name: string
    nativeName: string
    flag: string | null
    localeCode: string
    direction: $Enums.TextDirection
    isDefault: boolean
    isEnabled: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    flag?: boolean
    localeCode?: boolean
    direction?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    flag?: boolean
    localeCode?: boolean
    direction?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    flag?: boolean
    localeCode?: boolean
    direction?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    flag?: boolean
    localeCode?: boolean
    direction?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "nativeName" | "flag" | "localeCode" | "direction" | "isDefault" | "isEnabled" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      translations: Prisma.$LanguageTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      nativeName: string
      flag: string | null
      localeCode: string
      direction: $Enums.TextDirection
      isDefault: boolean
      isEnabled: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends Language$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Language$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly nativeName: FieldRef<"Language", 'String'>
    readonly flag: FieldRef<"Language", 'String'>
    readonly localeCode: FieldRef<"Language", 'String'>
    readonly direction: FieldRef<"Language", 'TextDirection'>
    readonly isDefault: FieldRef<"Language", 'Boolean'>
    readonly isEnabled: FieldRef<"Language", 'Boolean'>
    readonly sortOrder: FieldRef<"Language", 'Int'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.translations
   */
  export type Language$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    where?: LanguageTranslationWhereInput
    orderBy?: LanguageTranslationOrderByWithRelationInput | LanguageTranslationOrderByWithRelationInput[]
    cursor?: LanguageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageTranslationScalarFieldEnum | LanguageTranslationScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model LanguageTranslation
   */

  export type AggregateLanguageTranslation = {
    _count: LanguageTranslationCountAggregateOutputType | null
    _min: LanguageTranslationMinAggregateOutputType | null
    _max: LanguageTranslationMaxAggregateOutputType | null
  }

  export type LanguageTranslationMinAggregateOutputType = {
    id: string | null
    languageId: string | null
    locale: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageTranslationMaxAggregateOutputType = {
    id: string | null
    languageId: string | null
    locale: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageTranslationCountAggregateOutputType = {
    id: number
    languageId: number
    locale: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageTranslationMinAggregateInputType = {
    id?: true
    languageId?: true
    locale?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageTranslationMaxAggregateInputType = {
    id?: true
    languageId?: true
    locale?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageTranslationCountAggregateInputType = {
    id?: true
    languageId?: true
    locale?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageTranslation to aggregate.
     */
    where?: LanguageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageTranslations to fetch.
     */
    orderBy?: LanguageTranslationOrderByWithRelationInput | LanguageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LanguageTranslations
    **/
    _count?: true | LanguageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageTranslationMaxAggregateInputType
  }

  export type GetLanguageTranslationAggregateType<T extends LanguageTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageTranslation[P]>
      : GetScalarType<T[P], AggregateLanguageTranslation[P]>
  }




  export type LanguageTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageTranslationWhereInput
    orderBy?: LanguageTranslationOrderByWithAggregationInput | LanguageTranslationOrderByWithAggregationInput[]
    by: LanguageTranslationScalarFieldEnum[] | LanguageTranslationScalarFieldEnum
    having?: LanguageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageTranslationCountAggregateInputType | true
    _min?: LanguageTranslationMinAggregateInputType
    _max?: LanguageTranslationMaxAggregateInputType
  }

  export type LanguageTranslationGroupByOutputType = {
    id: string
    languageId: string
    locale: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: LanguageTranslationCountAggregateOutputType | null
    _min: LanguageTranslationMinAggregateOutputType | null
    _max: LanguageTranslationMaxAggregateOutputType | null
  }

  type GetLanguageTranslationGroupByPayload<T extends LanguageTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageTranslationGroupByOutputType[P]>
        }
      >
    >


  export type LanguageTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    languageId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageTranslation"]>

  export type LanguageTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    languageId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageTranslation"]>

  export type LanguageTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    languageId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageTranslation"]>

  export type LanguageTranslationSelectScalar = {
    id?: boolean
    languageId?: boolean
    locale?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "languageId" | "locale" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["languageTranslation"]>
  export type LanguageTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type LanguageTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type LanguageTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $LanguageTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LanguageTranslation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      languageId: string
      locale: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["languageTranslation"]>
    composites: {}
  }

  type LanguageTranslationGetPayload<S extends boolean | null | undefined | LanguageTranslationDefaultArgs> = $Result.GetResult<Prisma.$LanguageTranslationPayload, S>

  type LanguageTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageTranslationCountAggregateInputType | true
    }

  export interface LanguageTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LanguageTranslation'], meta: { name: 'LanguageTranslation' } }
    /**
     * Find zero or one LanguageTranslation that matches the filter.
     * @param {LanguageTranslationFindUniqueArgs} args - Arguments to find a LanguageTranslation
     * @example
     * // Get one LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageTranslationFindUniqueArgs>(args: SelectSubset<T, LanguageTranslationFindUniqueArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LanguageTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageTranslationFindUniqueOrThrowArgs} args - Arguments to find a LanguageTranslation
     * @example
     * // Get one LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationFindFirstArgs} args - Arguments to find a LanguageTranslation
     * @example
     * // Get one LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageTranslationFindFirstArgs>(args?: SelectSubset<T, LanguageTranslationFindFirstArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationFindFirstOrThrowArgs} args - Arguments to find a LanguageTranslation
     * @example
     * // Get one LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LanguageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LanguageTranslations
     * const languageTranslations = await prisma.languageTranslation.findMany()
     * 
     * // Get first 10 LanguageTranslations
     * const languageTranslations = await prisma.languageTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageTranslationWithIdOnly = await prisma.languageTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageTranslationFindManyArgs>(args?: SelectSubset<T, LanguageTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LanguageTranslation.
     * @param {LanguageTranslationCreateArgs} args - Arguments to create a LanguageTranslation.
     * @example
     * // Create one LanguageTranslation
     * const LanguageTranslation = await prisma.languageTranslation.create({
     *   data: {
     *     // ... data to create a LanguageTranslation
     *   }
     * })
     * 
     */
    create<T extends LanguageTranslationCreateArgs>(args: SelectSubset<T, LanguageTranslationCreateArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LanguageTranslations.
     * @param {LanguageTranslationCreateManyArgs} args - Arguments to create many LanguageTranslations.
     * @example
     * // Create many LanguageTranslations
     * const languageTranslation = await prisma.languageTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageTranslationCreateManyArgs>(args?: SelectSubset<T, LanguageTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LanguageTranslations and returns the data saved in the database.
     * @param {LanguageTranslationCreateManyAndReturnArgs} args - Arguments to create many LanguageTranslations.
     * @example
     * // Create many LanguageTranslations
     * const languageTranslation = await prisma.languageTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LanguageTranslations and only return the `id`
     * const languageTranslationWithIdOnly = await prisma.languageTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LanguageTranslation.
     * @param {LanguageTranslationDeleteArgs} args - Arguments to delete one LanguageTranslation.
     * @example
     * // Delete one LanguageTranslation
     * const LanguageTranslation = await prisma.languageTranslation.delete({
     *   where: {
     *     // ... filter to delete one LanguageTranslation
     *   }
     * })
     * 
     */
    delete<T extends LanguageTranslationDeleteArgs>(args: SelectSubset<T, LanguageTranslationDeleteArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LanguageTranslation.
     * @param {LanguageTranslationUpdateArgs} args - Arguments to update one LanguageTranslation.
     * @example
     * // Update one LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageTranslationUpdateArgs>(args: SelectSubset<T, LanguageTranslationUpdateArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LanguageTranslations.
     * @param {LanguageTranslationDeleteManyArgs} args - Arguments to filter LanguageTranslations to delete.
     * @example
     * // Delete a few LanguageTranslations
     * const { count } = await prisma.languageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageTranslationDeleteManyArgs>(args?: SelectSubset<T, LanguageTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LanguageTranslations
     * const languageTranslation = await prisma.languageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageTranslationUpdateManyArgs>(args: SelectSubset<T, LanguageTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageTranslations and returns the data updated in the database.
     * @param {LanguageTranslationUpdateManyAndReturnArgs} args - Arguments to update many LanguageTranslations.
     * @example
     * // Update many LanguageTranslations
     * const languageTranslation = await prisma.languageTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LanguageTranslations and only return the `id`
     * const languageTranslationWithIdOnly = await prisma.languageTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LanguageTranslation.
     * @param {LanguageTranslationUpsertArgs} args - Arguments to update or create a LanguageTranslation.
     * @example
     * // Update or create a LanguageTranslation
     * const languageTranslation = await prisma.languageTranslation.upsert({
     *   create: {
     *     // ... data to create a LanguageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LanguageTranslation we want to update
     *   }
     * })
     */
    upsert<T extends LanguageTranslationUpsertArgs>(args: SelectSubset<T, LanguageTranslationUpsertArgs<ExtArgs>>): Prisma__LanguageTranslationClient<$Result.GetResult<Prisma.$LanguageTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LanguageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationCountArgs} args - Arguments to filter LanguageTranslations to count.
     * @example
     * // Count the number of LanguageTranslations
     * const count = await prisma.languageTranslation.count({
     *   where: {
     *     // ... the filter for the LanguageTranslations we want to count
     *   }
     * })
    **/
    count<T extends LanguageTranslationCountArgs>(
      args?: Subset<T, LanguageTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LanguageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageTranslationAggregateArgs>(args: Subset<T, LanguageTranslationAggregateArgs>): Prisma.PrismaPromise<GetLanguageTranslationAggregateType<T>>

    /**
     * Group by LanguageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: LanguageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LanguageTranslation model
   */
  readonly fields: LanguageTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LanguageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LanguageTranslation model
   */
  interface LanguageTranslationFieldRefs {
    readonly id: FieldRef<"LanguageTranslation", 'String'>
    readonly languageId: FieldRef<"LanguageTranslation", 'String'>
    readonly locale: FieldRef<"LanguageTranslation", 'String'>
    readonly name: FieldRef<"LanguageTranslation", 'String'>
    readonly description: FieldRef<"LanguageTranslation", 'String'>
    readonly createdAt: FieldRef<"LanguageTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"LanguageTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LanguageTranslation findUnique
   */
  export type LanguageTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which LanguageTranslation to fetch.
     */
    where: LanguageTranslationWhereUniqueInput
  }

  /**
   * LanguageTranslation findUniqueOrThrow
   */
  export type LanguageTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which LanguageTranslation to fetch.
     */
    where: LanguageTranslationWhereUniqueInput
  }

  /**
   * LanguageTranslation findFirst
   */
  export type LanguageTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which LanguageTranslation to fetch.
     */
    where?: LanguageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageTranslations to fetch.
     */
    orderBy?: LanguageTranslationOrderByWithRelationInput | LanguageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageTranslations.
     */
    cursor?: LanguageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageTranslations.
     */
    distinct?: LanguageTranslationScalarFieldEnum | LanguageTranslationScalarFieldEnum[]
  }

  /**
   * LanguageTranslation findFirstOrThrow
   */
  export type LanguageTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which LanguageTranslation to fetch.
     */
    where?: LanguageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageTranslations to fetch.
     */
    orderBy?: LanguageTranslationOrderByWithRelationInput | LanguageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageTranslations.
     */
    cursor?: LanguageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageTranslations.
     */
    distinct?: LanguageTranslationScalarFieldEnum | LanguageTranslationScalarFieldEnum[]
  }

  /**
   * LanguageTranslation findMany
   */
  export type LanguageTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which LanguageTranslations to fetch.
     */
    where?: LanguageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageTranslations to fetch.
     */
    orderBy?: LanguageTranslationOrderByWithRelationInput | LanguageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LanguageTranslations.
     */
    cursor?: LanguageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageTranslations.
     */
    skip?: number
    distinct?: LanguageTranslationScalarFieldEnum | LanguageTranslationScalarFieldEnum[]
  }

  /**
   * LanguageTranslation create
   */
  export type LanguageTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a LanguageTranslation.
     */
    data: XOR<LanguageTranslationCreateInput, LanguageTranslationUncheckedCreateInput>
  }

  /**
   * LanguageTranslation createMany
   */
  export type LanguageTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LanguageTranslations.
     */
    data: LanguageTranslationCreateManyInput | LanguageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LanguageTranslation createManyAndReturn
   */
  export type LanguageTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many LanguageTranslations.
     */
    data: LanguageTranslationCreateManyInput | LanguageTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LanguageTranslation update
   */
  export type LanguageTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a LanguageTranslation.
     */
    data: XOR<LanguageTranslationUpdateInput, LanguageTranslationUncheckedUpdateInput>
    /**
     * Choose, which LanguageTranslation to update.
     */
    where: LanguageTranslationWhereUniqueInput
  }

  /**
   * LanguageTranslation updateMany
   */
  export type LanguageTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LanguageTranslations.
     */
    data: XOR<LanguageTranslationUpdateManyMutationInput, LanguageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which LanguageTranslations to update
     */
    where?: LanguageTranslationWhereInput
    /**
     * Limit how many LanguageTranslations to update.
     */
    limit?: number
  }

  /**
   * LanguageTranslation updateManyAndReturn
   */
  export type LanguageTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * The data used to update LanguageTranslations.
     */
    data: XOR<LanguageTranslationUpdateManyMutationInput, LanguageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which LanguageTranslations to update
     */
    where?: LanguageTranslationWhereInput
    /**
     * Limit how many LanguageTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LanguageTranslation upsert
   */
  export type LanguageTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the LanguageTranslation to update in case it exists.
     */
    where: LanguageTranslationWhereUniqueInput
    /**
     * In case the LanguageTranslation found by the `where` argument doesn't exist, create a new LanguageTranslation with this data.
     */
    create: XOR<LanguageTranslationCreateInput, LanguageTranslationUncheckedCreateInput>
    /**
     * In case the LanguageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageTranslationUpdateInput, LanguageTranslationUncheckedUpdateInput>
  }

  /**
   * LanguageTranslation delete
   */
  export type LanguageTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
    /**
     * Filter which LanguageTranslation to delete.
     */
    where: LanguageTranslationWhereUniqueInput
  }

  /**
   * LanguageTranslation deleteMany
   */
  export type LanguageTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageTranslations to delete
     */
    where?: LanguageTranslationWhereInput
    /**
     * Limit how many LanguageTranslations to delete.
     */
    limit?: number
  }

  /**
   * LanguageTranslation without action
   */
  export type LanguageTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageTranslation
     */
    select?: LanguageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageTranslation
     */
    omit?: LanguageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageTranslationInclude<ExtArgs> | null
  }


  /**
   * Model SiteConfig
   */

  export type AggregateSiteConfig = {
    _count: SiteConfigCountAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  export type SiteConfigMinAggregateOutputType = {
    id: string | null
    siteName: string | null
    siteDescription: string | null
    siteUrl: string | null
    logoUrl: string | null
    faviconUrl: string | null
    ogImageUrl: string | null
    contactEmail: string | null
    supportEmail: string | null
    twitterHandle: string | null
    googleAnalyticsId: string | null
    googleAdsenseId: string | null
    maintenanceMode: boolean | null
    enableComments: boolean | null
    enableRatings: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigMaxAggregateOutputType = {
    id: string | null
    siteName: string | null
    siteDescription: string | null
    siteUrl: string | null
    logoUrl: string | null
    faviconUrl: string | null
    ogImageUrl: string | null
    contactEmail: string | null
    supportEmail: string | null
    twitterHandle: string | null
    googleAnalyticsId: string | null
    googleAdsenseId: string | null
    maintenanceMode: boolean | null
    enableComments: boolean | null
    enableRatings: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigCountAggregateOutputType = {
    id: number
    siteName: number
    siteDescription: number
    siteUrl: number
    logoUrl: number
    faviconUrl: number
    ogImageUrl: number
    contactEmail: number
    supportEmail: number
    socialLinks: number
    defaultKeywords: number
    twitterHandle: number
    googleAnalyticsId: number
    googleAdsenseId: number
    customScripts: number
    maintenanceMode: number
    enableComments: number
    enableRatings: number
    extraConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteConfigMinAggregateInputType = {
    id?: true
    siteName?: true
    siteDescription?: true
    siteUrl?: true
    logoUrl?: true
    faviconUrl?: true
    ogImageUrl?: true
    contactEmail?: true
    supportEmail?: true
    twitterHandle?: true
    googleAnalyticsId?: true
    googleAdsenseId?: true
    maintenanceMode?: true
    enableComments?: true
    enableRatings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigMaxAggregateInputType = {
    id?: true
    siteName?: true
    siteDescription?: true
    siteUrl?: true
    logoUrl?: true
    faviconUrl?: true
    ogImageUrl?: true
    contactEmail?: true
    supportEmail?: true
    twitterHandle?: true
    googleAnalyticsId?: true
    googleAdsenseId?: true
    maintenanceMode?: true
    enableComments?: true
    enableRatings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigCountAggregateInputType = {
    id?: true
    siteName?: true
    siteDescription?: true
    siteUrl?: true
    logoUrl?: true
    faviconUrl?: true
    ogImageUrl?: true
    contactEmail?: true
    supportEmail?: true
    socialLinks?: true
    defaultKeywords?: true
    twitterHandle?: true
    googleAnalyticsId?: true
    googleAdsenseId?: true
    customScripts?: true
    maintenanceMode?: true
    enableComments?: true
    enableRatings?: true
    extraConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfig to aggregate.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteConfigs
    **/
    _count?: true | SiteConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteConfigMaxAggregateInputType
  }

  export type GetSiteConfigAggregateType<T extends SiteConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteConfig[P]>
      : GetScalarType<T[P], AggregateSiteConfig[P]>
  }




  export type SiteConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigWhereInput
    orderBy?: SiteConfigOrderByWithAggregationInput | SiteConfigOrderByWithAggregationInput[]
    by: SiteConfigScalarFieldEnum[] | SiteConfigScalarFieldEnum
    having?: SiteConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteConfigCountAggregateInputType | true
    _min?: SiteConfigMinAggregateInputType
    _max?: SiteConfigMaxAggregateInputType
  }

  export type SiteConfigGroupByOutputType = {
    id: string
    siteName: string
    siteDescription: string | null
    siteUrl: string
    logoUrl: string | null
    faviconUrl: string | null
    ogImageUrl: string | null
    contactEmail: string | null
    supportEmail: string | null
    socialLinks: JsonValue | null
    defaultKeywords: string[]
    twitterHandle: string | null
    googleAnalyticsId: string | null
    googleAdsenseId: string | null
    customScripts: JsonValue | null
    maintenanceMode: boolean
    enableComments: boolean
    enableRatings: boolean
    extraConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SiteConfigCountAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  type GetSiteConfigGroupByPayload<T extends SiteConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
        }
      >
    >


  export type SiteConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteDescription?: boolean
    siteUrl?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    ogImageUrl?: boolean
    contactEmail?: boolean
    supportEmail?: boolean
    socialLinks?: boolean
    defaultKeywords?: boolean
    twitterHandle?: boolean
    googleAnalyticsId?: boolean
    googleAdsenseId?: boolean
    customScripts?: boolean
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | SiteConfig$translationsArgs<ExtArgs>
    _count?: boolean | SiteConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteDescription?: boolean
    siteUrl?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    ogImageUrl?: boolean
    contactEmail?: boolean
    supportEmail?: boolean
    socialLinks?: boolean
    defaultKeywords?: boolean
    twitterHandle?: boolean
    googleAnalyticsId?: boolean
    googleAdsenseId?: boolean
    customScripts?: boolean
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteDescription?: boolean
    siteUrl?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    ogImageUrl?: boolean
    contactEmail?: boolean
    supportEmail?: boolean
    socialLinks?: boolean
    defaultKeywords?: boolean
    twitterHandle?: boolean
    googleAnalyticsId?: boolean
    googleAdsenseId?: boolean
    customScripts?: boolean
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectScalar = {
    id?: boolean
    siteName?: boolean
    siteDescription?: boolean
    siteUrl?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    ogImageUrl?: boolean
    contactEmail?: boolean
    supportEmail?: boolean
    socialLinks?: boolean
    defaultKeywords?: boolean
    twitterHandle?: boolean
    googleAnalyticsId?: boolean
    googleAdsenseId?: boolean
    customScripts?: boolean
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteName" | "siteDescription" | "siteUrl" | "logoUrl" | "faviconUrl" | "ogImageUrl" | "contactEmail" | "supportEmail" | "socialLinks" | "defaultKeywords" | "twitterHandle" | "googleAnalyticsId" | "googleAdsenseId" | "customScripts" | "maintenanceMode" | "enableComments" | "enableRatings" | "extraConfig" | "createdAt" | "updatedAt", ExtArgs["result"]["siteConfig"]>
  export type SiteConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | SiteConfig$translationsArgs<ExtArgs>
    _count?: boolean | SiteConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SiteConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SiteConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteConfig"
    objects: {
      translations: Prisma.$SiteConfigTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteName: string
      siteDescription: string | null
      siteUrl: string
      logoUrl: string | null
      faviconUrl: string | null
      ogImageUrl: string | null
      contactEmail: string | null
      supportEmail: string | null
      socialLinks: Prisma.JsonValue | null
      defaultKeywords: string[]
      twitterHandle: string | null
      googleAnalyticsId: string | null
      googleAdsenseId: string | null
      customScripts: Prisma.JsonValue | null
      maintenanceMode: boolean
      enableComments: boolean
      enableRatings: boolean
      extraConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteConfig"]>
    composites: {}
  }

  type SiteConfigGetPayload<S extends boolean | null | undefined | SiteConfigDefaultArgs> = $Result.GetResult<Prisma.$SiteConfigPayload, S>

  type SiteConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteConfigCountAggregateInputType | true
    }

  export interface SiteConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteConfig'], meta: { name: 'SiteConfig' } }
    /**
     * Find zero or one SiteConfig that matches the filter.
     * @param {SiteConfigFindUniqueArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteConfigFindUniqueArgs>(args: SelectSubset<T, SiteConfigFindUniqueArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteConfigFindUniqueOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteConfigFindFirstArgs>(args?: SelectSubset<T, SiteConfigFindFirstArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany()
     * 
     * // Get first 10 SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteConfigWithIdOnly = await prisma.siteConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteConfigFindManyArgs>(args?: SelectSubset<T, SiteConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteConfig.
     * @param {SiteConfigCreateArgs} args - Arguments to create a SiteConfig.
     * @example
     * // Create one SiteConfig
     * const SiteConfig = await prisma.siteConfig.create({
     *   data: {
     *     // ... data to create a SiteConfig
     *   }
     * })
     * 
     */
    create<T extends SiteConfigCreateArgs>(args: SelectSubset<T, SiteConfigCreateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteConfigs.
     * @param {SiteConfigCreateManyArgs} args - Arguments to create many SiteConfigs.
     * @example
     * // Create many SiteConfigs
     * const siteConfig = await prisma.siteConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteConfigCreateManyArgs>(args?: SelectSubset<T, SiteConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteConfigs and returns the data saved in the database.
     * @param {SiteConfigCreateManyAndReturnArgs} args - Arguments to create many SiteConfigs.
     * @example
     * // Create many SiteConfigs
     * const siteConfig = await prisma.siteConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteConfigs and only return the `id`
     * const siteConfigWithIdOnly = await prisma.siteConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteConfig.
     * @param {SiteConfigDeleteArgs} args - Arguments to delete one SiteConfig.
     * @example
     * // Delete one SiteConfig
     * const SiteConfig = await prisma.siteConfig.delete({
     *   where: {
     *     // ... filter to delete one SiteConfig
     *   }
     * })
     * 
     */
    delete<T extends SiteConfigDeleteArgs>(args: SelectSubset<T, SiteConfigDeleteArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteConfig.
     * @param {SiteConfigUpdateArgs} args - Arguments to update one SiteConfig.
     * @example
     * // Update one SiteConfig
     * const siteConfig = await prisma.siteConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteConfigUpdateArgs>(args: SelectSubset<T, SiteConfigUpdateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteConfigs.
     * @param {SiteConfigDeleteManyArgs} args - Arguments to filter SiteConfigs to delete.
     * @example
     * // Delete a few SiteConfigs
     * const { count } = await prisma.siteConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteConfigDeleteManyArgs>(args?: SelectSubset<T, SiteConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteConfigs
     * const siteConfig = await prisma.siteConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteConfigUpdateManyArgs>(args: SelectSubset<T, SiteConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigs and returns the data updated in the database.
     * @param {SiteConfigUpdateManyAndReturnArgs} args - Arguments to update many SiteConfigs.
     * @example
     * // Update many SiteConfigs
     * const siteConfig = await prisma.siteConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteConfigs and only return the `id`
     * const siteConfigWithIdOnly = await prisma.siteConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteConfig.
     * @param {SiteConfigUpsertArgs} args - Arguments to update or create a SiteConfig.
     * @example
     * // Update or create a SiteConfig
     * const siteConfig = await prisma.siteConfig.upsert({
     *   create: {
     *     // ... data to create a SiteConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteConfig we want to update
     *   }
     * })
     */
    upsert<T extends SiteConfigUpsertArgs>(args: SelectSubset<T, SiteConfigUpsertArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigCountArgs} args - Arguments to filter SiteConfigs to count.
     * @example
     * // Count the number of SiteConfigs
     * const count = await prisma.siteConfig.count({
     *   where: {
     *     // ... the filter for the SiteConfigs we want to count
     *   }
     * })
    **/
    count<T extends SiteConfigCountArgs>(
      args?: Subset<T, SiteConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteConfigAggregateArgs>(args: Subset<T, SiteConfigAggregateArgs>): Prisma.PrismaPromise<GetSiteConfigAggregateType<T>>

    /**
     * Group by SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteConfigGroupByArgs['orderBy'] }
        : { orderBy?: SiteConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteConfig model
   */
  readonly fields: SiteConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends SiteConfig$translationsArgs<ExtArgs> = {}>(args?: Subset<T, SiteConfig$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteConfig model
   */
  interface SiteConfigFieldRefs {
    readonly id: FieldRef<"SiteConfig", 'String'>
    readonly siteName: FieldRef<"SiteConfig", 'String'>
    readonly siteDescription: FieldRef<"SiteConfig", 'String'>
    readonly siteUrl: FieldRef<"SiteConfig", 'String'>
    readonly logoUrl: FieldRef<"SiteConfig", 'String'>
    readonly faviconUrl: FieldRef<"SiteConfig", 'String'>
    readonly ogImageUrl: FieldRef<"SiteConfig", 'String'>
    readonly contactEmail: FieldRef<"SiteConfig", 'String'>
    readonly supportEmail: FieldRef<"SiteConfig", 'String'>
    readonly socialLinks: FieldRef<"SiteConfig", 'Json'>
    readonly defaultKeywords: FieldRef<"SiteConfig", 'String[]'>
    readonly twitterHandle: FieldRef<"SiteConfig", 'String'>
    readonly googleAnalyticsId: FieldRef<"SiteConfig", 'String'>
    readonly googleAdsenseId: FieldRef<"SiteConfig", 'String'>
    readonly customScripts: FieldRef<"SiteConfig", 'Json'>
    readonly maintenanceMode: FieldRef<"SiteConfig", 'Boolean'>
    readonly enableComments: FieldRef<"SiteConfig", 'Boolean'>
    readonly enableRatings: FieldRef<"SiteConfig", 'Boolean'>
    readonly extraConfig: FieldRef<"SiteConfig", 'Json'>
    readonly createdAt: FieldRef<"SiteConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteConfig findUnique
   */
  export type SiteConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findUniqueOrThrow
   */
  export type SiteConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findFirst
   */
  export type SiteConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findFirstOrThrow
   */
  export type SiteConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findMany
   */
  export type SiteConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigs to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig create
   */
  export type SiteConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteConfig.
     */
    data: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
  }

  /**
   * SiteConfig createMany
   */
  export type SiteConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteConfigs.
     */
    data: SiteConfigCreateManyInput | SiteConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteConfig createManyAndReturn
   */
  export type SiteConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SiteConfigs.
     */
    data: SiteConfigCreateManyInput | SiteConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteConfig update
   */
  export type SiteConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteConfig.
     */
    data: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
    /**
     * Choose, which SiteConfig to update.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig updateMany
   */
  export type SiteConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteConfigs.
     */
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigs to update
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to update.
     */
    limit?: number
  }

  /**
   * SiteConfig updateManyAndReturn
   */
  export type SiteConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * The data used to update SiteConfigs.
     */
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigs to update
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to update.
     */
    limit?: number
  }

  /**
   * SiteConfig upsert
   */
  export type SiteConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteConfig to update in case it exists.
     */
    where: SiteConfigWhereUniqueInput
    /**
     * In case the SiteConfig found by the `where` argument doesn't exist, create a new SiteConfig with this data.
     */
    create: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
    /**
     * In case the SiteConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
  }

  /**
   * SiteConfig delete
   */
  export type SiteConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter which SiteConfig to delete.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig deleteMany
   */
  export type SiteConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigs to delete
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to delete.
     */
    limit?: number
  }

  /**
   * SiteConfig.translations
   */
  export type SiteConfig$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    where?: SiteConfigTranslationWhereInput
    orderBy?: SiteConfigTranslationOrderByWithRelationInput | SiteConfigTranslationOrderByWithRelationInput[]
    cursor?: SiteConfigTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteConfigTranslationScalarFieldEnum | SiteConfigTranslationScalarFieldEnum[]
  }

  /**
   * SiteConfig without action
   */
  export type SiteConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
  }


  /**
   * Model SiteConfigTranslation
   */

  export type AggregateSiteConfigTranslation = {
    _count: SiteConfigTranslationCountAggregateOutputType | null
    _min: SiteConfigTranslationMinAggregateOutputType | null
    _max: SiteConfigTranslationMaxAggregateOutputType | null
  }

  export type SiteConfigTranslationMinAggregateOutputType = {
    id: string | null
    siteConfigId: string | null
    locale: string | null
    siteName: string | null
    siteDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigTranslationMaxAggregateOutputType = {
    id: string | null
    siteConfigId: string | null
    locale: string | null
    siteName: string | null
    siteDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigTranslationCountAggregateOutputType = {
    id: number
    siteConfigId: number
    locale: number
    siteName: number
    siteDescription: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteConfigTranslationMinAggregateInputType = {
    id?: true
    siteConfigId?: true
    locale?: true
    siteName?: true
    siteDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigTranslationMaxAggregateInputType = {
    id?: true
    siteConfigId?: true
    locale?: true
    siteName?: true
    siteDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigTranslationCountAggregateInputType = {
    id?: true
    siteConfigId?: true
    locale?: true
    siteName?: true
    siteDescription?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteConfigTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigTranslation to aggregate.
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigTranslations to fetch.
     */
    orderBy?: SiteConfigTranslationOrderByWithRelationInput | SiteConfigTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteConfigTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteConfigTranslations
    **/
    _count?: true | SiteConfigTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteConfigTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteConfigTranslationMaxAggregateInputType
  }

  export type GetSiteConfigTranslationAggregateType<T extends SiteConfigTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteConfigTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteConfigTranslation[P]>
      : GetScalarType<T[P], AggregateSiteConfigTranslation[P]>
  }




  export type SiteConfigTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigTranslationWhereInput
    orderBy?: SiteConfigTranslationOrderByWithAggregationInput | SiteConfigTranslationOrderByWithAggregationInput[]
    by: SiteConfigTranslationScalarFieldEnum[] | SiteConfigTranslationScalarFieldEnum
    having?: SiteConfigTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteConfigTranslationCountAggregateInputType | true
    _min?: SiteConfigTranslationMinAggregateInputType
    _max?: SiteConfigTranslationMaxAggregateInputType
  }

  export type SiteConfigTranslationGroupByOutputType = {
    id: string
    siteConfigId: string
    locale: string
    siteName: string
    siteDescription: string | null
    keywords: string[]
    createdAt: Date
    updatedAt: Date
    _count: SiteConfigTranslationCountAggregateOutputType | null
    _min: SiteConfigTranslationMinAggregateOutputType | null
    _max: SiteConfigTranslationMaxAggregateOutputType | null
  }

  type GetSiteConfigTranslationGroupByPayload<T extends SiteConfigTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteConfigTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteConfigTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteConfigTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], SiteConfigTranslationGroupByOutputType[P]>
        }
      >
    >


  export type SiteConfigTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteConfigId?: boolean
    locale?: boolean
    siteName?: boolean
    siteDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfigTranslation"]>

  export type SiteConfigTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteConfigId?: boolean
    locale?: boolean
    siteName?: boolean
    siteDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfigTranslation"]>

  export type SiteConfigTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteConfigId?: boolean
    locale?: boolean
    siteName?: boolean
    siteDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfigTranslation"]>

  export type SiteConfigTranslationSelectScalar = {
    id?: boolean
    siteConfigId?: boolean
    locale?: boolean
    siteName?: boolean
    siteDescription?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteConfigTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteConfigId" | "locale" | "siteName" | "siteDescription" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["siteConfigTranslation"]>
  export type SiteConfigTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }
  export type SiteConfigTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }
  export type SiteConfigTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteConfig?: boolean | SiteConfigDefaultArgs<ExtArgs>
  }

  export type $SiteConfigTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteConfigTranslation"
    objects: {
      siteConfig: Prisma.$SiteConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteConfigId: string
      locale: string
      siteName: string
      siteDescription: string | null
      keywords: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteConfigTranslation"]>
    composites: {}
  }

  type SiteConfigTranslationGetPayload<S extends boolean | null | undefined | SiteConfigTranslationDefaultArgs> = $Result.GetResult<Prisma.$SiteConfigTranslationPayload, S>

  type SiteConfigTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteConfigTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteConfigTranslationCountAggregateInputType | true
    }

  export interface SiteConfigTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteConfigTranslation'], meta: { name: 'SiteConfigTranslation' } }
    /**
     * Find zero or one SiteConfigTranslation that matches the filter.
     * @param {SiteConfigTranslationFindUniqueArgs} args - Arguments to find a SiteConfigTranslation
     * @example
     * // Get one SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteConfigTranslationFindUniqueArgs>(args: SelectSubset<T, SiteConfigTranslationFindUniqueArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteConfigTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteConfigTranslationFindUniqueOrThrowArgs} args - Arguments to find a SiteConfigTranslation
     * @example
     * // Get one SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteConfigTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteConfigTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfigTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationFindFirstArgs} args - Arguments to find a SiteConfigTranslation
     * @example
     * // Get one SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteConfigTranslationFindFirstArgs>(args?: SelectSubset<T, SiteConfigTranslationFindFirstArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfigTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationFindFirstOrThrowArgs} args - Arguments to find a SiteConfigTranslation
     * @example
     * // Get one SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteConfigTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteConfigTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteConfigTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteConfigTranslations
     * const siteConfigTranslations = await prisma.siteConfigTranslation.findMany()
     * 
     * // Get first 10 SiteConfigTranslations
     * const siteConfigTranslations = await prisma.siteConfigTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteConfigTranslationWithIdOnly = await prisma.siteConfigTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteConfigTranslationFindManyArgs>(args?: SelectSubset<T, SiteConfigTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteConfigTranslation.
     * @param {SiteConfigTranslationCreateArgs} args - Arguments to create a SiteConfigTranslation.
     * @example
     * // Create one SiteConfigTranslation
     * const SiteConfigTranslation = await prisma.siteConfigTranslation.create({
     *   data: {
     *     // ... data to create a SiteConfigTranslation
     *   }
     * })
     * 
     */
    create<T extends SiteConfigTranslationCreateArgs>(args: SelectSubset<T, SiteConfigTranslationCreateArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteConfigTranslations.
     * @param {SiteConfigTranslationCreateManyArgs} args - Arguments to create many SiteConfigTranslations.
     * @example
     * // Create many SiteConfigTranslations
     * const siteConfigTranslation = await prisma.siteConfigTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteConfigTranslationCreateManyArgs>(args?: SelectSubset<T, SiteConfigTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteConfigTranslations and returns the data saved in the database.
     * @param {SiteConfigTranslationCreateManyAndReturnArgs} args - Arguments to create many SiteConfigTranslations.
     * @example
     * // Create many SiteConfigTranslations
     * const siteConfigTranslation = await prisma.siteConfigTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteConfigTranslations and only return the `id`
     * const siteConfigTranslationWithIdOnly = await prisma.siteConfigTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteConfigTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteConfigTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteConfigTranslation.
     * @param {SiteConfigTranslationDeleteArgs} args - Arguments to delete one SiteConfigTranslation.
     * @example
     * // Delete one SiteConfigTranslation
     * const SiteConfigTranslation = await prisma.siteConfigTranslation.delete({
     *   where: {
     *     // ... filter to delete one SiteConfigTranslation
     *   }
     * })
     * 
     */
    delete<T extends SiteConfigTranslationDeleteArgs>(args: SelectSubset<T, SiteConfigTranslationDeleteArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteConfigTranslation.
     * @param {SiteConfigTranslationUpdateArgs} args - Arguments to update one SiteConfigTranslation.
     * @example
     * // Update one SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteConfigTranslationUpdateArgs>(args: SelectSubset<T, SiteConfigTranslationUpdateArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteConfigTranslations.
     * @param {SiteConfigTranslationDeleteManyArgs} args - Arguments to filter SiteConfigTranslations to delete.
     * @example
     * // Delete a few SiteConfigTranslations
     * const { count } = await prisma.siteConfigTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteConfigTranslationDeleteManyArgs>(args?: SelectSubset<T, SiteConfigTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteConfigTranslations
     * const siteConfigTranslation = await prisma.siteConfigTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteConfigTranslationUpdateManyArgs>(args: SelectSubset<T, SiteConfigTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigTranslations and returns the data updated in the database.
     * @param {SiteConfigTranslationUpdateManyAndReturnArgs} args - Arguments to update many SiteConfigTranslations.
     * @example
     * // Update many SiteConfigTranslations
     * const siteConfigTranslation = await prisma.siteConfigTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteConfigTranslations and only return the `id`
     * const siteConfigTranslationWithIdOnly = await prisma.siteConfigTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteConfigTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteConfigTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteConfigTranslation.
     * @param {SiteConfigTranslationUpsertArgs} args - Arguments to update or create a SiteConfigTranslation.
     * @example
     * // Update or create a SiteConfigTranslation
     * const siteConfigTranslation = await prisma.siteConfigTranslation.upsert({
     *   create: {
     *     // ... data to create a SiteConfigTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteConfigTranslation we want to update
     *   }
     * })
     */
    upsert<T extends SiteConfigTranslationUpsertArgs>(args: SelectSubset<T, SiteConfigTranslationUpsertArgs<ExtArgs>>): Prisma__SiteConfigTranslationClient<$Result.GetResult<Prisma.$SiteConfigTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteConfigTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationCountArgs} args - Arguments to filter SiteConfigTranslations to count.
     * @example
     * // Count the number of SiteConfigTranslations
     * const count = await prisma.siteConfigTranslation.count({
     *   where: {
     *     // ... the filter for the SiteConfigTranslations we want to count
     *   }
     * })
    **/
    count<T extends SiteConfigTranslationCountArgs>(
      args?: Subset<T, SiteConfigTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteConfigTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteConfigTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteConfigTranslationAggregateArgs>(args: Subset<T, SiteConfigTranslationAggregateArgs>): Prisma.PrismaPromise<GetSiteConfigTranslationAggregateType<T>>

    /**
     * Group by SiteConfigTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteConfigTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteConfigTranslationGroupByArgs['orderBy'] }
        : { orderBy?: SiteConfigTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteConfigTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteConfigTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteConfigTranslation model
   */
  readonly fields: SiteConfigTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteConfigTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteConfigTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    siteConfig<T extends SiteConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteConfigDefaultArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteConfigTranslation model
   */
  interface SiteConfigTranslationFieldRefs {
    readonly id: FieldRef<"SiteConfigTranslation", 'String'>
    readonly siteConfigId: FieldRef<"SiteConfigTranslation", 'String'>
    readonly locale: FieldRef<"SiteConfigTranslation", 'String'>
    readonly siteName: FieldRef<"SiteConfigTranslation", 'String'>
    readonly siteDescription: FieldRef<"SiteConfigTranslation", 'String'>
    readonly keywords: FieldRef<"SiteConfigTranslation", 'String[]'>
    readonly createdAt: FieldRef<"SiteConfigTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteConfigTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteConfigTranslation findUnique
   */
  export type SiteConfigTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigTranslation to fetch.
     */
    where: SiteConfigTranslationWhereUniqueInput
  }

  /**
   * SiteConfigTranslation findUniqueOrThrow
   */
  export type SiteConfigTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigTranslation to fetch.
     */
    where: SiteConfigTranslationWhereUniqueInput
  }

  /**
   * SiteConfigTranslation findFirst
   */
  export type SiteConfigTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigTranslation to fetch.
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigTranslations to fetch.
     */
    orderBy?: SiteConfigTranslationOrderByWithRelationInput | SiteConfigTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigTranslations.
     */
    cursor?: SiteConfigTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigTranslations.
     */
    distinct?: SiteConfigTranslationScalarFieldEnum | SiteConfigTranslationScalarFieldEnum[]
  }

  /**
   * SiteConfigTranslation findFirstOrThrow
   */
  export type SiteConfigTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigTranslation to fetch.
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigTranslations to fetch.
     */
    orderBy?: SiteConfigTranslationOrderByWithRelationInput | SiteConfigTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigTranslations.
     */
    cursor?: SiteConfigTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigTranslations.
     */
    distinct?: SiteConfigTranslationScalarFieldEnum | SiteConfigTranslationScalarFieldEnum[]
  }

  /**
   * SiteConfigTranslation findMany
   */
  export type SiteConfigTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigTranslations to fetch.
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigTranslations to fetch.
     */
    orderBy?: SiteConfigTranslationOrderByWithRelationInput | SiteConfigTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteConfigTranslations.
     */
    cursor?: SiteConfigTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigTranslations.
     */
    skip?: number
    distinct?: SiteConfigTranslationScalarFieldEnum | SiteConfigTranslationScalarFieldEnum[]
  }

  /**
   * SiteConfigTranslation create
   */
  export type SiteConfigTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteConfigTranslation.
     */
    data: XOR<SiteConfigTranslationCreateInput, SiteConfigTranslationUncheckedCreateInput>
  }

  /**
   * SiteConfigTranslation createMany
   */
  export type SiteConfigTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteConfigTranslations.
     */
    data: SiteConfigTranslationCreateManyInput | SiteConfigTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteConfigTranslation createManyAndReturn
   */
  export type SiteConfigTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many SiteConfigTranslations.
     */
    data: SiteConfigTranslationCreateManyInput | SiteConfigTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteConfigTranslation update
   */
  export type SiteConfigTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteConfigTranslation.
     */
    data: XOR<SiteConfigTranslationUpdateInput, SiteConfigTranslationUncheckedUpdateInput>
    /**
     * Choose, which SiteConfigTranslation to update.
     */
    where: SiteConfigTranslationWhereUniqueInput
  }

  /**
   * SiteConfigTranslation updateMany
   */
  export type SiteConfigTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteConfigTranslations.
     */
    data: XOR<SiteConfigTranslationUpdateManyMutationInput, SiteConfigTranslationUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigTranslations to update
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * Limit how many SiteConfigTranslations to update.
     */
    limit?: number
  }

  /**
   * SiteConfigTranslation updateManyAndReturn
   */
  export type SiteConfigTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * The data used to update SiteConfigTranslations.
     */
    data: XOR<SiteConfigTranslationUpdateManyMutationInput, SiteConfigTranslationUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigTranslations to update
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * Limit how many SiteConfigTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteConfigTranslation upsert
   */
  export type SiteConfigTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteConfigTranslation to update in case it exists.
     */
    where: SiteConfigTranslationWhereUniqueInput
    /**
     * In case the SiteConfigTranslation found by the `where` argument doesn't exist, create a new SiteConfigTranslation with this data.
     */
    create: XOR<SiteConfigTranslationCreateInput, SiteConfigTranslationUncheckedCreateInput>
    /**
     * In case the SiteConfigTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteConfigTranslationUpdateInput, SiteConfigTranslationUncheckedUpdateInput>
  }

  /**
   * SiteConfigTranslation delete
   */
  export type SiteConfigTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
    /**
     * Filter which SiteConfigTranslation to delete.
     */
    where: SiteConfigTranslationWhereUniqueInput
  }

  /**
   * SiteConfigTranslation deleteMany
   */
  export type SiteConfigTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigTranslations to delete
     */
    where?: SiteConfigTranslationWhereInput
    /**
     * Limit how many SiteConfigTranslations to delete.
     */
    limit?: number
  }

  /**
   * SiteConfigTranslation without action
   */
  export type SiteConfigTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfigTranslation
     */
    select?: SiteConfigTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfigTranslation
     */
    omit?: SiteConfigTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigTranslationInclude<ExtArgs> | null
  }


  /**
   * Model GameVote
   */

  export type AggregateGameVote = {
    _count: GameVoteCountAggregateOutputType | null
    _min: GameVoteMinAggregateOutputType | null
    _max: GameVoteMaxAggregateOutputType | null
  }

  export type GameVoteMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    userIp: string | null
    isLike: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameVoteMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    userIp: string | null
    isLike: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameVoteCountAggregateOutputType = {
    id: number
    gameId: number
    userIp: number
    isLike: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameVoteMinAggregateInputType = {
    id?: true
    gameId?: true
    userIp?: true
    isLike?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameVoteMaxAggregateInputType = {
    id?: true
    gameId?: true
    userIp?: true
    isLike?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameVoteCountAggregateInputType = {
    id?: true
    gameId?: true
    userIp?: true
    isLike?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameVote to aggregate.
     */
    where?: GameVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameVotes to fetch.
     */
    orderBy?: GameVoteOrderByWithRelationInput | GameVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameVotes
    **/
    _count?: true | GameVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameVoteMaxAggregateInputType
  }

  export type GetGameVoteAggregateType<T extends GameVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateGameVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameVote[P]>
      : GetScalarType<T[P], AggregateGameVote[P]>
  }




  export type GameVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameVoteWhereInput
    orderBy?: GameVoteOrderByWithAggregationInput | GameVoteOrderByWithAggregationInput[]
    by: GameVoteScalarFieldEnum[] | GameVoteScalarFieldEnum
    having?: GameVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameVoteCountAggregateInputType | true
    _min?: GameVoteMinAggregateInputType
    _max?: GameVoteMaxAggregateInputType
  }

  export type GameVoteGroupByOutputType = {
    id: string
    gameId: string
    userIp: string
    isLike: boolean
    createdAt: Date
    updatedAt: Date
    _count: GameVoteCountAggregateOutputType | null
    _min: GameVoteMinAggregateOutputType | null
    _max: GameVoteMaxAggregateOutputType | null
  }

  type GetGameVoteGroupByPayload<T extends GameVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameVoteGroupByOutputType[P]>
            : GetScalarType<T[P], GameVoteGroupByOutputType[P]>
        }
      >
    >


  export type GameVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userIp?: boolean
    isLike?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameVote"]>

  export type GameVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userIp?: boolean
    isLike?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameVote"]>

  export type GameVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    userIp?: boolean
    isLike?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameVote"]>

  export type GameVoteSelectScalar = {
    id?: boolean
    gameId?: boolean
    userIp?: boolean
    isLike?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "userIp" | "isLike" | "createdAt" | "updatedAt", ExtArgs["result"]["gameVote"]>
  export type GameVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameVote"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      userIp: string
      isLike: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameVote"]>
    composites: {}
  }

  type GameVoteGetPayload<S extends boolean | null | undefined | GameVoteDefaultArgs> = $Result.GetResult<Prisma.$GameVotePayload, S>

  type GameVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameVoteCountAggregateInputType | true
    }

  export interface GameVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameVote'], meta: { name: 'GameVote' } }
    /**
     * Find zero or one GameVote that matches the filter.
     * @param {GameVoteFindUniqueArgs} args - Arguments to find a GameVote
     * @example
     * // Get one GameVote
     * const gameVote = await prisma.gameVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameVoteFindUniqueArgs>(args: SelectSubset<T, GameVoteFindUniqueArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameVoteFindUniqueOrThrowArgs} args - Arguments to find a GameVote
     * @example
     * // Get one GameVote
     * const gameVote = await prisma.gameVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, GameVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteFindFirstArgs} args - Arguments to find a GameVote
     * @example
     * // Get one GameVote
     * const gameVote = await prisma.gameVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameVoteFindFirstArgs>(args?: SelectSubset<T, GameVoteFindFirstArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteFindFirstOrThrowArgs} args - Arguments to find a GameVote
     * @example
     * // Get one GameVote
     * const gameVote = await prisma.gameVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, GameVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameVotes
     * const gameVotes = await prisma.gameVote.findMany()
     * 
     * // Get first 10 GameVotes
     * const gameVotes = await prisma.gameVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameVoteWithIdOnly = await prisma.gameVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameVoteFindManyArgs>(args?: SelectSubset<T, GameVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameVote.
     * @param {GameVoteCreateArgs} args - Arguments to create a GameVote.
     * @example
     * // Create one GameVote
     * const GameVote = await prisma.gameVote.create({
     *   data: {
     *     // ... data to create a GameVote
     *   }
     * })
     * 
     */
    create<T extends GameVoteCreateArgs>(args: SelectSubset<T, GameVoteCreateArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameVotes.
     * @param {GameVoteCreateManyArgs} args - Arguments to create many GameVotes.
     * @example
     * // Create many GameVotes
     * const gameVote = await prisma.gameVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameVoteCreateManyArgs>(args?: SelectSubset<T, GameVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameVotes and returns the data saved in the database.
     * @param {GameVoteCreateManyAndReturnArgs} args - Arguments to create many GameVotes.
     * @example
     * // Create many GameVotes
     * const gameVote = await prisma.gameVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameVotes and only return the `id`
     * const gameVoteWithIdOnly = await prisma.gameVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, GameVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameVote.
     * @param {GameVoteDeleteArgs} args - Arguments to delete one GameVote.
     * @example
     * // Delete one GameVote
     * const GameVote = await prisma.gameVote.delete({
     *   where: {
     *     // ... filter to delete one GameVote
     *   }
     * })
     * 
     */
    delete<T extends GameVoteDeleteArgs>(args: SelectSubset<T, GameVoteDeleteArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameVote.
     * @param {GameVoteUpdateArgs} args - Arguments to update one GameVote.
     * @example
     * // Update one GameVote
     * const gameVote = await prisma.gameVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameVoteUpdateArgs>(args: SelectSubset<T, GameVoteUpdateArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameVotes.
     * @param {GameVoteDeleteManyArgs} args - Arguments to filter GameVotes to delete.
     * @example
     * // Delete a few GameVotes
     * const { count } = await prisma.gameVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameVoteDeleteManyArgs>(args?: SelectSubset<T, GameVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameVotes
     * const gameVote = await prisma.gameVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameVoteUpdateManyArgs>(args: SelectSubset<T, GameVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameVotes and returns the data updated in the database.
     * @param {GameVoteUpdateManyAndReturnArgs} args - Arguments to update many GameVotes.
     * @example
     * // Update many GameVotes
     * const gameVote = await prisma.gameVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameVotes and only return the `id`
     * const gameVoteWithIdOnly = await prisma.gameVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, GameVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameVote.
     * @param {GameVoteUpsertArgs} args - Arguments to update or create a GameVote.
     * @example
     * // Update or create a GameVote
     * const gameVote = await prisma.gameVote.upsert({
     *   create: {
     *     // ... data to create a GameVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameVote we want to update
     *   }
     * })
     */
    upsert<T extends GameVoteUpsertArgs>(args: SelectSubset<T, GameVoteUpsertArgs<ExtArgs>>): Prisma__GameVoteClient<$Result.GetResult<Prisma.$GameVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteCountArgs} args - Arguments to filter GameVotes to count.
     * @example
     * // Count the number of GameVotes
     * const count = await prisma.gameVote.count({
     *   where: {
     *     // ... the filter for the GameVotes we want to count
     *   }
     * })
    **/
    count<T extends GameVoteCountArgs>(
      args?: Subset<T, GameVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameVoteAggregateArgs>(args: Subset<T, GameVoteAggregateArgs>): Prisma.PrismaPromise<GetGameVoteAggregateType<T>>

    /**
     * Group by GameVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameVoteGroupByArgs['orderBy'] }
        : { orderBy?: GameVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameVote model
   */
  readonly fields: GameVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameVote model
   */
  interface GameVoteFieldRefs {
    readonly id: FieldRef<"GameVote", 'String'>
    readonly gameId: FieldRef<"GameVote", 'String'>
    readonly userIp: FieldRef<"GameVote", 'String'>
    readonly isLike: FieldRef<"GameVote", 'Boolean'>
    readonly createdAt: FieldRef<"GameVote", 'DateTime'>
    readonly updatedAt: FieldRef<"GameVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameVote findUnique
   */
  export type GameVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter, which GameVote to fetch.
     */
    where: GameVoteWhereUniqueInput
  }

  /**
   * GameVote findUniqueOrThrow
   */
  export type GameVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter, which GameVote to fetch.
     */
    where: GameVoteWhereUniqueInput
  }

  /**
   * GameVote findFirst
   */
  export type GameVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter, which GameVote to fetch.
     */
    where?: GameVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameVotes to fetch.
     */
    orderBy?: GameVoteOrderByWithRelationInput | GameVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameVotes.
     */
    cursor?: GameVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameVotes.
     */
    distinct?: GameVoteScalarFieldEnum | GameVoteScalarFieldEnum[]
  }

  /**
   * GameVote findFirstOrThrow
   */
  export type GameVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter, which GameVote to fetch.
     */
    where?: GameVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameVotes to fetch.
     */
    orderBy?: GameVoteOrderByWithRelationInput | GameVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameVotes.
     */
    cursor?: GameVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameVotes.
     */
    distinct?: GameVoteScalarFieldEnum | GameVoteScalarFieldEnum[]
  }

  /**
   * GameVote findMany
   */
  export type GameVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter, which GameVotes to fetch.
     */
    where?: GameVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameVotes to fetch.
     */
    orderBy?: GameVoteOrderByWithRelationInput | GameVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameVotes.
     */
    cursor?: GameVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameVotes.
     */
    skip?: number
    distinct?: GameVoteScalarFieldEnum | GameVoteScalarFieldEnum[]
  }

  /**
   * GameVote create
   */
  export type GameVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a GameVote.
     */
    data: XOR<GameVoteCreateInput, GameVoteUncheckedCreateInput>
  }

  /**
   * GameVote createMany
   */
  export type GameVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameVotes.
     */
    data: GameVoteCreateManyInput | GameVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameVote createManyAndReturn
   */
  export type GameVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * The data used to create many GameVotes.
     */
    data: GameVoteCreateManyInput | GameVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameVote update
   */
  export type GameVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a GameVote.
     */
    data: XOR<GameVoteUpdateInput, GameVoteUncheckedUpdateInput>
    /**
     * Choose, which GameVote to update.
     */
    where: GameVoteWhereUniqueInput
  }

  /**
   * GameVote updateMany
   */
  export type GameVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameVotes.
     */
    data: XOR<GameVoteUpdateManyMutationInput, GameVoteUncheckedUpdateManyInput>
    /**
     * Filter which GameVotes to update
     */
    where?: GameVoteWhereInput
    /**
     * Limit how many GameVotes to update.
     */
    limit?: number
  }

  /**
   * GameVote updateManyAndReturn
   */
  export type GameVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * The data used to update GameVotes.
     */
    data: XOR<GameVoteUpdateManyMutationInput, GameVoteUncheckedUpdateManyInput>
    /**
     * Filter which GameVotes to update
     */
    where?: GameVoteWhereInput
    /**
     * Limit how many GameVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameVote upsert
   */
  export type GameVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the GameVote to update in case it exists.
     */
    where: GameVoteWhereUniqueInput
    /**
     * In case the GameVote found by the `where` argument doesn't exist, create a new GameVote with this data.
     */
    create: XOR<GameVoteCreateInput, GameVoteUncheckedCreateInput>
    /**
     * In case the GameVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameVoteUpdateInput, GameVoteUncheckedUpdateInput>
  }

  /**
   * GameVote delete
   */
  export type GameVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
    /**
     * Filter which GameVote to delete.
     */
    where: GameVoteWhereUniqueInput
  }

  /**
   * GameVote deleteMany
   */
  export type GameVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameVotes to delete
     */
    where?: GameVoteWhereInput
    /**
     * Limit how many GameVotes to delete.
     */
    limit?: number
  }

  /**
   * GameVote without action
   */
  export type GameVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameVote
     */
    select?: GameVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameVote
     */
    omit?: GameVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameVoteInclude<ExtArgs> | null
  }


  /**
   * Model AITask
   */

  export type AggregateAITask = {
    _count: AITaskCountAggregateOutputType | null
    _avg: AITaskAvgAggregateOutputType | null
    _sum: AITaskSumAggregateOutputType | null
    _min: AITaskMinAggregateOutputType | null
    _max: AITaskMaxAggregateOutputType | null
  }

  export type AITaskAvgAggregateOutputType = {
    progress: number | null
  }

  export type AITaskSumAggregateOutputType = {
    progress: number | null
  }

  export type AITaskMinAggregateOutputType = {
    id: string | null
    taskType: string | null
    status: $Enums.AITaskStatus | null
    progress: number | null
    currentStep: string | null
    errorMessage: string | null
    needsConfirmation: boolean | null
    confirmPrompt: string | null
    confirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AITaskMaxAggregateOutputType = {
    id: string | null
    taskType: string | null
    status: $Enums.AITaskStatus | null
    progress: number | null
    currentStep: string | null
    errorMessage: string | null
    needsConfirmation: boolean | null
    confirmPrompt: string | null
    confirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AITaskCountAggregateOutputType = {
    id: number
    taskType: number
    status: number
    progress: number
    currentStep: number
    inputData: number
    outputData: number
    errorMessage: number
    errorDetails: number
    needsConfirmation: number
    confirmPrompt: number
    confirmedAt: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type AITaskAvgAggregateInputType = {
    progress?: true
  }

  export type AITaskSumAggregateInputType = {
    progress?: true
  }

  export type AITaskMinAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    progress?: true
    currentStep?: true
    errorMessage?: true
    needsConfirmation?: true
    confirmPrompt?: true
    confirmedAt?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AITaskMaxAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    progress?: true
    currentStep?: true
    errorMessage?: true
    needsConfirmation?: true
    confirmPrompt?: true
    confirmedAt?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AITaskCountAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    progress?: true
    currentStep?: true
    inputData?: true
    outputData?: true
    errorMessage?: true
    errorDetails?: true
    needsConfirmation?: true
    confirmPrompt?: true
    confirmedAt?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AITaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITask to aggregate.
     */
    where?: AITaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITasks to fetch.
     */
    orderBy?: AITaskOrderByWithRelationInput | AITaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AITaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AITasks
    **/
    _count?: true | AITaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AITaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AITaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AITaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AITaskMaxAggregateInputType
  }

  export type GetAITaskAggregateType<T extends AITaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAITask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAITask[P]>
      : GetScalarType<T[P], AggregateAITask[P]>
  }




  export type AITaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AITaskWhereInput
    orderBy?: AITaskOrderByWithAggregationInput | AITaskOrderByWithAggregationInput[]
    by: AITaskScalarFieldEnum[] | AITaskScalarFieldEnum
    having?: AITaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AITaskCountAggregateInputType | true
    _avg?: AITaskAvgAggregateInputType
    _sum?: AITaskSumAggregateInputType
    _min?: AITaskMinAggregateInputType
    _max?: AITaskMaxAggregateInputType
  }

  export type AITaskGroupByOutputType = {
    id: string
    taskType: string
    status: $Enums.AITaskStatus
    progress: number
    currentStep: string | null
    inputData: JsonValue | null
    outputData: JsonValue | null
    errorMessage: string | null
    errorDetails: JsonValue | null
    needsConfirmation: boolean
    confirmPrompt: string | null
    confirmedAt: Date | null
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: AITaskCountAggregateOutputType | null
    _avg: AITaskAvgAggregateOutputType | null
    _sum: AITaskSumAggregateOutputType | null
    _min: AITaskMinAggregateOutputType | null
    _max: AITaskMaxAggregateOutputType | null
  }

  type GetAITaskGroupByPayload<T extends AITaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AITaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AITaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AITaskGroupByOutputType[P]>
            : GetScalarType<T[P], AITaskGroupByOutputType[P]>
        }
      >
    >


  export type AITaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    progress?: boolean
    currentStep?: boolean
    inputData?: boolean
    outputData?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    needsConfirmation?: boolean
    confirmPrompt?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITask"]>

  export type AITaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    progress?: boolean
    currentStep?: boolean
    inputData?: boolean
    outputData?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    needsConfirmation?: boolean
    confirmPrompt?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITask"]>

  export type AITaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    progress?: boolean
    currentStep?: boolean
    inputData?: boolean
    outputData?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    needsConfirmation?: boolean
    confirmPrompt?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["aITask"]>

  export type AITaskSelectScalar = {
    id?: boolean
    taskType?: boolean
    status?: boolean
    progress?: boolean
    currentStep?: boolean
    inputData?: boolean
    outputData?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    needsConfirmation?: boolean
    confirmPrompt?: boolean
    confirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type AITaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskType" | "status" | "progress" | "currentStep" | "inputData" | "outputData" | "errorMessage" | "errorDetails" | "needsConfirmation" | "confirmPrompt" | "confirmedAt" | "createdAt" | "updatedAt" | "startedAt" | "completedAt", ExtArgs["result"]["aITask"]>

  export type $AITaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AITask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskType: string
      status: $Enums.AITaskStatus
      progress: number
      currentStep: string | null
      inputData: Prisma.JsonValue | null
      outputData: Prisma.JsonValue | null
      errorMessage: string | null
      errorDetails: Prisma.JsonValue | null
      needsConfirmation: boolean
      confirmPrompt: string | null
      confirmedAt: Date | null
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["aITask"]>
    composites: {}
  }

  type AITaskGetPayload<S extends boolean | null | undefined | AITaskDefaultArgs> = $Result.GetResult<Prisma.$AITaskPayload, S>

  type AITaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AITaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AITaskCountAggregateInputType | true
    }

  export interface AITaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AITask'], meta: { name: 'AITask' } }
    /**
     * Find zero or one AITask that matches the filter.
     * @param {AITaskFindUniqueArgs} args - Arguments to find a AITask
     * @example
     * // Get one AITask
     * const aITask = await prisma.aITask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AITaskFindUniqueArgs>(args: SelectSubset<T, AITaskFindUniqueArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AITask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AITaskFindUniqueOrThrowArgs} args - Arguments to find a AITask
     * @example
     * // Get one AITask
     * const aITask = await prisma.aITask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AITaskFindUniqueOrThrowArgs>(args: SelectSubset<T, AITaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskFindFirstArgs} args - Arguments to find a AITask
     * @example
     * // Get one AITask
     * const aITask = await prisma.aITask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AITaskFindFirstArgs>(args?: SelectSubset<T, AITaskFindFirstArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AITask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskFindFirstOrThrowArgs} args - Arguments to find a AITask
     * @example
     * // Get one AITask
     * const aITask = await prisma.aITask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AITaskFindFirstOrThrowArgs>(args?: SelectSubset<T, AITaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AITasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AITasks
     * const aITasks = await prisma.aITask.findMany()
     * 
     * // Get first 10 AITasks
     * const aITasks = await prisma.aITask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aITaskWithIdOnly = await prisma.aITask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AITaskFindManyArgs>(args?: SelectSubset<T, AITaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AITask.
     * @param {AITaskCreateArgs} args - Arguments to create a AITask.
     * @example
     * // Create one AITask
     * const AITask = await prisma.aITask.create({
     *   data: {
     *     // ... data to create a AITask
     *   }
     * })
     * 
     */
    create<T extends AITaskCreateArgs>(args: SelectSubset<T, AITaskCreateArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AITasks.
     * @param {AITaskCreateManyArgs} args - Arguments to create many AITasks.
     * @example
     * // Create many AITasks
     * const aITask = await prisma.aITask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AITaskCreateManyArgs>(args?: SelectSubset<T, AITaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AITasks and returns the data saved in the database.
     * @param {AITaskCreateManyAndReturnArgs} args - Arguments to create many AITasks.
     * @example
     * // Create many AITasks
     * const aITask = await prisma.aITask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AITasks and only return the `id`
     * const aITaskWithIdOnly = await prisma.aITask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AITaskCreateManyAndReturnArgs>(args?: SelectSubset<T, AITaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AITask.
     * @param {AITaskDeleteArgs} args - Arguments to delete one AITask.
     * @example
     * // Delete one AITask
     * const AITask = await prisma.aITask.delete({
     *   where: {
     *     // ... filter to delete one AITask
     *   }
     * })
     * 
     */
    delete<T extends AITaskDeleteArgs>(args: SelectSubset<T, AITaskDeleteArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AITask.
     * @param {AITaskUpdateArgs} args - Arguments to update one AITask.
     * @example
     * // Update one AITask
     * const aITask = await prisma.aITask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AITaskUpdateArgs>(args: SelectSubset<T, AITaskUpdateArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AITasks.
     * @param {AITaskDeleteManyArgs} args - Arguments to filter AITasks to delete.
     * @example
     * // Delete a few AITasks
     * const { count } = await prisma.aITask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AITaskDeleteManyArgs>(args?: SelectSubset<T, AITaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AITasks
     * const aITask = await prisma.aITask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AITaskUpdateManyArgs>(args: SelectSubset<T, AITaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AITasks and returns the data updated in the database.
     * @param {AITaskUpdateManyAndReturnArgs} args - Arguments to update many AITasks.
     * @example
     * // Update many AITasks
     * const aITask = await prisma.aITask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AITasks and only return the `id`
     * const aITaskWithIdOnly = await prisma.aITask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AITaskUpdateManyAndReturnArgs>(args: SelectSubset<T, AITaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AITask.
     * @param {AITaskUpsertArgs} args - Arguments to update or create a AITask.
     * @example
     * // Update or create a AITask
     * const aITask = await prisma.aITask.upsert({
     *   create: {
     *     // ... data to create a AITask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AITask we want to update
     *   }
     * })
     */
    upsert<T extends AITaskUpsertArgs>(args: SelectSubset<T, AITaskUpsertArgs<ExtArgs>>): Prisma__AITaskClient<$Result.GetResult<Prisma.$AITaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AITasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskCountArgs} args - Arguments to filter AITasks to count.
     * @example
     * // Count the number of AITasks
     * const count = await prisma.aITask.count({
     *   where: {
     *     // ... the filter for the AITasks we want to count
     *   }
     * })
    **/
    count<T extends AITaskCountArgs>(
      args?: Subset<T, AITaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AITaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AITask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AITaskAggregateArgs>(args: Subset<T, AITaskAggregateArgs>): Prisma.PrismaPromise<GetAITaskAggregateType<T>>

    /**
     * Group by AITask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AITaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AITaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AITaskGroupByArgs['orderBy'] }
        : { orderBy?: AITaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AITaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAITaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AITask model
   */
  readonly fields: AITaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AITask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AITaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AITask model
   */
  interface AITaskFieldRefs {
    readonly id: FieldRef<"AITask", 'String'>
    readonly taskType: FieldRef<"AITask", 'String'>
    readonly status: FieldRef<"AITask", 'AITaskStatus'>
    readonly progress: FieldRef<"AITask", 'Int'>
    readonly currentStep: FieldRef<"AITask", 'String'>
    readonly inputData: FieldRef<"AITask", 'Json'>
    readonly outputData: FieldRef<"AITask", 'Json'>
    readonly errorMessage: FieldRef<"AITask", 'String'>
    readonly errorDetails: FieldRef<"AITask", 'Json'>
    readonly needsConfirmation: FieldRef<"AITask", 'Boolean'>
    readonly confirmPrompt: FieldRef<"AITask", 'String'>
    readonly confirmedAt: FieldRef<"AITask", 'DateTime'>
    readonly createdAt: FieldRef<"AITask", 'DateTime'>
    readonly updatedAt: FieldRef<"AITask", 'DateTime'>
    readonly startedAt: FieldRef<"AITask", 'DateTime'>
    readonly completedAt: FieldRef<"AITask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AITask findUnique
   */
  export type AITaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter, which AITask to fetch.
     */
    where: AITaskWhereUniqueInput
  }

  /**
   * AITask findUniqueOrThrow
   */
  export type AITaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter, which AITask to fetch.
     */
    where: AITaskWhereUniqueInput
  }

  /**
   * AITask findFirst
   */
  export type AITaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter, which AITask to fetch.
     */
    where?: AITaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITasks to fetch.
     */
    orderBy?: AITaskOrderByWithRelationInput | AITaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITasks.
     */
    cursor?: AITaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITasks.
     */
    distinct?: AITaskScalarFieldEnum | AITaskScalarFieldEnum[]
  }

  /**
   * AITask findFirstOrThrow
   */
  export type AITaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter, which AITask to fetch.
     */
    where?: AITaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITasks to fetch.
     */
    orderBy?: AITaskOrderByWithRelationInput | AITaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AITasks.
     */
    cursor?: AITaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AITasks.
     */
    distinct?: AITaskScalarFieldEnum | AITaskScalarFieldEnum[]
  }

  /**
   * AITask findMany
   */
  export type AITaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter, which AITasks to fetch.
     */
    where?: AITaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AITasks to fetch.
     */
    orderBy?: AITaskOrderByWithRelationInput | AITaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AITasks.
     */
    cursor?: AITaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AITasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AITasks.
     */
    skip?: number
    distinct?: AITaskScalarFieldEnum | AITaskScalarFieldEnum[]
  }

  /**
   * AITask create
   */
  export type AITaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * The data needed to create a AITask.
     */
    data: XOR<AITaskCreateInput, AITaskUncheckedCreateInput>
  }

  /**
   * AITask createMany
   */
  export type AITaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AITasks.
     */
    data: AITaskCreateManyInput | AITaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AITask createManyAndReturn
   */
  export type AITaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * The data used to create many AITasks.
     */
    data: AITaskCreateManyInput | AITaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AITask update
   */
  export type AITaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * The data needed to update a AITask.
     */
    data: XOR<AITaskUpdateInput, AITaskUncheckedUpdateInput>
    /**
     * Choose, which AITask to update.
     */
    where: AITaskWhereUniqueInput
  }

  /**
   * AITask updateMany
   */
  export type AITaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AITasks.
     */
    data: XOR<AITaskUpdateManyMutationInput, AITaskUncheckedUpdateManyInput>
    /**
     * Filter which AITasks to update
     */
    where?: AITaskWhereInput
    /**
     * Limit how many AITasks to update.
     */
    limit?: number
  }

  /**
   * AITask updateManyAndReturn
   */
  export type AITaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * The data used to update AITasks.
     */
    data: XOR<AITaskUpdateManyMutationInput, AITaskUncheckedUpdateManyInput>
    /**
     * Filter which AITasks to update
     */
    where?: AITaskWhereInput
    /**
     * Limit how many AITasks to update.
     */
    limit?: number
  }

  /**
   * AITask upsert
   */
  export type AITaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * The filter to search for the AITask to update in case it exists.
     */
    where: AITaskWhereUniqueInput
    /**
     * In case the AITask found by the `where` argument doesn't exist, create a new AITask with this data.
     */
    create: XOR<AITaskCreateInput, AITaskUncheckedCreateInput>
    /**
     * In case the AITask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AITaskUpdateInput, AITaskUncheckedUpdateInput>
  }

  /**
   * AITask delete
   */
  export type AITaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
    /**
     * Filter which AITask to delete.
     */
    where: AITaskWhereUniqueInput
  }

  /**
   * AITask deleteMany
   */
  export type AITaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AITasks to delete
     */
    where?: AITaskWhereInput
    /**
     * Limit how many AITasks to delete.
     */
    limit?: number
  }

  /**
   * AITask without action
   */
  export type AITaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AITask
     */
    select?: AITaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AITask
     */
    omit?: AITaskOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    icon: 'icon',
    sortOrder: 'sortOrder',
    isEnabled: 'isEnabled',
    parentId: 'parentId',
    name: 'name',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CategoryTranslationScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryTranslationScalarFieldEnum = (typeof CategoryTranslationScalarFieldEnum)[keyof typeof CategoryTranslationScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    icon: 'icon',
    isEnabled: 'isEnabled',
    name: 'name',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagTranslationScalarFieldEnum: {
    id: 'id',
    tagId: 'tagId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagTranslationScalarFieldEnum = (typeof TagTranslationScalarFieldEnum)[keyof typeof TagTranslationScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    thumbnail: 'thumbnail',
    banner: 'banner',
    screenshots: 'screenshots',
    videos: 'videos',
    embedUrl: 'embedUrl',
    gameUrl: 'gameUrl',
    dimensions: 'dimensions',
    status: 'status',
    isFeatured: 'isFeatured',
    playCount: 'playCount',
    viewCount: 'viewCount',
    likes: 'likes',
    dislikes: 'dislikes',
    rating: 'rating',
    ratingCount: 'ratingCount',
    qualityScore: 'qualityScore',
    sourcePlatform: 'sourcePlatform',
    sourcePlatformId: 'sourcePlatformId',
    developer: 'developer',
    developerUrl: 'developerUrl',
    gameInfo: 'gameInfo',
    releaseDate: 'releaseDate',
    sourceUpdatedAt: 'sourceUpdatedAt',
    importedAt: 'importedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GameTranslationScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    locale: 'locale',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    translationInfo: 'translationInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameTranslationScalarFieldEnum = (typeof GameTranslationScalarFieldEnum)[keyof typeof GameTranslationScalarFieldEnum]


  export const GameTagScalarFieldEnum: {
    gameId: 'gameId',
    tagId: 'tagId'
  };

  export type GameTagScalarFieldEnum = (typeof GameTagScalarFieldEnum)[keyof typeof GameTagScalarFieldEnum]


  export const GameCategoryScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    categoryId: 'categoryId',
    mainCategoryId: 'mainCategoryId',
    isPrimary: 'isPrimary',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameCategoryScalarFieldEnum = (typeof GameCategoryScalarFieldEnum)[keyof typeof GameCategoryScalarFieldEnum]


  export const PageTypeScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    type: 'type',
    icon: 'icon',
    isEnabled: 'isEnabled',
    sortOrder: 'sortOrder',
    title: 'title',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    pageInfo: 'pageInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageTypeScalarFieldEnum = (typeof PageTypeScalarFieldEnum)[keyof typeof PageTypeScalarFieldEnum]


  export const PageTypeTranslationScalarFieldEnum: {
    id: 'id',
    pageTypeId: 'pageTypeId',
    locale: 'locale',
    title: 'title',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    pageInfo: 'pageInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageTypeTranslationScalarFieldEnum = (typeof PageTypeTranslationScalarFieldEnum)[keyof typeof PageTypeTranslationScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nativeName: 'nativeName',
    flag: 'flag',
    localeCode: 'localeCode',
    direction: 'direction',
    isDefault: 'isDefault',
    isEnabled: 'isEnabled',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const LanguageTranslationScalarFieldEnum: {
    id: 'id',
    languageId: 'languageId',
    locale: 'locale',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageTranslationScalarFieldEnum = (typeof LanguageTranslationScalarFieldEnum)[keyof typeof LanguageTranslationScalarFieldEnum]


  export const SiteConfigScalarFieldEnum: {
    id: 'id',
    siteName: 'siteName',
    siteDescription: 'siteDescription',
    siteUrl: 'siteUrl',
    logoUrl: 'logoUrl',
    faviconUrl: 'faviconUrl',
    ogImageUrl: 'ogImageUrl',
    contactEmail: 'contactEmail',
    supportEmail: 'supportEmail',
    socialLinks: 'socialLinks',
    defaultKeywords: 'defaultKeywords',
    twitterHandle: 'twitterHandle',
    googleAnalyticsId: 'googleAnalyticsId',
    googleAdsenseId: 'googleAdsenseId',
    customScripts: 'customScripts',
    maintenanceMode: 'maintenanceMode',
    enableComments: 'enableComments',
    enableRatings: 'enableRatings',
    extraConfig: 'extraConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteConfigScalarFieldEnum = (typeof SiteConfigScalarFieldEnum)[keyof typeof SiteConfigScalarFieldEnum]


  export const SiteConfigTranslationScalarFieldEnum: {
    id: 'id',
    siteConfigId: 'siteConfigId',
    locale: 'locale',
    siteName: 'siteName',
    siteDescription: 'siteDescription',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteConfigTranslationScalarFieldEnum = (typeof SiteConfigTranslationScalarFieldEnum)[keyof typeof SiteConfigTranslationScalarFieldEnum]


  export const GameVoteScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    userIp: 'userIp',
    isLike: 'isLike',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameVoteScalarFieldEnum = (typeof GameVoteScalarFieldEnum)[keyof typeof GameVoteScalarFieldEnum]


  export const AITaskScalarFieldEnum: {
    id: 'id',
    taskType: 'taskType',
    status: 'status',
    progress: 'progress',
    currentStep: 'currentStep',
    inputData: 'inputData',
    outputData: 'outputData',
    errorMessage: 'errorMessage',
    errorDetails: 'errorDetails',
    needsConfirmation: 'needsConfirmation',
    confirmPrompt: 'confirmPrompt',
    confirmedAt: 'confirmedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type AITaskScalarFieldEnum = (typeof AITaskScalarFieldEnum)[keyof typeof AITaskScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PageTypeEnum'
   */
  export type EnumPageTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageTypeEnum'>
    


  /**
   * Reference to a field of type 'PageTypeEnum[]'
   */
  export type ListEnumPageTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageTypeEnum[]'>
    


  /**
   * Reference to a field of type 'TextDirection'
   */
  export type EnumTextDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextDirection'>
    


  /**
   * Reference to a field of type 'TextDirection[]'
   */
  export type ListEnumTextDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextDirection[]'>
    


  /**
   * Reference to a field of type 'AITaskStatus'
   */
  export type EnumAITaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AITaskStatus'>
    


  /**
   * Reference to a field of type 'AITaskStatus[]'
   */
  export type ListEnumAITaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AITaskStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isEnabled?: BoolFilter<"Category"> | boolean
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    translations?: CategoryTranslationListRelationFilter
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    subCategories?: CategoryListRelationFilter
    gameSubCategories?: GameCategoryListRelationFilter
    gameMainCategories?: GameCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isEnabled?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: CategoryTranslationOrderByRelationAggregateInput
    parent?: CategoryOrderByWithRelationInput
    subCategories?: CategoryOrderByRelationAggregateInput
    gameSubCategories?: GameCategoryOrderByRelationAggregateInput
    gameMainCategories?: GameCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    icon?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isEnabled?: BoolFilter<"Category"> | boolean
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    translations?: CategoryTranslationListRelationFilter
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    subCategories?: CategoryListRelationFilter
    gameSubCategories?: GameCategoryListRelationFilter
    gameMainCategories?: GameCategoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isEnabled?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Category"> | number
    isEnabled?: BoolWithAggregatesFilter<"Category"> | boolean
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Category"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type CategoryTranslationWhereInput = {
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    id?: StringFilter<"CategoryTranslation"> | string
    categoryId?: StringFilter<"CategoryTranslation"> | string
    locale?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaTitle?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaDescription?: StringNullableFilter<"CategoryTranslation"> | string | null
    keywords?: StringNullableFilter<"CategoryTranslation"> | string | null
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type CategoryTranslationOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
  }

  export type CategoryTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_locale?: CategoryTranslationCategoryIdLocaleCompoundUniqueInput
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    categoryId?: StringFilter<"CategoryTranslation"> | string
    locale?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaTitle?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaDescription?: StringNullableFilter<"CategoryTranslation"> | string | null
    keywords?: StringNullableFilter<"CategoryTranslation"> | string | null
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "categoryId_locale">

  export type CategoryTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryTranslationCountOrderByAggregateInput
    _max?: CategoryTranslationMaxOrderByAggregateInput
    _min?: CategoryTranslationMinOrderByAggregateInput
  }

  export type CategoryTranslationScalarWhereWithAggregatesInput = {
    AND?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    OR?: CategoryTranslationScalarWhereWithAggregatesInput[]
    NOT?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    categoryId?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    locale?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    name?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryTranslation"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    icon?: StringNullableFilter<"Tag"> | string | null
    isEnabled?: BoolFilter<"Tag"> | boolean
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    metaTitle?: StringNullableFilter<"Tag"> | string | null
    metaDescription?: StringNullableFilter<"Tag"> | string | null
    keywords?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    games?: GameTagListRelationFilter
    translations?: TagTranslationListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    games?: GameTagOrderByRelationAggregateInput
    translations?: TagTranslationOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    icon?: StringNullableFilter<"Tag"> | string | null
    isEnabled?: BoolFilter<"Tag"> | boolean
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    metaTitle?: StringNullableFilter<"Tag"> | string | null
    metaDescription?: StringNullableFilter<"Tag"> | string | null
    keywords?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    games?: GameTagListRelationFilter
    translations?: TagTranslationListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    icon?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"Tag"> | boolean
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagTranslationWhereInput = {
    AND?: TagTranslationWhereInput | TagTranslationWhereInput[]
    OR?: TagTranslationWhereInput[]
    NOT?: TagTranslationWhereInput | TagTranslationWhereInput[]
    id?: StringFilter<"TagTranslation"> | string
    tagId?: StringFilter<"TagTranslation"> | string
    locale?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    description?: StringNullableFilter<"TagTranslation"> | string | null
    metaTitle?: StringNullableFilter<"TagTranslation"> | string | null
    metaDescription?: StringNullableFilter<"TagTranslation"> | string | null
    keywords?: StringNullableFilter<"TagTranslation"> | string | null
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TagTranslationOrderByWithRelationInput = {
    id?: SortOrder
    tagId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tag?: TagOrderByWithRelationInput
  }

  export type TagTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagId_locale?: TagTranslationTagIdLocaleCompoundUniqueInput
    AND?: TagTranslationWhereInput | TagTranslationWhereInput[]
    OR?: TagTranslationWhereInput[]
    NOT?: TagTranslationWhereInput | TagTranslationWhereInput[]
    tagId?: StringFilter<"TagTranslation"> | string
    locale?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    description?: StringNullableFilter<"TagTranslation"> | string | null
    metaTitle?: StringNullableFilter<"TagTranslation"> | string | null
    metaDescription?: StringNullableFilter<"TagTranslation"> | string | null
    keywords?: StringNullableFilter<"TagTranslation"> | string | null
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "tagId_locale">

  export type TagTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    tagId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagTranslationCountOrderByAggregateInput
    _max?: TagTranslationMaxOrderByAggregateInput
    _min?: TagTranslationMinOrderByAggregateInput
  }

  export type TagTranslationScalarWhereWithAggregatesInput = {
    AND?: TagTranslationScalarWhereWithAggregatesInput | TagTranslationScalarWhereWithAggregatesInput[]
    OR?: TagTranslationScalarWhereWithAggregatesInput[]
    NOT?: TagTranslationScalarWhereWithAggregatesInput | TagTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TagTranslation"> | string
    tagId?: StringWithAggregatesFilter<"TagTranslation"> | string
    locale?: StringWithAggregatesFilter<"TagTranslation"> | string
    name?: StringWithAggregatesFilter<"TagTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"TagTranslation"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"TagTranslation"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"TagTranslation"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"TagTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TagTranslation"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    slug?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    keywords?: StringNullableFilter<"Game"> | string | null
    metaTitle?: StringNullableFilter<"Game"> | string | null
    metaDescription?: StringNullableFilter<"Game"> | string | null
    thumbnail?: StringFilter<"Game"> | string
    banner?: StringNullableFilter<"Game"> | string | null
    screenshots?: StringNullableListFilter<"Game">
    videos?: StringNullableListFilter<"Game">
    embedUrl?: StringFilter<"Game"> | string
    gameUrl?: StringNullableFilter<"Game"> | string | null
    dimensions?: JsonFilter<"Game">
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    isFeatured?: BoolFilter<"Game"> | boolean
    playCount?: IntFilter<"Game"> | number
    viewCount?: IntFilter<"Game"> | number
    likes?: IntFilter<"Game"> | number
    dislikes?: IntFilter<"Game"> | number
    rating?: FloatFilter<"Game"> | number
    ratingCount?: IntFilter<"Game"> | number
    qualityScore?: FloatNullableFilter<"Game"> | number | null
    sourcePlatform?: StringNullableFilter<"Game"> | string | null
    sourcePlatformId?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    developerUrl?: StringNullableFilter<"Game"> | string | null
    gameInfo?: JsonNullableFilter<"Game">
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    sourceUpdatedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    importedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    gameCategories?: GameCategoryListRelationFilter
    tags?: GameTagListRelationFilter
    translations?: GameTranslationListRelationFilter
    votes?: GameVoteListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    thumbnail?: SortOrder
    banner?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    videos?: SortOrder
    embedUrl?: SortOrder
    gameUrl?: SortOrderInput | SortOrder
    dimensions?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    sourcePlatform?: SortOrderInput | SortOrder
    sourcePlatformId?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    developerUrl?: SortOrderInput | SortOrder
    gameInfo?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    sourceUpdatedAt?: SortOrderInput | SortOrder
    importedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCategories?: GameCategoryOrderByRelationAggregateInput
    tags?: GameTagOrderByRelationAggregateInput
    translations?: GameTranslationOrderByRelationAggregateInput
    votes?: GameVoteOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    title?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    keywords?: StringNullableFilter<"Game"> | string | null
    metaTitle?: StringNullableFilter<"Game"> | string | null
    metaDescription?: StringNullableFilter<"Game"> | string | null
    thumbnail?: StringFilter<"Game"> | string
    banner?: StringNullableFilter<"Game"> | string | null
    screenshots?: StringNullableListFilter<"Game">
    videos?: StringNullableListFilter<"Game">
    embedUrl?: StringFilter<"Game"> | string
    gameUrl?: StringNullableFilter<"Game"> | string | null
    dimensions?: JsonFilter<"Game">
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    isFeatured?: BoolFilter<"Game"> | boolean
    playCount?: IntFilter<"Game"> | number
    viewCount?: IntFilter<"Game"> | number
    likes?: IntFilter<"Game"> | number
    dislikes?: IntFilter<"Game"> | number
    rating?: FloatFilter<"Game"> | number
    ratingCount?: IntFilter<"Game"> | number
    qualityScore?: FloatNullableFilter<"Game"> | number | null
    sourcePlatform?: StringNullableFilter<"Game"> | string | null
    sourcePlatformId?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    developerUrl?: StringNullableFilter<"Game"> | string | null
    gameInfo?: JsonNullableFilter<"Game">
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    sourceUpdatedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    importedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    gameCategories?: GameCategoryListRelationFilter
    tags?: GameTagListRelationFilter
    translations?: GameTranslationListRelationFilter
    votes?: GameVoteListRelationFilter
  }, "id" | "slug">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    thumbnail?: SortOrder
    banner?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    videos?: SortOrder
    embedUrl?: SortOrder
    gameUrl?: SortOrderInput | SortOrder
    dimensions?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    sourcePlatform?: SortOrderInput | SortOrder
    sourcePlatformId?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    developerUrl?: SortOrderInput | SortOrder
    gameInfo?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    sourceUpdatedAt?: SortOrderInput | SortOrder
    importedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    slug?: StringWithAggregatesFilter<"Game"> | string
    title?: StringWithAggregatesFilter<"Game"> | string
    description?: StringNullableWithAggregatesFilter<"Game"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"Game"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Game"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Game"> | string | null
    thumbnail?: StringWithAggregatesFilter<"Game"> | string
    banner?: StringNullableWithAggregatesFilter<"Game"> | string | null
    screenshots?: StringNullableListFilter<"Game">
    videos?: StringNullableListFilter<"Game">
    embedUrl?: StringWithAggregatesFilter<"Game"> | string
    gameUrl?: StringNullableWithAggregatesFilter<"Game"> | string | null
    dimensions?: JsonWithAggregatesFilter<"Game">
    status?: EnumGameStatusWithAggregatesFilter<"Game"> | $Enums.GameStatus
    isFeatured?: BoolWithAggregatesFilter<"Game"> | boolean
    playCount?: IntWithAggregatesFilter<"Game"> | number
    viewCount?: IntWithAggregatesFilter<"Game"> | number
    likes?: IntWithAggregatesFilter<"Game"> | number
    dislikes?: IntWithAggregatesFilter<"Game"> | number
    rating?: FloatWithAggregatesFilter<"Game"> | number
    ratingCount?: IntWithAggregatesFilter<"Game"> | number
    qualityScore?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    sourcePlatform?: StringNullableWithAggregatesFilter<"Game"> | string | null
    sourcePlatformId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    developer?: StringNullableWithAggregatesFilter<"Game"> | string | null
    developerUrl?: StringNullableWithAggregatesFilter<"Game"> | string | null
    gameInfo?: JsonNullableWithAggregatesFilter<"Game">
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    sourceUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    importedAt?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type GameTranslationWhereInput = {
    AND?: GameTranslationWhereInput | GameTranslationWhereInput[]
    OR?: GameTranslationWhereInput[]
    NOT?: GameTranslationWhereInput | GameTranslationWhereInput[]
    id?: StringFilter<"GameTranslation"> | string
    gameId?: StringFilter<"GameTranslation"> | string
    locale?: StringFilter<"GameTranslation"> | string
    title?: StringFilter<"GameTranslation"> | string
    description?: StringNullableFilter<"GameTranslation"> | string | null
    keywords?: StringNullableFilter<"GameTranslation"> | string | null
    metaTitle?: StringNullableFilter<"GameTranslation"> | string | null
    metaDescription?: StringNullableFilter<"GameTranslation"> | string | null
    translationInfo?: JsonNullableFilter<"GameTranslation">
    createdAt?: DateTimeFilter<"GameTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GameTranslation"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameTranslationOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    translationInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: GameOrderByWithRelationInput
  }

  export type GameTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_locale?: GameTranslationGameIdLocaleCompoundUniqueInput
    AND?: GameTranslationWhereInput | GameTranslationWhereInput[]
    OR?: GameTranslationWhereInput[]
    NOT?: GameTranslationWhereInput | GameTranslationWhereInput[]
    gameId?: StringFilter<"GameTranslation"> | string
    locale?: StringFilter<"GameTranslation"> | string
    title?: StringFilter<"GameTranslation"> | string
    description?: StringNullableFilter<"GameTranslation"> | string | null
    keywords?: StringNullableFilter<"GameTranslation"> | string | null
    metaTitle?: StringNullableFilter<"GameTranslation"> | string | null
    metaDescription?: StringNullableFilter<"GameTranslation"> | string | null
    translationInfo?: JsonNullableFilter<"GameTranslation">
    createdAt?: DateTimeFilter<"GameTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GameTranslation"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "gameId_locale">

  export type GameTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    translationInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameTranslationCountOrderByAggregateInput
    _max?: GameTranslationMaxOrderByAggregateInput
    _min?: GameTranslationMinOrderByAggregateInput
  }

  export type GameTranslationScalarWhereWithAggregatesInput = {
    AND?: GameTranslationScalarWhereWithAggregatesInput | GameTranslationScalarWhereWithAggregatesInput[]
    OR?: GameTranslationScalarWhereWithAggregatesInput[]
    NOT?: GameTranslationScalarWhereWithAggregatesInput | GameTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameTranslation"> | string
    gameId?: StringWithAggregatesFilter<"GameTranslation"> | string
    locale?: StringWithAggregatesFilter<"GameTranslation"> | string
    title?: StringWithAggregatesFilter<"GameTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"GameTranslation"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"GameTranslation"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"GameTranslation"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"GameTranslation"> | string | null
    translationInfo?: JsonNullableWithAggregatesFilter<"GameTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"GameTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameTranslation"> | Date | string
  }

  export type GameTagWhereInput = {
    AND?: GameTagWhereInput | GameTagWhereInput[]
    OR?: GameTagWhereInput[]
    NOT?: GameTagWhereInput | GameTagWhereInput[]
    gameId?: StringFilter<"GameTag"> | string
    tagId?: StringFilter<"GameTag"> | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type GameTagOrderByWithRelationInput = {
    gameId?: SortOrder
    tagId?: SortOrder
    game?: GameOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type GameTagWhereUniqueInput = Prisma.AtLeast<{
    gameId_tagId?: GameTagGameIdTagIdCompoundUniqueInput
    AND?: GameTagWhereInput | GameTagWhereInput[]
    OR?: GameTagWhereInput[]
    NOT?: GameTagWhereInput | GameTagWhereInput[]
    gameId?: StringFilter<"GameTag"> | string
    tagId?: StringFilter<"GameTag"> | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "gameId_tagId">

  export type GameTagOrderByWithAggregationInput = {
    gameId?: SortOrder
    tagId?: SortOrder
    _count?: GameTagCountOrderByAggregateInput
    _max?: GameTagMaxOrderByAggregateInput
    _min?: GameTagMinOrderByAggregateInput
  }

  export type GameTagScalarWhereWithAggregatesInput = {
    AND?: GameTagScalarWhereWithAggregatesInput | GameTagScalarWhereWithAggregatesInput[]
    OR?: GameTagScalarWhereWithAggregatesInput[]
    NOT?: GameTagScalarWhereWithAggregatesInput | GameTagScalarWhereWithAggregatesInput[]
    gameId?: StringWithAggregatesFilter<"GameTag"> | string
    tagId?: StringWithAggregatesFilter<"GameTag"> | string
  }

  export type GameCategoryWhereInput = {
    AND?: GameCategoryWhereInput | GameCategoryWhereInput[]
    OR?: GameCategoryWhereInput[]
    NOT?: GameCategoryWhereInput | GameCategoryWhereInput[]
    id?: StringFilter<"GameCategory"> | string
    gameId?: StringFilter<"GameCategory"> | string
    categoryId?: StringFilter<"GameCategory"> | string
    mainCategoryId?: StringFilter<"GameCategory"> | string
    isPrimary?: BoolFilter<"GameCategory"> | boolean
    sortOrder?: IntFilter<"GameCategory"> | number
    createdAt?: DateTimeFilter<"GameCategory"> | Date | string
    updatedAt?: DateTimeFilter<"GameCategory"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    mainCategory?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type GameCategoryOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    categoryId?: SortOrder
    mainCategoryId?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: GameOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    mainCategory?: CategoryOrderByWithRelationInput
  }

  export type GameCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_categoryId?: GameCategoryGameIdCategoryIdCompoundUniqueInput
    AND?: GameCategoryWhereInput | GameCategoryWhereInput[]
    OR?: GameCategoryWhereInput[]
    NOT?: GameCategoryWhereInput | GameCategoryWhereInput[]
    gameId?: StringFilter<"GameCategory"> | string
    categoryId?: StringFilter<"GameCategory"> | string
    mainCategoryId?: StringFilter<"GameCategory"> | string
    isPrimary?: BoolFilter<"GameCategory"> | boolean
    sortOrder?: IntFilter<"GameCategory"> | number
    createdAt?: DateTimeFilter<"GameCategory"> | Date | string
    updatedAt?: DateTimeFilter<"GameCategory"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    mainCategory?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "gameId_categoryId">

  export type GameCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    categoryId?: SortOrder
    mainCategoryId?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCategoryCountOrderByAggregateInput
    _avg?: GameCategoryAvgOrderByAggregateInput
    _max?: GameCategoryMaxOrderByAggregateInput
    _min?: GameCategoryMinOrderByAggregateInput
    _sum?: GameCategorySumOrderByAggregateInput
  }

  export type GameCategoryScalarWhereWithAggregatesInput = {
    AND?: GameCategoryScalarWhereWithAggregatesInput | GameCategoryScalarWhereWithAggregatesInput[]
    OR?: GameCategoryScalarWhereWithAggregatesInput[]
    NOT?: GameCategoryScalarWhereWithAggregatesInput | GameCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameCategory"> | string
    gameId?: StringWithAggregatesFilter<"GameCategory"> | string
    categoryId?: StringWithAggregatesFilter<"GameCategory"> | string
    mainCategoryId?: StringWithAggregatesFilter<"GameCategory"> | string
    isPrimary?: BoolWithAggregatesFilter<"GameCategory"> | boolean
    sortOrder?: IntWithAggregatesFilter<"GameCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GameCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameCategory"> | Date | string
  }

  export type PageTypeWhereInput = {
    AND?: PageTypeWhereInput | PageTypeWhereInput[]
    OR?: PageTypeWhereInput[]
    NOT?: PageTypeWhereInput | PageTypeWhereInput[]
    id?: StringFilter<"PageType"> | string
    slug?: StringFilter<"PageType"> | string
    type?: EnumPageTypeEnumFilter<"PageType"> | $Enums.PageTypeEnum
    icon?: StringNullableFilter<"PageType"> | string | null
    isEnabled?: BoolFilter<"PageType"> | boolean
    sortOrder?: IntFilter<"PageType"> | number
    title?: StringFilter<"PageType"> | string
    description?: StringNullableFilter<"PageType"> | string | null
    metaTitle?: StringNullableFilter<"PageType"> | string | null
    metaDescription?: StringNullableFilter<"PageType"> | string | null
    keywords?: StringNullableFilter<"PageType"> | string | null
    pageInfo?: JsonNullableFilter<"PageType">
    createdAt?: DateTimeFilter<"PageType"> | Date | string
    updatedAt?: DateTimeFilter<"PageType"> | Date | string
    translations?: PageTypeTranslationListRelationFilter
  }

  export type PageTypeOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    pageInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: PageTypeTranslationOrderByRelationAggregateInput
  }

  export type PageTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageTypeWhereInput | PageTypeWhereInput[]
    OR?: PageTypeWhereInput[]
    NOT?: PageTypeWhereInput | PageTypeWhereInput[]
    type?: EnumPageTypeEnumFilter<"PageType"> | $Enums.PageTypeEnum
    icon?: StringNullableFilter<"PageType"> | string | null
    isEnabled?: BoolFilter<"PageType"> | boolean
    sortOrder?: IntFilter<"PageType"> | number
    title?: StringFilter<"PageType"> | string
    description?: StringNullableFilter<"PageType"> | string | null
    metaTitle?: StringNullableFilter<"PageType"> | string | null
    metaDescription?: StringNullableFilter<"PageType"> | string | null
    keywords?: StringNullableFilter<"PageType"> | string | null
    pageInfo?: JsonNullableFilter<"PageType">
    createdAt?: DateTimeFilter<"PageType"> | Date | string
    updatedAt?: DateTimeFilter<"PageType"> | Date | string
    translations?: PageTypeTranslationListRelationFilter
  }, "id" | "slug">

  export type PageTypeOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    pageInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageTypeCountOrderByAggregateInput
    _avg?: PageTypeAvgOrderByAggregateInput
    _max?: PageTypeMaxOrderByAggregateInput
    _min?: PageTypeMinOrderByAggregateInput
    _sum?: PageTypeSumOrderByAggregateInput
  }

  export type PageTypeScalarWhereWithAggregatesInput = {
    AND?: PageTypeScalarWhereWithAggregatesInput | PageTypeScalarWhereWithAggregatesInput[]
    OR?: PageTypeScalarWhereWithAggregatesInput[]
    NOT?: PageTypeScalarWhereWithAggregatesInput | PageTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageType"> | string
    slug?: StringWithAggregatesFilter<"PageType"> | string
    type?: EnumPageTypeEnumWithAggregatesFilter<"PageType"> | $Enums.PageTypeEnum
    icon?: StringNullableWithAggregatesFilter<"PageType"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"PageType"> | boolean
    sortOrder?: IntWithAggregatesFilter<"PageType"> | number
    title?: StringWithAggregatesFilter<"PageType"> | string
    description?: StringNullableWithAggregatesFilter<"PageType"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"PageType"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"PageType"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"PageType"> | string | null
    pageInfo?: JsonNullableWithAggregatesFilter<"PageType">
    createdAt?: DateTimeWithAggregatesFilter<"PageType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PageType"> | Date | string
  }

  export type PageTypeTranslationWhereInput = {
    AND?: PageTypeTranslationWhereInput | PageTypeTranslationWhereInput[]
    OR?: PageTypeTranslationWhereInput[]
    NOT?: PageTypeTranslationWhereInput | PageTypeTranslationWhereInput[]
    id?: StringFilter<"PageTypeTranslation"> | string
    pageTypeId?: StringFilter<"PageTypeTranslation"> | string
    locale?: StringFilter<"PageTypeTranslation"> | string
    title?: StringFilter<"PageTypeTranslation"> | string
    description?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaTitle?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaDescription?: StringNullableFilter<"PageTypeTranslation"> | string | null
    keywords?: StringNullableFilter<"PageTypeTranslation"> | string | null
    pageInfo?: JsonNullableFilter<"PageTypeTranslation">
    createdAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
    pageType?: XOR<PageTypeScalarRelationFilter, PageTypeWhereInput>
  }

  export type PageTypeTranslationOrderByWithRelationInput = {
    id?: SortOrder
    pageTypeId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    pageInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pageType?: PageTypeOrderByWithRelationInput
  }

  export type PageTypeTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageTypeId_locale?: PageTypeTranslationPageTypeIdLocaleCompoundUniqueInput
    AND?: PageTypeTranslationWhereInput | PageTypeTranslationWhereInput[]
    OR?: PageTypeTranslationWhereInput[]
    NOT?: PageTypeTranslationWhereInput | PageTypeTranslationWhereInput[]
    pageTypeId?: StringFilter<"PageTypeTranslation"> | string
    locale?: StringFilter<"PageTypeTranslation"> | string
    title?: StringFilter<"PageTypeTranslation"> | string
    description?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaTitle?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaDescription?: StringNullableFilter<"PageTypeTranslation"> | string | null
    keywords?: StringNullableFilter<"PageTypeTranslation"> | string | null
    pageInfo?: JsonNullableFilter<"PageTypeTranslation">
    createdAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
    pageType?: XOR<PageTypeScalarRelationFilter, PageTypeWhereInput>
  }, "id" | "pageTypeId_locale">

  export type PageTypeTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    pageTypeId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    pageInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageTypeTranslationCountOrderByAggregateInput
    _max?: PageTypeTranslationMaxOrderByAggregateInput
    _min?: PageTypeTranslationMinOrderByAggregateInput
  }

  export type PageTypeTranslationScalarWhereWithAggregatesInput = {
    AND?: PageTypeTranslationScalarWhereWithAggregatesInput | PageTypeTranslationScalarWhereWithAggregatesInput[]
    OR?: PageTypeTranslationScalarWhereWithAggregatesInput[]
    NOT?: PageTypeTranslationScalarWhereWithAggregatesInput | PageTypeTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageTypeTranslation"> | string
    pageTypeId?: StringWithAggregatesFilter<"PageTypeTranslation"> | string
    locale?: StringWithAggregatesFilter<"PageTypeTranslation"> | string
    title?: StringWithAggregatesFilter<"PageTypeTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"PageTypeTranslation"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"PageTypeTranslation"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"PageTypeTranslation"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"PageTypeTranslation"> | string | null
    pageInfo?: JsonNullableWithAggregatesFilter<"PageTypeTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"PageTypeTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PageTypeTranslation"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    flag?: StringNullableFilter<"Language"> | string | null
    localeCode?: StringFilter<"Language"> | string
    direction?: EnumTextDirectionFilter<"Language"> | $Enums.TextDirection
    isDefault?: BoolFilter<"Language"> | boolean
    isEnabled?: BoolFilter<"Language"> | boolean
    sortOrder?: IntFilter<"Language"> | number
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    translations?: LanguageTranslationListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    flag?: SortOrderInput | SortOrder
    localeCode?: SortOrder
    direction?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: LanguageTranslationOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    flag?: StringNullableFilter<"Language"> | string | null
    localeCode?: StringFilter<"Language"> | string
    direction?: EnumTextDirectionFilter<"Language"> | $Enums.TextDirection
    isDefault?: BoolFilter<"Language"> | boolean
    isEnabled?: BoolFilter<"Language"> | boolean
    sortOrder?: IntFilter<"Language"> | number
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    translations?: LanguageTranslationListRelationFilter
  }, "id" | "code">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    flag?: SortOrderInput | SortOrder
    localeCode?: SortOrder
    direction?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    nativeName?: StringWithAggregatesFilter<"Language"> | string
    flag?: StringNullableWithAggregatesFilter<"Language"> | string | null
    localeCode?: StringWithAggregatesFilter<"Language"> | string
    direction?: EnumTextDirectionWithAggregatesFilter<"Language"> | $Enums.TextDirection
    isDefault?: BoolWithAggregatesFilter<"Language"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"Language"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Language"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type LanguageTranslationWhereInput = {
    AND?: LanguageTranslationWhereInput | LanguageTranslationWhereInput[]
    OR?: LanguageTranslationWhereInput[]
    NOT?: LanguageTranslationWhereInput | LanguageTranslationWhereInput[]
    id?: StringFilter<"LanguageTranslation"> | string
    languageId?: StringFilter<"LanguageTranslation"> | string
    locale?: StringFilter<"LanguageTranslation"> | string
    name?: StringFilter<"LanguageTranslation"> | string
    description?: StringNullableFilter<"LanguageTranslation"> | string | null
    createdAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }

  export type LanguageTranslationOrderByWithRelationInput = {
    id?: SortOrder
    languageId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
  }

  export type LanguageTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    languageId_locale?: LanguageTranslationLanguageIdLocaleCompoundUniqueInput
    AND?: LanguageTranslationWhereInput | LanguageTranslationWhereInput[]
    OR?: LanguageTranslationWhereInput[]
    NOT?: LanguageTranslationWhereInput | LanguageTranslationWhereInput[]
    languageId?: StringFilter<"LanguageTranslation"> | string
    locale?: StringFilter<"LanguageTranslation"> | string
    name?: StringFilter<"LanguageTranslation"> | string
    description?: StringNullableFilter<"LanguageTranslation"> | string | null
    createdAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }, "id" | "languageId_locale">

  export type LanguageTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    languageId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageTranslationCountOrderByAggregateInput
    _max?: LanguageTranslationMaxOrderByAggregateInput
    _min?: LanguageTranslationMinOrderByAggregateInput
  }

  export type LanguageTranslationScalarWhereWithAggregatesInput = {
    AND?: LanguageTranslationScalarWhereWithAggregatesInput | LanguageTranslationScalarWhereWithAggregatesInput[]
    OR?: LanguageTranslationScalarWhereWithAggregatesInput[]
    NOT?: LanguageTranslationScalarWhereWithAggregatesInput | LanguageTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LanguageTranslation"> | string
    languageId?: StringWithAggregatesFilter<"LanguageTranslation"> | string
    locale?: StringWithAggregatesFilter<"LanguageTranslation"> | string
    name?: StringWithAggregatesFilter<"LanguageTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"LanguageTranslation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LanguageTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LanguageTranslation"> | Date | string
  }

  export type SiteConfigWhereInput = {
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    id?: StringFilter<"SiteConfig"> | string
    siteName?: StringFilter<"SiteConfig"> | string
    siteDescription?: StringNullableFilter<"SiteConfig"> | string | null
    siteUrl?: StringFilter<"SiteConfig"> | string
    logoUrl?: StringNullableFilter<"SiteConfig"> | string | null
    faviconUrl?: StringNullableFilter<"SiteConfig"> | string | null
    ogImageUrl?: StringNullableFilter<"SiteConfig"> | string | null
    contactEmail?: StringNullableFilter<"SiteConfig"> | string | null
    supportEmail?: StringNullableFilter<"SiteConfig"> | string | null
    socialLinks?: JsonNullableFilter<"SiteConfig">
    defaultKeywords?: StringNullableListFilter<"SiteConfig">
    twitterHandle?: StringNullableFilter<"SiteConfig"> | string | null
    googleAnalyticsId?: StringNullableFilter<"SiteConfig"> | string | null
    googleAdsenseId?: StringNullableFilter<"SiteConfig"> | string | null
    customScripts?: JsonNullableFilter<"SiteConfig">
    maintenanceMode?: BoolFilter<"SiteConfig"> | boolean
    enableComments?: BoolFilter<"SiteConfig"> | boolean
    enableRatings?: BoolFilter<"SiteConfig"> | boolean
    extraConfig?: JsonNullableFilter<"SiteConfig">
    createdAt?: DateTimeFilter<"SiteConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfig"> | Date | string
    translations?: SiteConfigTranslationListRelationFilter
  }

  export type SiteConfigOrderByWithRelationInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    siteUrl?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    supportEmail?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    defaultKeywords?: SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    googleAnalyticsId?: SortOrderInput | SortOrder
    googleAdsenseId?: SortOrderInput | SortOrder
    customScripts?: SortOrderInput | SortOrder
    maintenanceMode?: SortOrder
    enableComments?: SortOrder
    enableRatings?: SortOrder
    extraConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: SiteConfigTranslationOrderByRelationAggregateInput
  }

  export type SiteConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    siteName?: StringFilter<"SiteConfig"> | string
    siteDescription?: StringNullableFilter<"SiteConfig"> | string | null
    siteUrl?: StringFilter<"SiteConfig"> | string
    logoUrl?: StringNullableFilter<"SiteConfig"> | string | null
    faviconUrl?: StringNullableFilter<"SiteConfig"> | string | null
    ogImageUrl?: StringNullableFilter<"SiteConfig"> | string | null
    contactEmail?: StringNullableFilter<"SiteConfig"> | string | null
    supportEmail?: StringNullableFilter<"SiteConfig"> | string | null
    socialLinks?: JsonNullableFilter<"SiteConfig">
    defaultKeywords?: StringNullableListFilter<"SiteConfig">
    twitterHandle?: StringNullableFilter<"SiteConfig"> | string | null
    googleAnalyticsId?: StringNullableFilter<"SiteConfig"> | string | null
    googleAdsenseId?: StringNullableFilter<"SiteConfig"> | string | null
    customScripts?: JsonNullableFilter<"SiteConfig">
    maintenanceMode?: BoolFilter<"SiteConfig"> | boolean
    enableComments?: BoolFilter<"SiteConfig"> | boolean
    enableRatings?: BoolFilter<"SiteConfig"> | boolean
    extraConfig?: JsonNullableFilter<"SiteConfig">
    createdAt?: DateTimeFilter<"SiteConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfig"> | Date | string
    translations?: SiteConfigTranslationListRelationFilter
  }, "id">

  export type SiteConfigOrderByWithAggregationInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    siteUrl?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    supportEmail?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    defaultKeywords?: SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    googleAnalyticsId?: SortOrderInput | SortOrder
    googleAdsenseId?: SortOrderInput | SortOrder
    customScripts?: SortOrderInput | SortOrder
    maintenanceMode?: SortOrder
    enableComments?: SortOrder
    enableRatings?: SortOrder
    extraConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteConfigCountOrderByAggregateInput
    _max?: SiteConfigMaxOrderByAggregateInput
    _min?: SiteConfigMinOrderByAggregateInput
  }

  export type SiteConfigScalarWhereWithAggregatesInput = {
    AND?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    OR?: SiteConfigScalarWhereWithAggregatesInput[]
    NOT?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteConfig"> | string
    siteName?: StringWithAggregatesFilter<"SiteConfig"> | string
    siteDescription?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    siteUrl?: StringWithAggregatesFilter<"SiteConfig"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    faviconUrl?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    ogImageUrl?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    supportEmail?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    socialLinks?: JsonNullableWithAggregatesFilter<"SiteConfig">
    defaultKeywords?: StringNullableListFilter<"SiteConfig">
    twitterHandle?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    googleAnalyticsId?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    googleAdsenseId?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    customScripts?: JsonNullableWithAggregatesFilter<"SiteConfig">
    maintenanceMode?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
    enableComments?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
    enableRatings?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
    extraConfig?: JsonNullableWithAggregatesFilter<"SiteConfig">
    createdAt?: DateTimeWithAggregatesFilter<"SiteConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteConfig"> | Date | string
  }

  export type SiteConfigTranslationWhereInput = {
    AND?: SiteConfigTranslationWhereInput | SiteConfigTranslationWhereInput[]
    OR?: SiteConfigTranslationWhereInput[]
    NOT?: SiteConfigTranslationWhereInput | SiteConfigTranslationWhereInput[]
    id?: StringFilter<"SiteConfigTranslation"> | string
    siteConfigId?: StringFilter<"SiteConfigTranslation"> | string
    locale?: StringFilter<"SiteConfigTranslation"> | string
    siteName?: StringFilter<"SiteConfigTranslation"> | string
    siteDescription?: StringNullableFilter<"SiteConfigTranslation"> | string | null
    keywords?: StringNullableListFilter<"SiteConfigTranslation">
    createdAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
    siteConfig?: XOR<SiteConfigScalarRelationFilter, SiteConfigWhereInput>
  }

  export type SiteConfigTranslationOrderByWithRelationInput = {
    id?: SortOrder
    siteConfigId?: SortOrder
    locale?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteConfig?: SiteConfigOrderByWithRelationInput
  }

  export type SiteConfigTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    siteConfigId_locale?: SiteConfigTranslationSiteConfigIdLocaleCompoundUniqueInput
    AND?: SiteConfigTranslationWhereInput | SiteConfigTranslationWhereInput[]
    OR?: SiteConfigTranslationWhereInput[]
    NOT?: SiteConfigTranslationWhereInput | SiteConfigTranslationWhereInput[]
    siteConfigId?: StringFilter<"SiteConfigTranslation"> | string
    locale?: StringFilter<"SiteConfigTranslation"> | string
    siteName?: StringFilter<"SiteConfigTranslation"> | string
    siteDescription?: StringNullableFilter<"SiteConfigTranslation"> | string | null
    keywords?: StringNullableListFilter<"SiteConfigTranslation">
    createdAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
    siteConfig?: XOR<SiteConfigScalarRelationFilter, SiteConfigWhereInput>
  }, "id" | "siteConfigId_locale">

  export type SiteConfigTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    siteConfigId?: SortOrder
    locale?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteConfigTranslationCountOrderByAggregateInput
    _max?: SiteConfigTranslationMaxOrderByAggregateInput
    _min?: SiteConfigTranslationMinOrderByAggregateInput
  }

  export type SiteConfigTranslationScalarWhereWithAggregatesInput = {
    AND?: SiteConfigTranslationScalarWhereWithAggregatesInput | SiteConfigTranslationScalarWhereWithAggregatesInput[]
    OR?: SiteConfigTranslationScalarWhereWithAggregatesInput[]
    NOT?: SiteConfigTranslationScalarWhereWithAggregatesInput | SiteConfigTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteConfigTranslation"> | string
    siteConfigId?: StringWithAggregatesFilter<"SiteConfigTranslation"> | string
    locale?: StringWithAggregatesFilter<"SiteConfigTranslation"> | string
    siteName?: StringWithAggregatesFilter<"SiteConfigTranslation"> | string
    siteDescription?: StringNullableWithAggregatesFilter<"SiteConfigTranslation"> | string | null
    keywords?: StringNullableListFilter<"SiteConfigTranslation">
    createdAt?: DateTimeWithAggregatesFilter<"SiteConfigTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteConfigTranslation"> | Date | string
  }

  export type GameVoteWhereInput = {
    AND?: GameVoteWhereInput | GameVoteWhereInput[]
    OR?: GameVoteWhereInput[]
    NOT?: GameVoteWhereInput | GameVoteWhereInput[]
    id?: StringFilter<"GameVote"> | string
    gameId?: StringFilter<"GameVote"> | string
    userIp?: StringFilter<"GameVote"> | string
    isLike?: BoolFilter<"GameVote"> | boolean
    createdAt?: DateTimeFilter<"GameVote"> | Date | string
    updatedAt?: DateTimeFilter<"GameVote"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameVoteOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userIp?: SortOrder
    isLike?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: GameOrderByWithRelationInput
  }

  export type GameVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_userIp?: GameVoteGameIdUserIpCompoundUniqueInput
    AND?: GameVoteWhereInput | GameVoteWhereInput[]
    OR?: GameVoteWhereInput[]
    NOT?: GameVoteWhereInput | GameVoteWhereInput[]
    gameId?: StringFilter<"GameVote"> | string
    userIp?: StringFilter<"GameVote"> | string
    isLike?: BoolFilter<"GameVote"> | boolean
    createdAt?: DateTimeFilter<"GameVote"> | Date | string
    updatedAt?: DateTimeFilter<"GameVote"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "gameId_userIp">

  export type GameVoteOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    userIp?: SortOrder
    isLike?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameVoteCountOrderByAggregateInput
    _max?: GameVoteMaxOrderByAggregateInput
    _min?: GameVoteMinOrderByAggregateInput
  }

  export type GameVoteScalarWhereWithAggregatesInput = {
    AND?: GameVoteScalarWhereWithAggregatesInput | GameVoteScalarWhereWithAggregatesInput[]
    OR?: GameVoteScalarWhereWithAggregatesInput[]
    NOT?: GameVoteScalarWhereWithAggregatesInput | GameVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameVote"> | string
    gameId?: StringWithAggregatesFilter<"GameVote"> | string
    userIp?: StringWithAggregatesFilter<"GameVote"> | string
    isLike?: BoolWithAggregatesFilter<"GameVote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GameVote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameVote"> | Date | string
  }

  export type AITaskWhereInput = {
    AND?: AITaskWhereInput | AITaskWhereInput[]
    OR?: AITaskWhereInput[]
    NOT?: AITaskWhereInput | AITaskWhereInput[]
    id?: StringFilter<"AITask"> | string
    taskType?: StringFilter<"AITask"> | string
    status?: EnumAITaskStatusFilter<"AITask"> | $Enums.AITaskStatus
    progress?: IntFilter<"AITask"> | number
    currentStep?: StringNullableFilter<"AITask"> | string | null
    inputData?: JsonNullableFilter<"AITask">
    outputData?: JsonNullableFilter<"AITask">
    errorMessage?: StringNullableFilter<"AITask"> | string | null
    errorDetails?: JsonNullableFilter<"AITask">
    needsConfirmation?: BoolFilter<"AITask"> | boolean
    confirmPrompt?: StringNullableFilter<"AITask"> | string | null
    confirmedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
    createdAt?: DateTimeFilter<"AITask"> | Date | string
    updatedAt?: DateTimeFilter<"AITask"> | Date | string
    startedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
  }

  export type AITaskOrderByWithRelationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentStep?: SortOrderInput | SortOrder
    inputData?: SortOrderInput | SortOrder
    outputData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    needsConfirmation?: SortOrder
    confirmPrompt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type AITaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AITaskWhereInput | AITaskWhereInput[]
    OR?: AITaskWhereInput[]
    NOT?: AITaskWhereInput | AITaskWhereInput[]
    taskType?: StringFilter<"AITask"> | string
    status?: EnumAITaskStatusFilter<"AITask"> | $Enums.AITaskStatus
    progress?: IntFilter<"AITask"> | number
    currentStep?: StringNullableFilter<"AITask"> | string | null
    inputData?: JsonNullableFilter<"AITask">
    outputData?: JsonNullableFilter<"AITask">
    errorMessage?: StringNullableFilter<"AITask"> | string | null
    errorDetails?: JsonNullableFilter<"AITask">
    needsConfirmation?: BoolFilter<"AITask"> | boolean
    confirmPrompt?: StringNullableFilter<"AITask"> | string | null
    confirmedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
    createdAt?: DateTimeFilter<"AITask"> | Date | string
    updatedAt?: DateTimeFilter<"AITask"> | Date | string
    startedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AITask"> | Date | string | null
  }, "id">

  export type AITaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentStep?: SortOrderInput | SortOrder
    inputData?: SortOrderInput | SortOrder
    outputData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    needsConfirmation?: SortOrder
    confirmPrompt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AITaskCountOrderByAggregateInput
    _avg?: AITaskAvgOrderByAggregateInput
    _max?: AITaskMaxOrderByAggregateInput
    _min?: AITaskMinOrderByAggregateInput
    _sum?: AITaskSumOrderByAggregateInput
  }

  export type AITaskScalarWhereWithAggregatesInput = {
    AND?: AITaskScalarWhereWithAggregatesInput | AITaskScalarWhereWithAggregatesInput[]
    OR?: AITaskScalarWhereWithAggregatesInput[]
    NOT?: AITaskScalarWhereWithAggregatesInput | AITaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AITask"> | string
    taskType?: StringWithAggregatesFilter<"AITask"> | string
    status?: EnumAITaskStatusWithAggregatesFilter<"AITask"> | $Enums.AITaskStatus
    progress?: IntWithAggregatesFilter<"AITask"> | number
    currentStep?: StringNullableWithAggregatesFilter<"AITask"> | string | null
    inputData?: JsonNullableWithAggregatesFilter<"AITask">
    outputData?: JsonNullableWithAggregatesFilter<"AITask">
    errorMessage?: StringNullableWithAggregatesFilter<"AITask"> | string | null
    errorDetails?: JsonNullableWithAggregatesFilter<"AITask">
    needsConfirmation?: BoolWithAggregatesFilter<"AITask"> | boolean
    confirmPrompt?: StringNullableWithAggregatesFilter<"AITask"> | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"AITask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AITask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AITask"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"AITask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AITask"> | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutSubCategoriesInput
    subCategories?: CategoryCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    subCategories?: CategoryUncheckedCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryUncheckedCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutSubCategoriesNestedInput
    subCategories?: CategoryUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    subCategories?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryTranslationUncheckedCreateInput = {
    id?: string
    categoryId: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateManyInput = {
    id?: string
    categoryId: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameTagCreateNestedManyWithoutTagInput
    translations?: TagTranslationCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameTagUncheckedCreateNestedManyWithoutTagInput
    translations?: TagTranslationUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameTagUpdateManyWithoutTagNestedInput
    translations?: TagTranslationUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameTagUncheckedUpdateManyWithoutTagNestedInput
    translations?: TagTranslationUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: TagCreateNestedOneWithoutTranslationsInput
  }

  export type TagTranslationUncheckedCreateInput = {
    id?: string
    tagId: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TagTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationCreateManyInput = {
    id?: string
    tagId: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryCreateNestedManyWithoutGameInput
    tags?: GameTagCreateNestedManyWithoutGameInput
    translations?: GameTranslationCreateNestedManyWithoutGameInput
    votes?: GameVoteCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryUncheckedCreateNestedManyWithoutGameInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGameInput
    translations?: GameTranslationUncheckedCreateNestedManyWithoutGameInput
    votes?: GameVoteUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUpdateManyWithoutGameNestedInput
    tags?: GameTagUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUpdateManyWithoutGameNestedInput
    votes?: GameVoteUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUncheckedUpdateManyWithoutGameNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUncheckedUpdateManyWithoutGameNestedInput
    votes?: GameVoteUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTranslationCreateInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutTranslationsInput
  }

  export type GameTranslationUncheckedCreateInput = {
    id?: string
    gameId: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type GameTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTranslationCreateManyInput = {
    id?: string
    gameId: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTagCreateInput = {
    game: GameCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutGamesInput
  }

  export type GameTagUncheckedCreateInput = {
    gameId: string
    tagId: string
  }

  export type GameTagUpdateInput = {
    game?: GameUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutGamesNestedInput
  }

  export type GameTagUncheckedUpdateInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagCreateManyInput = {
    gameId: string
    tagId: string
  }

  export type GameTagUpdateManyMutationInput = {

  }

  export type GameTagUncheckedUpdateManyInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type GameCategoryCreateInput = {
    id?: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutGameCategoriesInput
    category: CategoryCreateNestedOneWithoutGameSubCategoriesInput
    mainCategory: CategoryCreateNestedOneWithoutGameMainCategoriesInput
  }

  export type GameCategoryUncheckedCreateInput = {
    id?: string
    gameId: string
    categoryId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutGameSubCategoriesNestedInput
    mainCategory?: CategoryUpdateOneRequiredWithoutGameMainCategoriesNestedInput
  }

  export type GameCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryCreateManyInput = {
    id?: string
    gameId: string
    categoryId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeCreateInput = {
    id?: string
    slug: string
    type?: $Enums.PageTypeEnum
    icon?: string | null
    isEnabled?: boolean
    sortOrder?: number
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTypeTranslationCreateNestedManyWithoutPageTypeInput
  }

  export type PageTypeUncheckedCreateInput = {
    id?: string
    slug: string
    type?: $Enums.PageTypeEnum
    icon?: string | null
    isEnabled?: boolean
    sortOrder?: number
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: PageTypeTranslationUncheckedCreateNestedManyWithoutPageTypeInput
  }

  export type PageTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTypeTranslationUpdateManyWithoutPageTypeNestedInput
  }

  export type PageTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: PageTypeTranslationUncheckedUpdateManyWithoutPageTypeNestedInput
  }

  export type PageTypeCreateManyInput = {
    id?: string
    slug: string
    type?: $Enums.PageTypeEnum
    icon?: string | null
    isEnabled?: boolean
    sortOrder?: number
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationCreateInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pageType: PageTypeCreateNestedOneWithoutTranslationsInput
  }

  export type PageTypeTranslationUncheckedCreateInput = {
    id?: string
    pageTypeId: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageType?: PageTypeUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type PageTypeTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageTypeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationCreateManyInput = {
    id?: string
    pageTypeId: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageTypeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    flag?: string | null
    localeCode: string
    direction?: $Enums.TextDirection
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: LanguageTranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    flag?: string | null
    localeCode: string
    direction?: $Enums.TextDirection
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: LanguageTranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: LanguageTranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: LanguageTranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    flag?: string | null
    localeCode: string
    direction?: $Enums.TextDirection
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationCreateInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutTranslationsInput
  }

  export type LanguageTranslationUncheckedCreateInput = {
    id?: string
    languageId: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type LanguageTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationCreateManyInput = {
    id?: string
    languageId: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigCreateInput = {
    id?: string
    siteName: string
    siteDescription?: string | null
    siteUrl: string
    logoUrl?: string | null
    faviconUrl?: string | null
    ogImageUrl?: string | null
    contactEmail?: string | null
    supportEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigCreatedefaultKeywordsInput | string[]
    twitterHandle?: string | null
    googleAnalyticsId?: string | null
    googleAdsenseId?: string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: SiteConfigTranslationCreateNestedManyWithoutSiteConfigInput
  }

  export type SiteConfigUncheckedCreateInput = {
    id?: string
    siteName: string
    siteDescription?: string | null
    siteUrl: string
    logoUrl?: string | null
    faviconUrl?: string | null
    ogImageUrl?: string | null
    contactEmail?: string | null
    supportEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigCreatedefaultKeywordsInput | string[]
    twitterHandle?: string | null
    googleAnalyticsId?: string | null
    googleAdsenseId?: string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: SiteConfigTranslationUncheckedCreateNestedManyWithoutSiteConfigInput
  }

  export type SiteConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: SiteConfigTranslationUpdateManyWithoutSiteConfigNestedInput
  }

  export type SiteConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: SiteConfigTranslationUncheckedUpdateManyWithoutSiteConfigNestedInput
  }

  export type SiteConfigCreateManyInput = {
    id?: string
    siteName: string
    siteDescription?: string | null
    siteUrl: string
    logoUrl?: string | null
    faviconUrl?: string | null
    ogImageUrl?: string | null
    contactEmail?: string | null
    supportEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigCreatedefaultKeywordsInput | string[]
    twitterHandle?: string | null
    googleAnalyticsId?: string | null
    googleAdsenseId?: string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationCreateInput = {
    id?: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    siteConfig: SiteConfigCreateNestedOneWithoutTranslationsInput
  }

  export type SiteConfigTranslationUncheckedCreateInput = {
    id?: string
    siteConfigId: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteConfig?: SiteConfigUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type SiteConfigTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteConfigId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationCreateManyInput = {
    id?: string
    siteConfigId: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteConfigId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteCreateInput = {
    id?: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutVotesInput
  }

  export type GameVoteUncheckedCreateInput = {
    id?: string
    gameId: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutVotesNestedInput
  }

  export type GameVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteCreateManyInput = {
    id?: string
    gameId: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AITaskCreateInput = {
    id?: string
    taskType: string
    status?: $Enums.AITaskStatus
    progress?: number
    currentStep?: string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: boolean
    confirmPrompt?: string | null
    confirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AITaskUncheckedCreateInput = {
    id?: string
    taskType: string
    status?: $Enums.AITaskStatus
    progress?: number
    currentStep?: string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: boolean
    confirmPrompt?: string | null
    confirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AITaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    status?: EnumAITaskStatusFieldUpdateOperationsInput | $Enums.AITaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    status?: EnumAITaskStatusFieldUpdateOperationsInput | $Enums.AITaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITaskCreateManyInput = {
    id?: string
    taskType: string
    status?: $Enums.AITaskStatus
    progress?: number
    currentStep?: string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: boolean
    confirmPrompt?: string | null
    confirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AITaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    status?: EnumAITaskStatusFieldUpdateOperationsInput | $Enums.AITaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AITaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    status?: EnumAITaskStatusFieldUpdateOperationsInput | $Enums.AITaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    currentStep?: NullableStringFieldUpdateOperationsInput | string | null
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    needsConfirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CategoryTranslationListRelationFilter = {
    every?: CategoryTranslationWhereInput
    some?: CategoryTranslationWhereInput
    none?: CategoryTranslationWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type GameCategoryListRelationFilter = {
    every?: GameCategoryWhereInput
    some?: GameCategoryWhereInput
    none?: GameCategoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CategoryTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isEnabled?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isEnabled?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isEnabled?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CategoryTranslationCategoryIdLocaleCompoundUniqueInput = {
    categoryId: string
    locale: string
  }

  export type CategoryTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameTagListRelationFilter = {
    every?: GameTagWhereInput
    some?: GameTagWhereInput
    none?: GameTagWhereInput
  }

  export type TagTranslationListRelationFilter = {
    every?: TagTranslationWhereInput
    some?: TagTranslationWhereInput
    none?: TagTranslationWhereInput
  }

  export type GameTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagTranslationTagIdLocaleCompoundUniqueInput = {
    tagId: string
    locale: string
  }

  export type TagTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type GameTranslationListRelationFilter = {
    every?: GameTranslationWhereInput
    some?: GameTranslationWhereInput
    none?: GameTranslationWhereInput
  }

  export type GameVoteListRelationFilter = {
    every?: GameVoteWhereInput
    some?: GameVoteWhereInput
    none?: GameVoteWhereInput
  }

  export type GameTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    thumbnail?: SortOrder
    banner?: SortOrder
    screenshots?: SortOrder
    videos?: SortOrder
    embedUrl?: SortOrder
    gameUrl?: SortOrder
    dimensions?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrder
    sourcePlatform?: SortOrder
    sourcePlatformId?: SortOrder
    developer?: SortOrder
    developerUrl?: SortOrder
    gameInfo?: SortOrder
    releaseDate?: SortOrder
    sourceUpdatedAt?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    thumbnail?: SortOrder
    banner?: SortOrder
    embedUrl?: SortOrder
    gameUrl?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrder
    sourcePlatform?: SortOrder
    sourcePlatformId?: SortOrder
    developer?: SortOrder
    developerUrl?: SortOrder
    releaseDate?: SortOrder
    sourceUpdatedAt?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    thumbnail?: SortOrder
    banner?: SortOrder
    embedUrl?: SortOrder
    gameUrl?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrder
    sourcePlatform?: SortOrder
    sourcePlatformId?: SortOrder
    developer?: SortOrder
    developerUrl?: SortOrder
    releaseDate?: SortOrder
    sourceUpdatedAt?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    playCount?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    qualityScore?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type GameTranslationGameIdLocaleCompoundUniqueInput = {
    gameId: string
    locale: string
  }

  export type GameTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    translationInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameTagGameIdTagIdCompoundUniqueInput = {
    gameId: string
    tagId: string
  }

  export type GameTagCountOrderByAggregateInput = {
    gameId?: SortOrder
    tagId?: SortOrder
  }

  export type GameTagMaxOrderByAggregateInput = {
    gameId?: SortOrder
    tagId?: SortOrder
  }

  export type GameTagMinOrderByAggregateInput = {
    gameId?: SortOrder
    tagId?: SortOrder
  }

  export type GameCategoryGameIdCategoryIdCompoundUniqueInput = {
    gameId: string
    categoryId: string
  }

  export type GameCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    categoryId?: SortOrder
    mainCategoryId?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type GameCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    categoryId?: SortOrder
    mainCategoryId?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    categoryId?: SortOrder
    mainCategoryId?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumPageTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PageTypeEnum | EnumPageTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPageTypeEnumFilter<$PrismaModel> | $Enums.PageTypeEnum
  }

  export type PageTypeTranslationListRelationFilter = {
    every?: PageTypeTranslationWhereInput
    some?: PageTypeTranslationWhereInput
    none?: PageTypeTranslationWhereInput
  }

  export type PageTypeTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageTypeCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    pageInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTypeAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PageTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTypeMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTypeSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumPageTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PageTypeEnum | EnumPageTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPageTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PageTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPageTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPageTypeEnumFilter<$PrismaModel>
  }

  export type PageTypeScalarRelationFilter = {
    is?: PageTypeWhereInput
    isNot?: PageTypeWhereInput
  }

  export type PageTypeTranslationPageTypeIdLocaleCompoundUniqueInput = {
    pageTypeId: string
    locale: string
  }

  export type PageTypeTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    pageTypeId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    pageInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTypeTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    pageTypeId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTypeTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    pageTypeId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTextDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.TextDirection | EnumTextDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumTextDirectionFilter<$PrismaModel> | $Enums.TextDirection
  }

  export type LanguageTranslationListRelationFilter = {
    every?: LanguageTranslationWhereInput
    some?: LanguageTranslationWhereInput
    none?: LanguageTranslationWhereInput
  }

  export type LanguageTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    flag?: SortOrder
    localeCode?: SortOrder
    direction?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    flag?: SortOrder
    localeCode?: SortOrder
    direction?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    flag?: SortOrder
    localeCode?: SortOrder
    direction?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumTextDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextDirection | EnumTextDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumTextDirectionWithAggregatesFilter<$PrismaModel> | $Enums.TextDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextDirectionFilter<$PrismaModel>
    _max?: NestedEnumTextDirectionFilter<$PrismaModel>
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type LanguageTranslationLanguageIdLocaleCompoundUniqueInput = {
    languageId: string
    locale: string
  }

  export type LanguageTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    locale?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigTranslationListRelationFilter = {
    every?: SiteConfigTranslationWhereInput
    some?: SiteConfigTranslationWhereInput
    none?: SiteConfigTranslationWhereInput
  }

  export type SiteConfigTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteConfigCountOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    siteUrl?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    ogImageUrl?: SortOrder
    contactEmail?: SortOrder
    supportEmail?: SortOrder
    socialLinks?: SortOrder
    defaultKeywords?: SortOrder
    twitterHandle?: SortOrder
    googleAnalyticsId?: SortOrder
    googleAdsenseId?: SortOrder
    customScripts?: SortOrder
    maintenanceMode?: SortOrder
    enableComments?: SortOrder
    enableRatings?: SortOrder
    extraConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    siteUrl?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    ogImageUrl?: SortOrder
    contactEmail?: SortOrder
    supportEmail?: SortOrder
    twitterHandle?: SortOrder
    googleAnalyticsId?: SortOrder
    googleAdsenseId?: SortOrder
    maintenanceMode?: SortOrder
    enableComments?: SortOrder
    enableRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigMinOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    siteUrl?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    ogImageUrl?: SortOrder
    contactEmail?: SortOrder
    supportEmail?: SortOrder
    twitterHandle?: SortOrder
    googleAnalyticsId?: SortOrder
    googleAdsenseId?: SortOrder
    maintenanceMode?: SortOrder
    enableComments?: SortOrder
    enableRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigScalarRelationFilter = {
    is?: SiteConfigWhereInput
    isNot?: SiteConfigWhereInput
  }

  export type SiteConfigTranslationSiteConfigIdLocaleCompoundUniqueInput = {
    siteConfigId: string
    locale: string
  }

  export type SiteConfigTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    siteConfigId?: SortOrder
    locale?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    siteConfigId?: SortOrder
    locale?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    siteConfigId?: SortOrder
    locale?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameVoteGameIdUserIpCompoundUniqueInput = {
    gameId: string
    userIp: string
  }

  export type GameVoteCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userIp?: SortOrder
    isLike?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userIp?: SortOrder
    isLike?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameVoteMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    userIp?: SortOrder
    isLike?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAITaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AITaskStatus | EnumAITaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAITaskStatusFilter<$PrismaModel> | $Enums.AITaskStatus
  }

  export type AITaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentStep?: SortOrder
    inputData?: SortOrder
    outputData?: SortOrder
    errorMessage?: SortOrder
    errorDetails?: SortOrder
    needsConfirmation?: SortOrder
    confirmPrompt?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITaskAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type AITaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentStep?: SortOrder
    errorMessage?: SortOrder
    needsConfirmation?: SortOrder
    confirmPrompt?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentStep?: SortOrder
    errorMessage?: SortOrder
    needsConfirmation?: SortOrder
    confirmPrompt?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AITaskSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumAITaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AITaskStatus | EnumAITaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAITaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.AITaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAITaskStatusFilter<$PrismaModel>
    _max?: NestedEnumAITaskStatusFilter<$PrismaModel>
  }

  export type CategoryTranslationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GameCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput> | GameCategoryCreateWithoutCategoryInput[] | GameCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutCategoryInput | GameCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: GameCategoryCreateManyCategoryInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type GameCategoryCreateNestedManyWithoutMainCategoryInput = {
    create?: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput> | GameCategoryCreateWithoutMainCategoryInput[] | GameCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutMainCategoryInput | GameCategoryCreateOrConnectWithoutMainCategoryInput[]
    createMany?: GameCategoryCreateManyMainCategoryInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GameCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput> | GameCategoryCreateWithoutCategoryInput[] | GameCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutCategoryInput | GameCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: GameCategoryCreateManyCategoryInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput = {
    create?: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput> | GameCategoryCreateWithoutMainCategoryInput[] | GameCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutMainCategoryInput | GameCategoryCreateOrConnectWithoutMainCategoryInput[]
    createMany?: GameCategoryCreateManyMainCategoryInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CategoryTranslationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutSubCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    upsert?: CategoryUpsertWithoutSubCategoriesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubCategoriesInput, CategoryUpdateWithoutSubCategoriesInput>, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GameCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput> | GameCategoryCreateWithoutCategoryInput[] | GameCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutCategoryInput | GameCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutCategoryInput | GameCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GameCategoryCreateManyCategoryInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutCategoryInput | GameCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutCategoryInput | GameCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type GameCategoryUpdateManyWithoutMainCategoryNestedInput = {
    create?: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput> | GameCategoryCreateWithoutMainCategoryInput[] | GameCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutMainCategoryInput | GameCategoryCreateOrConnectWithoutMainCategoryInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutMainCategoryInput | GameCategoryUpsertWithWhereUniqueWithoutMainCategoryInput[]
    createMany?: GameCategoryCreateManyMainCategoryInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutMainCategoryInput | GameCategoryUpdateWithWhereUniqueWithoutMainCategoryInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutMainCategoryInput | GameCategoryUpdateManyWithWhereWithoutMainCategoryInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput> | GameCategoryCreateWithoutCategoryInput[] | GameCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutCategoryInput | GameCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutCategoryInput | GameCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GameCategoryCreateManyCategoryInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutCategoryInput | GameCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutCategoryInput | GameCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput = {
    create?: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput> | GameCategoryCreateWithoutMainCategoryInput[] | GameCategoryUncheckedCreateWithoutMainCategoryInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutMainCategoryInput | GameCategoryCreateOrConnectWithoutMainCategoryInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutMainCategoryInput | GameCategoryUpsertWithWhereUniqueWithoutMainCategoryInput[]
    createMany?: GameCategoryCreateManyMainCategoryInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutMainCategoryInput | GameCategoryUpdateWithWhereUniqueWithoutMainCategoryInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutMainCategoryInput | GameCategoryUpdateManyWithWhereWithoutMainCategoryInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    upsert?: CategoryUpsertWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTranslationsInput, CategoryUpdateWithoutTranslationsInput>, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type GameTagCreateNestedManyWithoutTagInput = {
    create?: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput> | GameTagCreateWithoutTagInput[] | GameTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutTagInput | GameTagCreateOrConnectWithoutTagInput[]
    createMany?: GameTagCreateManyTagInputEnvelope
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type TagTranslationCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type GameTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput> | GameTagCreateWithoutTagInput[] | GameTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutTagInput | GameTagCreateOrConnectWithoutTagInput[]
    createMany?: GameTagCreateManyTagInputEnvelope
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type TagTranslationUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
  }

  export type GameTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput> | GameTagCreateWithoutTagInput[] | GameTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutTagInput | GameTagCreateOrConnectWithoutTagInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutTagInput | GameTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: GameTagCreateManyTagInputEnvelope
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutTagInput | GameTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutTagInput | GameTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type TagTranslationUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutTagInput | TagTranslationUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutTagInput | TagTranslationUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutTagInput | TagTranslationUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type GameTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput> | GameTagCreateWithoutTagInput[] | GameTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutTagInput | GameTagCreateOrConnectWithoutTagInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutTagInput | GameTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: GameTagCreateManyTagInputEnvelope
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutTagInput | GameTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutTagInput | GameTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type TagTranslationUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput> | TagTranslationCreateWithoutTagInput[] | TagTranslationUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTranslationCreateOrConnectWithoutTagInput | TagTranslationCreateOrConnectWithoutTagInput[]
    upsert?: TagTranslationUpsertWithWhereUniqueWithoutTagInput | TagTranslationUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTranslationCreateManyTagInputEnvelope
    set?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    disconnect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    delete?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    connect?: TagTranslationWhereUniqueInput | TagTranslationWhereUniqueInput[]
    update?: TagTranslationUpdateWithWhereUniqueWithoutTagInput | TagTranslationUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTranslationUpdateManyWithWhereWithoutTagInput | TagTranslationUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
  }

  export type TagCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTranslationsInput
    connect?: TagWhereUniqueInput
  }

  export type TagUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTranslationsInput
    upsert?: TagUpsertWithoutTranslationsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTranslationsInput, TagUpdateWithoutTranslationsInput>, TagUncheckedUpdateWithoutTranslationsInput>
  }

  export type GameCreatescreenshotsInput = {
    set: string[]
  }

  export type GameCreatevideosInput = {
    set: string[]
  }

  export type GameCategoryCreateNestedManyWithoutGameInput = {
    create?: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput> | GameCategoryCreateWithoutGameInput[] | GameCategoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGameInput | GameCategoryCreateOrConnectWithoutGameInput[]
    createMany?: GameCategoryCreateManyGameInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type GameTagCreateNestedManyWithoutGameInput = {
    create?: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput> | GameTagCreateWithoutGameInput[] | GameTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGameInput | GameTagCreateOrConnectWithoutGameInput[]
    createMany?: GameTagCreateManyGameInputEnvelope
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type GameTranslationCreateNestedManyWithoutGameInput = {
    create?: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput> | GameTranslationCreateWithoutGameInput[] | GameTranslationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTranslationCreateOrConnectWithoutGameInput | GameTranslationCreateOrConnectWithoutGameInput[]
    createMany?: GameTranslationCreateManyGameInputEnvelope
    connect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
  }

  export type GameVoteCreateNestedManyWithoutGameInput = {
    create?: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput> | GameVoteCreateWithoutGameInput[] | GameVoteUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameVoteCreateOrConnectWithoutGameInput | GameVoteCreateOrConnectWithoutGameInput[]
    createMany?: GameVoteCreateManyGameInputEnvelope
    connect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
  }

  export type GameCategoryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput> | GameCategoryCreateWithoutGameInput[] | GameCategoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGameInput | GameCategoryCreateOrConnectWithoutGameInput[]
    createMany?: GameCategoryCreateManyGameInputEnvelope
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
  }

  export type GameTagUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput> | GameTagCreateWithoutGameInput[] | GameTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGameInput | GameTagCreateOrConnectWithoutGameInput[]
    createMany?: GameTagCreateManyGameInputEnvelope
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
  }

  export type GameTranslationUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput> | GameTranslationCreateWithoutGameInput[] | GameTranslationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTranslationCreateOrConnectWithoutGameInput | GameTranslationCreateOrConnectWithoutGameInput[]
    createMany?: GameTranslationCreateManyGameInputEnvelope
    connect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
  }

  export type GameVoteUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput> | GameVoteCreateWithoutGameInput[] | GameVoteUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameVoteCreateOrConnectWithoutGameInput | GameVoteCreateOrConnectWithoutGameInput[]
    createMany?: GameVoteCreateManyGameInputEnvelope
    connect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
  }

  export type GameUpdatescreenshotsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GameUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GameCategoryUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput> | GameCategoryCreateWithoutGameInput[] | GameCategoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGameInput | GameCategoryCreateOrConnectWithoutGameInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutGameInput | GameCategoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameCategoryCreateManyGameInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutGameInput | GameCategoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutGameInput | GameCategoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type GameTagUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput> | GameTagCreateWithoutGameInput[] | GameTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGameInput | GameTagCreateOrConnectWithoutGameInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutGameInput | GameTagUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameTagCreateManyGameInputEnvelope
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutGameInput | GameTagUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutGameInput | GameTagUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type GameTranslationUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput> | GameTranslationCreateWithoutGameInput[] | GameTranslationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTranslationCreateOrConnectWithoutGameInput | GameTranslationCreateOrConnectWithoutGameInput[]
    upsert?: GameTranslationUpsertWithWhereUniqueWithoutGameInput | GameTranslationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameTranslationCreateManyGameInputEnvelope
    set?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    disconnect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    delete?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    connect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    update?: GameTranslationUpdateWithWhereUniqueWithoutGameInput | GameTranslationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameTranslationUpdateManyWithWhereWithoutGameInput | GameTranslationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameTranslationScalarWhereInput | GameTranslationScalarWhereInput[]
  }

  export type GameVoteUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput> | GameVoteCreateWithoutGameInput[] | GameVoteUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameVoteCreateOrConnectWithoutGameInput | GameVoteCreateOrConnectWithoutGameInput[]
    upsert?: GameVoteUpsertWithWhereUniqueWithoutGameInput | GameVoteUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameVoteCreateManyGameInputEnvelope
    set?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    disconnect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    delete?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    connect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    update?: GameVoteUpdateWithWhereUniqueWithoutGameInput | GameVoteUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameVoteUpdateManyWithWhereWithoutGameInput | GameVoteUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameVoteScalarWhereInput | GameVoteScalarWhereInput[]
  }

  export type GameCategoryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput> | GameCategoryCreateWithoutGameInput[] | GameCategoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGameInput | GameCategoryCreateOrConnectWithoutGameInput[]
    upsert?: GameCategoryUpsertWithWhereUniqueWithoutGameInput | GameCategoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameCategoryCreateManyGameInputEnvelope
    set?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    disconnect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    delete?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    connect?: GameCategoryWhereUniqueInput | GameCategoryWhereUniqueInput[]
    update?: GameCategoryUpdateWithWhereUniqueWithoutGameInput | GameCategoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameCategoryUpdateManyWithWhereWithoutGameInput | GameCategoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
  }

  export type GameTagUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput> | GameTagCreateWithoutGameInput[] | GameTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTagCreateOrConnectWithoutGameInput | GameTagCreateOrConnectWithoutGameInput[]
    upsert?: GameTagUpsertWithWhereUniqueWithoutGameInput | GameTagUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameTagCreateManyGameInputEnvelope
    set?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    disconnect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    delete?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    connect?: GameTagWhereUniqueInput | GameTagWhereUniqueInput[]
    update?: GameTagUpdateWithWhereUniqueWithoutGameInput | GameTagUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameTagUpdateManyWithWhereWithoutGameInput | GameTagUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
  }

  export type GameTranslationUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput> | GameTranslationCreateWithoutGameInput[] | GameTranslationUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameTranslationCreateOrConnectWithoutGameInput | GameTranslationCreateOrConnectWithoutGameInput[]
    upsert?: GameTranslationUpsertWithWhereUniqueWithoutGameInput | GameTranslationUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameTranslationCreateManyGameInputEnvelope
    set?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    disconnect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    delete?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    connect?: GameTranslationWhereUniqueInput | GameTranslationWhereUniqueInput[]
    update?: GameTranslationUpdateWithWhereUniqueWithoutGameInput | GameTranslationUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameTranslationUpdateManyWithWhereWithoutGameInput | GameTranslationUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameTranslationScalarWhereInput | GameTranslationScalarWhereInput[]
  }

  export type GameVoteUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput> | GameVoteCreateWithoutGameInput[] | GameVoteUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameVoteCreateOrConnectWithoutGameInput | GameVoteCreateOrConnectWithoutGameInput[]
    upsert?: GameVoteUpsertWithWhereUniqueWithoutGameInput | GameVoteUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameVoteCreateManyGameInputEnvelope
    set?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    disconnect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    delete?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    connect?: GameVoteWhereUniqueInput | GameVoteWhereUniqueInput[]
    update?: GameVoteUpdateWithWhereUniqueWithoutGameInput | GameVoteUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameVoteUpdateManyWithWhereWithoutGameInput | GameVoteUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameVoteScalarWhereInput | GameVoteScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<GameCreateWithoutTranslationsInput, GameUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GameCreateOrConnectWithoutTranslationsInput
    connect?: GameWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<GameCreateWithoutTranslationsInput, GameUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: GameCreateOrConnectWithoutTranslationsInput
    upsert?: GameUpsertWithoutTranslationsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutTranslationsInput, GameUpdateWithoutTranslationsInput>, GameUncheckedUpdateWithoutTranslationsInput>
  }

  export type GameCreateNestedOneWithoutTagsInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput
    connect?: GameWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutGamesInput = {
    create?: XOR<TagCreateWithoutGamesInput, TagUncheckedCreateWithoutGamesInput>
    connectOrCreate?: TagCreateOrConnectWithoutGamesInput
    connect?: TagWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
    connectOrCreate?: GameCreateOrConnectWithoutTagsInput
    upsert?: GameUpsertWithoutTagsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutTagsInput, GameUpdateWithoutTagsInput>, GameUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<TagCreateWithoutGamesInput, TagUncheckedCreateWithoutGamesInput>
    connectOrCreate?: TagCreateOrConnectWithoutGamesInput
    upsert?: TagUpsertWithoutGamesInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutGamesInput, TagUpdateWithoutGamesInput>, TagUncheckedUpdateWithoutGamesInput>
  }

  export type GameCreateNestedOneWithoutGameCategoriesInput = {
    create?: XOR<GameCreateWithoutGameCategoriesInput, GameUncheckedCreateWithoutGameCategoriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameCategoriesInput
    connect?: GameWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutGameSubCategoriesInput = {
    create?: XOR<CategoryCreateWithoutGameSubCategoriesInput, CategoryUncheckedCreateWithoutGameSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGameSubCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutGameMainCategoriesInput = {
    create?: XOR<CategoryCreateWithoutGameMainCategoriesInput, CategoryUncheckedCreateWithoutGameMainCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGameMainCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutGameCategoriesNestedInput = {
    create?: XOR<GameCreateWithoutGameCategoriesInput, GameUncheckedCreateWithoutGameCategoriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameCategoriesInput
    upsert?: GameUpsertWithoutGameCategoriesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGameCategoriesInput, GameUpdateWithoutGameCategoriesInput>, GameUncheckedUpdateWithoutGameCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutGameSubCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutGameSubCategoriesInput, CategoryUncheckedCreateWithoutGameSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGameSubCategoriesInput
    upsert?: CategoryUpsertWithoutGameSubCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutGameSubCategoriesInput, CategoryUpdateWithoutGameSubCategoriesInput>, CategoryUncheckedUpdateWithoutGameSubCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutGameMainCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutGameMainCategoriesInput, CategoryUncheckedCreateWithoutGameMainCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGameMainCategoriesInput
    upsert?: CategoryUpsertWithoutGameMainCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutGameMainCategoriesInput, CategoryUpdateWithoutGameMainCategoriesInput>, CategoryUncheckedUpdateWithoutGameMainCategoriesInput>
  }

  export type PageTypeTranslationCreateNestedManyWithoutPageTypeInput = {
    create?: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput> | PageTypeTranslationCreateWithoutPageTypeInput[] | PageTypeTranslationUncheckedCreateWithoutPageTypeInput[]
    connectOrCreate?: PageTypeTranslationCreateOrConnectWithoutPageTypeInput | PageTypeTranslationCreateOrConnectWithoutPageTypeInput[]
    createMany?: PageTypeTranslationCreateManyPageTypeInputEnvelope
    connect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
  }

  export type PageTypeTranslationUncheckedCreateNestedManyWithoutPageTypeInput = {
    create?: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput> | PageTypeTranslationCreateWithoutPageTypeInput[] | PageTypeTranslationUncheckedCreateWithoutPageTypeInput[]
    connectOrCreate?: PageTypeTranslationCreateOrConnectWithoutPageTypeInput | PageTypeTranslationCreateOrConnectWithoutPageTypeInput[]
    createMany?: PageTypeTranslationCreateManyPageTypeInputEnvelope
    connect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
  }

  export type EnumPageTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.PageTypeEnum
  }

  export type PageTypeTranslationUpdateManyWithoutPageTypeNestedInput = {
    create?: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput> | PageTypeTranslationCreateWithoutPageTypeInput[] | PageTypeTranslationUncheckedCreateWithoutPageTypeInput[]
    connectOrCreate?: PageTypeTranslationCreateOrConnectWithoutPageTypeInput | PageTypeTranslationCreateOrConnectWithoutPageTypeInput[]
    upsert?: PageTypeTranslationUpsertWithWhereUniqueWithoutPageTypeInput | PageTypeTranslationUpsertWithWhereUniqueWithoutPageTypeInput[]
    createMany?: PageTypeTranslationCreateManyPageTypeInputEnvelope
    set?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    disconnect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    delete?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    connect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    update?: PageTypeTranslationUpdateWithWhereUniqueWithoutPageTypeInput | PageTypeTranslationUpdateWithWhereUniqueWithoutPageTypeInput[]
    updateMany?: PageTypeTranslationUpdateManyWithWhereWithoutPageTypeInput | PageTypeTranslationUpdateManyWithWhereWithoutPageTypeInput[]
    deleteMany?: PageTypeTranslationScalarWhereInput | PageTypeTranslationScalarWhereInput[]
  }

  export type PageTypeTranslationUncheckedUpdateManyWithoutPageTypeNestedInput = {
    create?: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput> | PageTypeTranslationCreateWithoutPageTypeInput[] | PageTypeTranslationUncheckedCreateWithoutPageTypeInput[]
    connectOrCreate?: PageTypeTranslationCreateOrConnectWithoutPageTypeInput | PageTypeTranslationCreateOrConnectWithoutPageTypeInput[]
    upsert?: PageTypeTranslationUpsertWithWhereUniqueWithoutPageTypeInput | PageTypeTranslationUpsertWithWhereUniqueWithoutPageTypeInput[]
    createMany?: PageTypeTranslationCreateManyPageTypeInputEnvelope
    set?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    disconnect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    delete?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    connect?: PageTypeTranslationWhereUniqueInput | PageTypeTranslationWhereUniqueInput[]
    update?: PageTypeTranslationUpdateWithWhereUniqueWithoutPageTypeInput | PageTypeTranslationUpdateWithWhereUniqueWithoutPageTypeInput[]
    updateMany?: PageTypeTranslationUpdateManyWithWhereWithoutPageTypeInput | PageTypeTranslationUpdateManyWithWhereWithoutPageTypeInput[]
    deleteMany?: PageTypeTranslationScalarWhereInput | PageTypeTranslationScalarWhereInput[]
  }

  export type PageTypeCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<PageTypeCreateWithoutTranslationsInput, PageTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageTypeCreateOrConnectWithoutTranslationsInput
    connect?: PageTypeWhereUniqueInput
  }

  export type PageTypeUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<PageTypeCreateWithoutTranslationsInput, PageTypeUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: PageTypeCreateOrConnectWithoutTranslationsInput
    upsert?: PageTypeUpsertWithoutTranslationsInput
    connect?: PageTypeWhereUniqueInput
    update?: XOR<XOR<PageTypeUpdateToOneWithWhereWithoutTranslationsInput, PageTypeUpdateWithoutTranslationsInput>, PageTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageTranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput> | LanguageTranslationCreateWithoutLanguageInput[] | LanguageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LanguageTranslationCreateOrConnectWithoutLanguageInput | LanguageTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: LanguageTranslationCreateManyLanguageInputEnvelope
    connect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
  }

  export type LanguageTranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput> | LanguageTranslationCreateWithoutLanguageInput[] | LanguageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LanguageTranslationCreateOrConnectWithoutLanguageInput | LanguageTranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: LanguageTranslationCreateManyLanguageInputEnvelope
    connect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
  }

  export type EnumTextDirectionFieldUpdateOperationsInput = {
    set?: $Enums.TextDirection
  }

  export type LanguageTranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput> | LanguageTranslationCreateWithoutLanguageInput[] | LanguageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LanguageTranslationCreateOrConnectWithoutLanguageInput | LanguageTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: LanguageTranslationUpsertWithWhereUniqueWithoutLanguageInput | LanguageTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: LanguageTranslationCreateManyLanguageInputEnvelope
    set?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    disconnect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    delete?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    connect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    update?: LanguageTranslationUpdateWithWhereUniqueWithoutLanguageInput | LanguageTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: LanguageTranslationUpdateManyWithWhereWithoutLanguageInput | LanguageTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: LanguageTranslationScalarWhereInput | LanguageTranslationScalarWhereInput[]
  }

  export type LanguageTranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput> | LanguageTranslationCreateWithoutLanguageInput[] | LanguageTranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LanguageTranslationCreateOrConnectWithoutLanguageInput | LanguageTranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: LanguageTranslationUpsertWithWhereUniqueWithoutLanguageInput | LanguageTranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: LanguageTranslationCreateManyLanguageInputEnvelope
    set?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    disconnect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    delete?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    connect?: LanguageTranslationWhereUniqueInput | LanguageTranslationWhereUniqueInput[]
    update?: LanguageTranslationUpdateWithWhereUniqueWithoutLanguageInput | LanguageTranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: LanguageTranslationUpdateManyWithWhereWithoutLanguageInput | LanguageTranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: LanguageTranslationScalarWhereInput | LanguageTranslationScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    upsert?: LanguageUpsertWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutTranslationsInput, LanguageUpdateWithoutTranslationsInput>, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type SiteConfigCreatedefaultKeywordsInput = {
    set: string[]
  }

  export type SiteConfigTranslationCreateNestedManyWithoutSiteConfigInput = {
    create?: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput> | SiteConfigTranslationCreateWithoutSiteConfigInput[] | SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput[]
    connectOrCreate?: SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput | SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput[]
    createMany?: SiteConfigTranslationCreateManySiteConfigInputEnvelope
    connect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
  }

  export type SiteConfigTranslationUncheckedCreateNestedManyWithoutSiteConfigInput = {
    create?: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput> | SiteConfigTranslationCreateWithoutSiteConfigInput[] | SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput[]
    connectOrCreate?: SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput | SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput[]
    createMany?: SiteConfigTranslationCreateManySiteConfigInputEnvelope
    connect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
  }

  export type SiteConfigUpdatedefaultKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SiteConfigTranslationUpdateManyWithoutSiteConfigNestedInput = {
    create?: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput> | SiteConfigTranslationCreateWithoutSiteConfigInput[] | SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput[]
    connectOrCreate?: SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput | SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput[]
    upsert?: SiteConfigTranslationUpsertWithWhereUniqueWithoutSiteConfigInput | SiteConfigTranslationUpsertWithWhereUniqueWithoutSiteConfigInput[]
    createMany?: SiteConfigTranslationCreateManySiteConfigInputEnvelope
    set?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    disconnect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    delete?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    connect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    update?: SiteConfigTranslationUpdateWithWhereUniqueWithoutSiteConfigInput | SiteConfigTranslationUpdateWithWhereUniqueWithoutSiteConfigInput[]
    updateMany?: SiteConfigTranslationUpdateManyWithWhereWithoutSiteConfigInput | SiteConfigTranslationUpdateManyWithWhereWithoutSiteConfigInput[]
    deleteMany?: SiteConfigTranslationScalarWhereInput | SiteConfigTranslationScalarWhereInput[]
  }

  export type SiteConfigTranslationUncheckedUpdateManyWithoutSiteConfigNestedInput = {
    create?: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput> | SiteConfigTranslationCreateWithoutSiteConfigInput[] | SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput[]
    connectOrCreate?: SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput | SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput[]
    upsert?: SiteConfigTranslationUpsertWithWhereUniqueWithoutSiteConfigInput | SiteConfigTranslationUpsertWithWhereUniqueWithoutSiteConfigInput[]
    createMany?: SiteConfigTranslationCreateManySiteConfigInputEnvelope
    set?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    disconnect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    delete?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    connect?: SiteConfigTranslationWhereUniqueInput | SiteConfigTranslationWhereUniqueInput[]
    update?: SiteConfigTranslationUpdateWithWhereUniqueWithoutSiteConfigInput | SiteConfigTranslationUpdateWithWhereUniqueWithoutSiteConfigInput[]
    updateMany?: SiteConfigTranslationUpdateManyWithWhereWithoutSiteConfigInput | SiteConfigTranslationUpdateManyWithWhereWithoutSiteConfigInput[]
    deleteMany?: SiteConfigTranslationScalarWhereInput | SiteConfigTranslationScalarWhereInput[]
  }

  export type SiteConfigTranslationCreatekeywordsInput = {
    set: string[]
  }

  export type SiteConfigCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<SiteConfigCreateWithoutTranslationsInput, SiteConfigUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: SiteConfigCreateOrConnectWithoutTranslationsInput
    connect?: SiteConfigWhereUniqueInput
  }

  export type SiteConfigTranslationUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SiteConfigUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<SiteConfigCreateWithoutTranslationsInput, SiteConfigUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: SiteConfigCreateOrConnectWithoutTranslationsInput
    upsert?: SiteConfigUpsertWithoutTranslationsInput
    connect?: SiteConfigWhereUniqueInput
    update?: XOR<XOR<SiteConfigUpdateToOneWithWhereWithoutTranslationsInput, SiteConfigUpdateWithoutTranslationsInput>, SiteConfigUncheckedUpdateWithoutTranslationsInput>
  }

  export type GameCreateNestedOneWithoutVotesInput = {
    create?: XOR<GameCreateWithoutVotesInput, GameUncheckedCreateWithoutVotesInput>
    connectOrCreate?: GameCreateOrConnectWithoutVotesInput
    connect?: GameWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<GameCreateWithoutVotesInput, GameUncheckedCreateWithoutVotesInput>
    connectOrCreate?: GameCreateOrConnectWithoutVotesInput
    upsert?: GameUpsertWithoutVotesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutVotesInput, GameUpdateWithoutVotesInput>, GameUncheckedUpdateWithoutVotesInput>
  }

  export type EnumAITaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.AITaskStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPageTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PageTypeEnum | EnumPageTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPageTypeEnumFilter<$PrismaModel> | $Enums.PageTypeEnum
  }

  export type NestedEnumPageTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PageTypeEnum | EnumPageTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageTypeEnum[] | ListEnumPageTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPageTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PageTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPageTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPageTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumTextDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.TextDirection | EnumTextDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumTextDirectionFilter<$PrismaModel> | $Enums.TextDirection
  }

  export type NestedEnumTextDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextDirection | EnumTextDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextDirection[] | ListEnumTextDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumTextDirectionWithAggregatesFilter<$PrismaModel> | $Enums.TextDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextDirectionFilter<$PrismaModel>
    _max?: NestedEnumTextDirectionFilter<$PrismaModel>
  }

  export type NestedEnumAITaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AITaskStatus | EnumAITaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAITaskStatusFilter<$PrismaModel> | $Enums.AITaskStatus
  }

  export type NestedEnumAITaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AITaskStatus | EnumAITaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AITaskStatus[] | ListEnumAITaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAITaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.AITaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAITaskStatusFilter<$PrismaModel>
    _max?: NestedEnumAITaskStatusFilter<$PrismaModel>
  }

  export type CategoryTranslationCreateWithoutCategoryInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUncheckedCreateWithoutCategoryInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationCreateOrConnectWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationCreateManyCategoryInputEnvelope = {
    data: CategoryTranslationCreateManyCategoryInput | CategoryTranslationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSubCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutSubCategoriesInput
    gameSubCategories?: GameCategoryCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    gameSubCategories?: GameCategoryUncheckedCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    subCategories?: CategoryCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    subCategories?: CategoryUncheckedCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryUncheckedCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type GameCategoryCreateWithoutCategoryInput = {
    id?: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutGameCategoriesInput
    mainCategory: CategoryCreateNestedOneWithoutGameMainCategoriesInput
  }

  export type GameCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    gameId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryCreateOrConnectWithoutCategoryInput = {
    where: GameCategoryWhereUniqueInput
    create: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type GameCategoryCreateManyCategoryInputEnvelope = {
    data: GameCategoryCreateManyCategoryInput | GameCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type GameCategoryCreateWithoutMainCategoryInput = {
    id?: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutGameCategoriesInput
    category: CategoryCreateNestedOneWithoutGameSubCategoriesInput
  }

  export type GameCategoryUncheckedCreateWithoutMainCategoryInput = {
    id?: string
    gameId: string
    categoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryCreateOrConnectWithoutMainCategoryInput = {
    where: GameCategoryWhereUniqueInput
    create: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput>
  }

  export type GameCategoryCreateManyMainCategoryInputEnvelope = {
    data: GameCategoryCreateManyMainCategoryInput | GameCategoryCreateManyMainCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryTranslationScalarWhereInput = {
    AND?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    OR?: CategoryTranslationScalarWhereInput[]
    NOT?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    id?: StringFilter<"CategoryTranslation"> | string
    categoryId?: StringFilter<"CategoryTranslation"> | string
    locale?: StringFilter<"CategoryTranslation"> | string
    name?: StringFilter<"CategoryTranslation"> | string
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaTitle?: StringNullableFilter<"CategoryTranslation"> | string | null
    metaDescription?: StringNullableFilter<"CategoryTranslation"> | string | null
    keywords?: StringNullableFilter<"CategoryTranslation"> | string | null
    createdAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryTranslation"> | Date | string
  }

  export type CategoryUpsertWithoutSubCategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutSubCategoriesNestedInput
    gameSubCategories?: GameCategoryUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    gameSubCategories?: GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isEnabled?: BoolFilter<"Category"> | boolean
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    keywords?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type GameCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: GameCategoryWhereUniqueInput
    update: XOR<GameCategoryUpdateWithoutCategoryInput, GameCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<GameCategoryCreateWithoutCategoryInput, GameCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type GameCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: GameCategoryWhereUniqueInput
    data: XOR<GameCategoryUpdateWithoutCategoryInput, GameCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type GameCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: GameCategoryScalarWhereInput
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type GameCategoryScalarWhereInput = {
    AND?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
    OR?: GameCategoryScalarWhereInput[]
    NOT?: GameCategoryScalarWhereInput | GameCategoryScalarWhereInput[]
    id?: StringFilter<"GameCategory"> | string
    gameId?: StringFilter<"GameCategory"> | string
    categoryId?: StringFilter<"GameCategory"> | string
    mainCategoryId?: StringFilter<"GameCategory"> | string
    isPrimary?: BoolFilter<"GameCategory"> | boolean
    sortOrder?: IntFilter<"GameCategory"> | number
    createdAt?: DateTimeFilter<"GameCategory"> | Date | string
    updatedAt?: DateTimeFilter<"GameCategory"> | Date | string
  }

  export type GameCategoryUpsertWithWhereUniqueWithoutMainCategoryInput = {
    where: GameCategoryWhereUniqueInput
    update: XOR<GameCategoryUpdateWithoutMainCategoryInput, GameCategoryUncheckedUpdateWithoutMainCategoryInput>
    create: XOR<GameCategoryCreateWithoutMainCategoryInput, GameCategoryUncheckedCreateWithoutMainCategoryInput>
  }

  export type GameCategoryUpdateWithWhereUniqueWithoutMainCategoryInput = {
    where: GameCategoryWhereUniqueInput
    data: XOR<GameCategoryUpdateWithoutMainCategoryInput, GameCategoryUncheckedUpdateWithoutMainCategoryInput>
  }

  export type GameCategoryUpdateManyWithWhereWithoutMainCategoryInput = {
    where: GameCategoryScalarWhereInput
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyWithoutMainCategoryInput>
  }

  export type CategoryCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutSubCategoriesInput
    subCategories?: CategoryCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subCategories?: CategoryUncheckedCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryUncheckedCreateNestedManyWithoutCategoryInput
    gameMainCategories?: GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTranslationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
  }

  export type CategoryUpsertWithoutTranslationsInput = {
    update: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutSubCategoriesNestedInput
    subCategories?: CategoryUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCategories?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type GameTagCreateWithoutTagInput = {
    game: GameCreateNestedOneWithoutTagsInput
  }

  export type GameTagUncheckedCreateWithoutTagInput = {
    gameId: string
  }

  export type GameTagCreateOrConnectWithoutTagInput = {
    where: GameTagWhereUniqueInput
    create: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput>
  }

  export type GameTagCreateManyTagInputEnvelope = {
    data: GameTagCreateManyTagInput | GameTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagTranslationCreateWithoutTagInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationUncheckedCreateWithoutTagInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTranslationCreateOrConnectWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    create: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput>
  }

  export type TagTranslationCreateManyTagInputEnvelope = {
    data: TagTranslationCreateManyTagInput | TagTranslationCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type GameTagUpsertWithWhereUniqueWithoutTagInput = {
    where: GameTagWhereUniqueInput
    update: XOR<GameTagUpdateWithoutTagInput, GameTagUncheckedUpdateWithoutTagInput>
    create: XOR<GameTagCreateWithoutTagInput, GameTagUncheckedCreateWithoutTagInput>
  }

  export type GameTagUpdateWithWhereUniqueWithoutTagInput = {
    where: GameTagWhereUniqueInput
    data: XOR<GameTagUpdateWithoutTagInput, GameTagUncheckedUpdateWithoutTagInput>
  }

  export type GameTagUpdateManyWithWhereWithoutTagInput = {
    where: GameTagScalarWhereInput
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyWithoutTagInput>
  }

  export type GameTagScalarWhereInput = {
    AND?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
    OR?: GameTagScalarWhereInput[]
    NOT?: GameTagScalarWhereInput | GameTagScalarWhereInput[]
    gameId?: StringFilter<"GameTag"> | string
    tagId?: StringFilter<"GameTag"> | string
  }

  export type TagTranslationUpsertWithWhereUniqueWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    update: XOR<TagTranslationUpdateWithoutTagInput, TagTranslationUncheckedUpdateWithoutTagInput>
    create: XOR<TagTranslationCreateWithoutTagInput, TagTranslationUncheckedCreateWithoutTagInput>
  }

  export type TagTranslationUpdateWithWhereUniqueWithoutTagInput = {
    where: TagTranslationWhereUniqueInput
    data: XOR<TagTranslationUpdateWithoutTagInput, TagTranslationUncheckedUpdateWithoutTagInput>
  }

  export type TagTranslationUpdateManyWithWhereWithoutTagInput = {
    where: TagTranslationScalarWhereInput
    data: XOR<TagTranslationUpdateManyMutationInput, TagTranslationUncheckedUpdateManyWithoutTagInput>
  }

  export type TagTranslationScalarWhereInput = {
    AND?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
    OR?: TagTranslationScalarWhereInput[]
    NOT?: TagTranslationScalarWhereInput | TagTranslationScalarWhereInput[]
    id?: StringFilter<"TagTranslation"> | string
    tagId?: StringFilter<"TagTranslation"> | string
    locale?: StringFilter<"TagTranslation"> | string
    name?: StringFilter<"TagTranslation"> | string
    description?: StringNullableFilter<"TagTranslation"> | string | null
    metaTitle?: StringNullableFilter<"TagTranslation"> | string | null
    metaDescription?: StringNullableFilter<"TagTranslation"> | string | null
    keywords?: StringNullableFilter<"TagTranslation"> | string | null
    createdAt?: DateTimeFilter<"TagTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TagTranslation"> | Date | string
  }

  export type TagCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTranslationsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
  }

  export type TagUpsertWithoutTranslationsInput = {
    update: XOR<TagUpdateWithoutTranslationsInput, TagUncheckedUpdateWithoutTranslationsInput>
    create: XOR<TagCreateWithoutTranslationsInput, TagUncheckedCreateWithoutTranslationsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTranslationsInput, TagUncheckedUpdateWithoutTranslationsInput>
  }

  export type TagUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type GameCategoryCreateWithoutGameInput = {
    id?: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutGameSubCategoriesInput
    mainCategory: CategoryCreateNestedOneWithoutGameMainCategoriesInput
  }

  export type GameCategoryUncheckedCreateWithoutGameInput = {
    id?: string
    categoryId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryCreateOrConnectWithoutGameInput = {
    where: GameCategoryWhereUniqueInput
    create: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput>
  }

  export type GameCategoryCreateManyGameInputEnvelope = {
    data: GameCategoryCreateManyGameInput | GameCategoryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameTagCreateWithoutGameInput = {
    tag: TagCreateNestedOneWithoutGamesInput
  }

  export type GameTagUncheckedCreateWithoutGameInput = {
    tagId: string
  }

  export type GameTagCreateOrConnectWithoutGameInput = {
    where: GameTagWhereUniqueInput
    create: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput>
  }

  export type GameTagCreateManyGameInputEnvelope = {
    data: GameTagCreateManyGameInput | GameTagCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameTranslationCreateWithoutGameInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTranslationUncheckedCreateWithoutGameInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTranslationCreateOrConnectWithoutGameInput = {
    where: GameTranslationWhereUniqueInput
    create: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput>
  }

  export type GameTranslationCreateManyGameInputEnvelope = {
    data: GameTranslationCreateManyGameInput | GameTranslationCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameVoteCreateWithoutGameInput = {
    id?: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameVoteUncheckedCreateWithoutGameInput = {
    id?: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameVoteCreateOrConnectWithoutGameInput = {
    where: GameVoteWhereUniqueInput
    create: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput>
  }

  export type GameVoteCreateManyGameInputEnvelope = {
    data: GameVoteCreateManyGameInput | GameVoteCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameCategoryUpsertWithWhereUniqueWithoutGameInput = {
    where: GameCategoryWhereUniqueInput
    update: XOR<GameCategoryUpdateWithoutGameInput, GameCategoryUncheckedUpdateWithoutGameInput>
    create: XOR<GameCategoryCreateWithoutGameInput, GameCategoryUncheckedCreateWithoutGameInput>
  }

  export type GameCategoryUpdateWithWhereUniqueWithoutGameInput = {
    where: GameCategoryWhereUniqueInput
    data: XOR<GameCategoryUpdateWithoutGameInput, GameCategoryUncheckedUpdateWithoutGameInput>
  }

  export type GameCategoryUpdateManyWithWhereWithoutGameInput = {
    where: GameCategoryScalarWhereInput
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyWithoutGameInput>
  }

  export type GameTagUpsertWithWhereUniqueWithoutGameInput = {
    where: GameTagWhereUniqueInput
    update: XOR<GameTagUpdateWithoutGameInput, GameTagUncheckedUpdateWithoutGameInput>
    create: XOR<GameTagCreateWithoutGameInput, GameTagUncheckedCreateWithoutGameInput>
  }

  export type GameTagUpdateWithWhereUniqueWithoutGameInput = {
    where: GameTagWhereUniqueInput
    data: XOR<GameTagUpdateWithoutGameInput, GameTagUncheckedUpdateWithoutGameInput>
  }

  export type GameTagUpdateManyWithWhereWithoutGameInput = {
    where: GameTagScalarWhereInput
    data: XOR<GameTagUpdateManyMutationInput, GameTagUncheckedUpdateManyWithoutGameInput>
  }

  export type GameTranslationUpsertWithWhereUniqueWithoutGameInput = {
    where: GameTranslationWhereUniqueInput
    update: XOR<GameTranslationUpdateWithoutGameInput, GameTranslationUncheckedUpdateWithoutGameInput>
    create: XOR<GameTranslationCreateWithoutGameInput, GameTranslationUncheckedCreateWithoutGameInput>
  }

  export type GameTranslationUpdateWithWhereUniqueWithoutGameInput = {
    where: GameTranslationWhereUniqueInput
    data: XOR<GameTranslationUpdateWithoutGameInput, GameTranslationUncheckedUpdateWithoutGameInput>
  }

  export type GameTranslationUpdateManyWithWhereWithoutGameInput = {
    where: GameTranslationScalarWhereInput
    data: XOR<GameTranslationUpdateManyMutationInput, GameTranslationUncheckedUpdateManyWithoutGameInput>
  }

  export type GameTranslationScalarWhereInput = {
    AND?: GameTranslationScalarWhereInput | GameTranslationScalarWhereInput[]
    OR?: GameTranslationScalarWhereInput[]
    NOT?: GameTranslationScalarWhereInput | GameTranslationScalarWhereInput[]
    id?: StringFilter<"GameTranslation"> | string
    gameId?: StringFilter<"GameTranslation"> | string
    locale?: StringFilter<"GameTranslation"> | string
    title?: StringFilter<"GameTranslation"> | string
    description?: StringNullableFilter<"GameTranslation"> | string | null
    keywords?: StringNullableFilter<"GameTranslation"> | string | null
    metaTitle?: StringNullableFilter<"GameTranslation"> | string | null
    metaDescription?: StringNullableFilter<"GameTranslation"> | string | null
    translationInfo?: JsonNullableFilter<"GameTranslation">
    createdAt?: DateTimeFilter<"GameTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GameTranslation"> | Date | string
  }

  export type GameVoteUpsertWithWhereUniqueWithoutGameInput = {
    where: GameVoteWhereUniqueInput
    update: XOR<GameVoteUpdateWithoutGameInput, GameVoteUncheckedUpdateWithoutGameInput>
    create: XOR<GameVoteCreateWithoutGameInput, GameVoteUncheckedCreateWithoutGameInput>
  }

  export type GameVoteUpdateWithWhereUniqueWithoutGameInput = {
    where: GameVoteWhereUniqueInput
    data: XOR<GameVoteUpdateWithoutGameInput, GameVoteUncheckedUpdateWithoutGameInput>
  }

  export type GameVoteUpdateManyWithWhereWithoutGameInput = {
    where: GameVoteScalarWhereInput
    data: XOR<GameVoteUpdateManyMutationInput, GameVoteUncheckedUpdateManyWithoutGameInput>
  }

  export type GameVoteScalarWhereInput = {
    AND?: GameVoteScalarWhereInput | GameVoteScalarWhereInput[]
    OR?: GameVoteScalarWhereInput[]
    NOT?: GameVoteScalarWhereInput | GameVoteScalarWhereInput[]
    id?: StringFilter<"GameVote"> | string
    gameId?: StringFilter<"GameVote"> | string
    userIp?: StringFilter<"GameVote"> | string
    isLike?: BoolFilter<"GameVote"> | boolean
    createdAt?: DateTimeFilter<"GameVote"> | Date | string
    updatedAt?: DateTimeFilter<"GameVote"> | Date | string
  }

  export type GameCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryCreateNestedManyWithoutGameInput
    tags?: GameTagCreateNestedManyWithoutGameInput
    votes?: GameVoteCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryUncheckedCreateNestedManyWithoutGameInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGameInput
    votes?: GameVoteUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTranslationsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTranslationsInput, GameUncheckedCreateWithoutTranslationsInput>
  }

  export type GameUpsertWithoutTranslationsInput = {
    update: XOR<GameUpdateWithoutTranslationsInput, GameUncheckedUpdateWithoutTranslationsInput>
    create: XOR<GameCreateWithoutTranslationsInput, GameUncheckedCreateWithoutTranslationsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutTranslationsInput, GameUncheckedUpdateWithoutTranslationsInput>
  }

  export type GameUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUpdateManyWithoutGameNestedInput
    tags?: GameTagUpdateManyWithoutGameNestedInput
    votes?: GameVoteUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUncheckedUpdateManyWithoutGameNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGameNestedInput
    votes?: GameVoteUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryCreateNestedManyWithoutGameInput
    translations?: GameTranslationCreateNestedManyWithoutGameInput
    votes?: GameVoteCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryUncheckedCreateNestedManyWithoutGameInput
    translations?: GameTranslationUncheckedCreateNestedManyWithoutGameInput
    votes?: GameVoteUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTagsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutGamesInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutGamesInput = {
    id?: string
    slug: string
    icon?: string | null
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TagTranslationUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutGamesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutGamesInput, TagUncheckedCreateWithoutGamesInput>
  }

  export type GameUpsertWithoutTagsInput = {
    update: XOR<GameUpdateWithoutTagsInput, GameUncheckedUpdateWithoutTagsInput>
    create: XOR<GameCreateWithoutTagsInput, GameUncheckedCreateWithoutTagsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutTagsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutTagsInput, GameUncheckedUpdateWithoutTagsInput>
  }

  export type GameUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUpdateManyWithoutGameNestedInput
    votes?: GameVoteUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUncheckedUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUncheckedUpdateManyWithoutGameNestedInput
    votes?: GameVoteUncheckedUpdateManyWithoutGameNestedInput
  }

  export type TagUpsertWithoutGamesInput = {
    update: XOR<TagUpdateWithoutGamesInput, TagUncheckedUpdateWithoutGamesInput>
    create: XOR<TagCreateWithoutGamesInput, TagUncheckedCreateWithoutGamesInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutGamesInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutGamesInput, TagUncheckedUpdateWithoutGamesInput>
  }

  export type TagUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TagTranslationUncheckedUpdateManyWithoutTagNestedInput
  }

  export type GameCreateWithoutGameCategoriesInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: GameTagCreateNestedManyWithoutGameInput
    translations?: GameTranslationCreateNestedManyWithoutGameInput
    votes?: GameVoteCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameCategoriesInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: GameTagUncheckedCreateNestedManyWithoutGameInput
    translations?: GameTranslationUncheckedCreateNestedManyWithoutGameInput
    votes?: GameVoteUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameCategoriesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGameCategoriesInput, GameUncheckedCreateWithoutGameCategoriesInput>
  }

  export type CategoryCreateWithoutGameSubCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutSubCategoriesInput
    subCategories?: CategoryCreateNestedManyWithoutParentInput
    gameMainCategories?: GameCategoryCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryUncheckedCreateWithoutGameSubCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    subCategories?: CategoryUncheckedCreateNestedManyWithoutParentInput
    gameMainCategories?: GameCategoryUncheckedCreateNestedManyWithoutMainCategoryInput
  }

  export type CategoryCreateOrConnectWithoutGameSubCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutGameSubCategoriesInput, CategoryUncheckedCreateWithoutGameSubCategoriesInput>
  }

  export type CategoryCreateWithoutGameMainCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutSubCategoriesInput
    subCategories?: CategoryCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutGameMainCategoriesInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    parentId?: string | null
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
    subCategories?: CategoryUncheckedCreateNestedManyWithoutParentInput
    gameSubCategories?: GameCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutGameMainCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutGameMainCategoriesInput, CategoryUncheckedCreateWithoutGameMainCategoriesInput>
  }

  export type GameUpsertWithoutGameCategoriesInput = {
    update: XOR<GameUpdateWithoutGameCategoriesInput, GameUncheckedUpdateWithoutGameCategoriesInput>
    create: XOR<GameCreateWithoutGameCategoriesInput, GameUncheckedCreateWithoutGameCategoriesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGameCategoriesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGameCategoriesInput, GameUncheckedUpdateWithoutGameCategoriesInput>
  }

  export type GameUpdateWithoutGameCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: GameTagUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUpdateManyWithoutGameNestedInput
    votes?: GameVoteUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGameCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: GameTagUncheckedUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUncheckedUpdateManyWithoutGameNestedInput
    votes?: GameVoteUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CategoryUpsertWithoutGameSubCategoriesInput = {
    update: XOR<CategoryUpdateWithoutGameSubCategoriesInput, CategoryUncheckedUpdateWithoutGameSubCategoriesInput>
    create: XOR<CategoryCreateWithoutGameSubCategoriesInput, CategoryUncheckedCreateWithoutGameSubCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutGameSubCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutGameSubCategoriesInput, CategoryUncheckedUpdateWithoutGameSubCategoriesInput>
  }

  export type CategoryUpdateWithoutGameSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutSubCategoriesNestedInput
    subCategories?: CategoryUpdateManyWithoutParentNestedInput
    gameMainCategories?: GameCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutGameSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    subCategories?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    gameMainCategories?: GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUpsertWithoutGameMainCategoriesInput = {
    update: XOR<CategoryUpdateWithoutGameMainCategoriesInput, CategoryUncheckedUpdateWithoutGameMainCategoriesInput>
    create: XOR<CategoryCreateWithoutGameMainCategoriesInput, CategoryUncheckedCreateWithoutGameMainCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutGameMainCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutGameMainCategoriesInput, CategoryUncheckedUpdateWithoutGameMainCategoriesInput>
  }

  export type CategoryUpdateWithoutGameMainCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutSubCategoriesNestedInput
    subCategories?: CategoryUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutGameMainCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    subCategories?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PageTypeTranslationCreateWithoutPageTypeInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeTranslationUncheckedCreateWithoutPageTypeInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeTranslationCreateOrConnectWithoutPageTypeInput = {
    where: PageTypeTranslationWhereUniqueInput
    create: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput>
  }

  export type PageTypeTranslationCreateManyPageTypeInputEnvelope = {
    data: PageTypeTranslationCreateManyPageTypeInput | PageTypeTranslationCreateManyPageTypeInput[]
    skipDuplicates?: boolean
  }

  export type PageTypeTranslationUpsertWithWhereUniqueWithoutPageTypeInput = {
    where: PageTypeTranslationWhereUniqueInput
    update: XOR<PageTypeTranslationUpdateWithoutPageTypeInput, PageTypeTranslationUncheckedUpdateWithoutPageTypeInput>
    create: XOR<PageTypeTranslationCreateWithoutPageTypeInput, PageTypeTranslationUncheckedCreateWithoutPageTypeInput>
  }

  export type PageTypeTranslationUpdateWithWhereUniqueWithoutPageTypeInput = {
    where: PageTypeTranslationWhereUniqueInput
    data: XOR<PageTypeTranslationUpdateWithoutPageTypeInput, PageTypeTranslationUncheckedUpdateWithoutPageTypeInput>
  }

  export type PageTypeTranslationUpdateManyWithWhereWithoutPageTypeInput = {
    where: PageTypeTranslationScalarWhereInput
    data: XOR<PageTypeTranslationUpdateManyMutationInput, PageTypeTranslationUncheckedUpdateManyWithoutPageTypeInput>
  }

  export type PageTypeTranslationScalarWhereInput = {
    AND?: PageTypeTranslationScalarWhereInput | PageTypeTranslationScalarWhereInput[]
    OR?: PageTypeTranslationScalarWhereInput[]
    NOT?: PageTypeTranslationScalarWhereInput | PageTypeTranslationScalarWhereInput[]
    id?: StringFilter<"PageTypeTranslation"> | string
    pageTypeId?: StringFilter<"PageTypeTranslation"> | string
    locale?: StringFilter<"PageTypeTranslation"> | string
    title?: StringFilter<"PageTypeTranslation"> | string
    description?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaTitle?: StringNullableFilter<"PageTypeTranslation"> | string | null
    metaDescription?: StringNullableFilter<"PageTypeTranslation"> | string | null
    keywords?: StringNullableFilter<"PageTypeTranslation"> | string | null
    pageInfo?: JsonNullableFilter<"PageTypeTranslation">
    createdAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PageTypeTranslation"> | Date | string
  }

  export type PageTypeCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    type?: $Enums.PageTypeEnum
    icon?: string | null
    isEnabled?: boolean
    sortOrder?: number
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeUncheckedCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    type?: $Enums.PageTypeEnum
    icon?: string | null
    isEnabled?: boolean
    sortOrder?: number
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeCreateOrConnectWithoutTranslationsInput = {
    where: PageTypeWhereUniqueInput
    create: XOR<PageTypeCreateWithoutTranslationsInput, PageTypeUncheckedCreateWithoutTranslationsInput>
  }

  export type PageTypeUpsertWithoutTranslationsInput = {
    update: XOR<PageTypeUpdateWithoutTranslationsInput, PageTypeUncheckedUpdateWithoutTranslationsInput>
    create: XOR<PageTypeCreateWithoutTranslationsInput, PageTypeUncheckedCreateWithoutTranslationsInput>
    where?: PageTypeWhereInput
  }

  export type PageTypeUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: PageTypeWhereInput
    data: XOR<PageTypeUpdateWithoutTranslationsInput, PageTypeUncheckedUpdateWithoutTranslationsInput>
  }

  export type PageTypeUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumPageTypeEnumFieldUpdateOperationsInput | $Enums.PageTypeEnum
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationCreateWithoutLanguageInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageTranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageTranslationCreateOrConnectWithoutLanguageInput = {
    where: LanguageTranslationWhereUniqueInput
    create: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type LanguageTranslationCreateManyLanguageInputEnvelope = {
    data: LanguageTranslationCreateManyLanguageInput | LanguageTranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type LanguageTranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: LanguageTranslationWhereUniqueInput
    update: XOR<LanguageTranslationUpdateWithoutLanguageInput, LanguageTranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<LanguageTranslationCreateWithoutLanguageInput, LanguageTranslationUncheckedCreateWithoutLanguageInput>
  }

  export type LanguageTranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: LanguageTranslationWhereUniqueInput
    data: XOR<LanguageTranslationUpdateWithoutLanguageInput, LanguageTranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type LanguageTranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: LanguageTranslationScalarWhereInput
    data: XOR<LanguageTranslationUpdateManyMutationInput, LanguageTranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type LanguageTranslationScalarWhereInput = {
    AND?: LanguageTranslationScalarWhereInput | LanguageTranslationScalarWhereInput[]
    OR?: LanguageTranslationScalarWhereInput[]
    NOT?: LanguageTranslationScalarWhereInput | LanguageTranslationScalarWhereInput[]
    id?: StringFilter<"LanguageTranslation"> | string
    languageId?: StringFilter<"LanguageTranslation"> | string
    locale?: StringFilter<"LanguageTranslation"> | string
    name?: StringFilter<"LanguageTranslation"> | string
    description?: StringNullableFilter<"LanguageTranslation"> | string | null
    createdAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageTranslation"> | Date | string
  }

  export type LanguageCreateWithoutTranslationsInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    flag?: string | null
    localeCode: string
    direction?: $Enums.TextDirection
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUncheckedCreateWithoutTranslationsInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    flag?: string | null
    localeCode: string
    direction?: $Enums.TextDirection
    isDefault?: boolean
    isEnabled?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageCreateOrConnectWithoutTranslationsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutTranslationsInput = {
    update: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    flag?: NullableStringFieldUpdateOperationsInput | string | null
    localeCode?: StringFieldUpdateOperationsInput | string
    direction?: EnumTextDirectionFieldUpdateOperationsInput | $Enums.TextDirection
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationCreateWithoutSiteConfigInput = {
    id?: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput = {
    id?: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigTranslationCreateOrConnectWithoutSiteConfigInput = {
    where: SiteConfigTranslationWhereUniqueInput
    create: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput>
  }

  export type SiteConfigTranslationCreateManySiteConfigInputEnvelope = {
    data: SiteConfigTranslationCreateManySiteConfigInput | SiteConfigTranslationCreateManySiteConfigInput[]
    skipDuplicates?: boolean
  }

  export type SiteConfigTranslationUpsertWithWhereUniqueWithoutSiteConfigInput = {
    where: SiteConfigTranslationWhereUniqueInput
    update: XOR<SiteConfigTranslationUpdateWithoutSiteConfigInput, SiteConfigTranslationUncheckedUpdateWithoutSiteConfigInput>
    create: XOR<SiteConfigTranslationCreateWithoutSiteConfigInput, SiteConfigTranslationUncheckedCreateWithoutSiteConfigInput>
  }

  export type SiteConfigTranslationUpdateWithWhereUniqueWithoutSiteConfigInput = {
    where: SiteConfigTranslationWhereUniqueInput
    data: XOR<SiteConfigTranslationUpdateWithoutSiteConfigInput, SiteConfigTranslationUncheckedUpdateWithoutSiteConfigInput>
  }

  export type SiteConfigTranslationUpdateManyWithWhereWithoutSiteConfigInput = {
    where: SiteConfigTranslationScalarWhereInput
    data: XOR<SiteConfigTranslationUpdateManyMutationInput, SiteConfigTranslationUncheckedUpdateManyWithoutSiteConfigInput>
  }

  export type SiteConfigTranslationScalarWhereInput = {
    AND?: SiteConfigTranslationScalarWhereInput | SiteConfigTranslationScalarWhereInput[]
    OR?: SiteConfigTranslationScalarWhereInput[]
    NOT?: SiteConfigTranslationScalarWhereInput | SiteConfigTranslationScalarWhereInput[]
    id?: StringFilter<"SiteConfigTranslation"> | string
    siteConfigId?: StringFilter<"SiteConfigTranslation"> | string
    locale?: StringFilter<"SiteConfigTranslation"> | string
    siteName?: StringFilter<"SiteConfigTranslation"> | string
    siteDescription?: StringNullableFilter<"SiteConfigTranslation"> | string | null
    keywords?: StringNullableListFilter<"SiteConfigTranslation">
    createdAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfigTranslation"> | Date | string
  }

  export type SiteConfigCreateWithoutTranslationsInput = {
    id?: string
    siteName: string
    siteDescription?: string | null
    siteUrl: string
    logoUrl?: string | null
    faviconUrl?: string | null
    ogImageUrl?: string | null
    contactEmail?: string | null
    supportEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigCreatedefaultKeywordsInput | string[]
    twitterHandle?: string | null
    googleAnalyticsId?: string | null
    googleAdsenseId?: string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigUncheckedCreateWithoutTranslationsInput = {
    id?: string
    siteName: string
    siteDescription?: string | null
    siteUrl: string
    logoUrl?: string | null
    faviconUrl?: string | null
    ogImageUrl?: string | null
    contactEmail?: string | null
    supportEmail?: string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigCreatedefaultKeywordsInput | string[]
    twitterHandle?: string | null
    googleAnalyticsId?: string | null
    googleAdsenseId?: string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: boolean
    enableComments?: boolean
    enableRatings?: boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigCreateOrConnectWithoutTranslationsInput = {
    where: SiteConfigWhereUniqueInput
    create: XOR<SiteConfigCreateWithoutTranslationsInput, SiteConfigUncheckedCreateWithoutTranslationsInput>
  }

  export type SiteConfigUpsertWithoutTranslationsInput = {
    update: XOR<SiteConfigUpdateWithoutTranslationsInput, SiteConfigUncheckedUpdateWithoutTranslationsInput>
    create: XOR<SiteConfigCreateWithoutTranslationsInput, SiteConfigUncheckedCreateWithoutTranslationsInput>
    where?: SiteConfigWhereInput
  }

  export type SiteConfigUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: SiteConfigWhereInput
    data: XOR<SiteConfigUpdateWithoutTranslationsInput, SiteConfigUncheckedUpdateWithoutTranslationsInput>
  }

  export type SiteConfigUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultKeywords?: SiteConfigUpdatedefaultKeywordsInput | string[]
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    googleAnalyticsId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAdsenseId?: NullableStringFieldUpdateOperationsInput | string | null
    customScripts?: NullableJsonNullValueInput | InputJsonValue
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    enableComments?: BoolFieldUpdateOperationsInput | boolean
    enableRatings?: BoolFieldUpdateOperationsInput | boolean
    extraConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateWithoutVotesInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryCreateNestedManyWithoutGameInput
    tags?: GameTagCreateNestedManyWithoutGameInput
    translations?: GameTranslationCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutVotesInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    thumbnail: string
    banner?: string | null
    screenshots?: GameCreatescreenshotsInput | string[]
    videos?: GameCreatevideosInput | string[]
    embedUrl: string
    gameUrl?: string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.GameStatus
    isFeatured?: boolean
    playCount?: number
    viewCount?: number
    likes?: number
    dislikes?: number
    rating?: number
    ratingCount?: number
    qualityScore?: number | null
    sourcePlatform?: string | null
    sourcePlatformId?: string | null
    developer?: string | null
    developerUrl?: string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: Date | string | null
    sourceUpdatedAt?: Date | string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCategories?: GameCategoryUncheckedCreateNestedManyWithoutGameInput
    tags?: GameTagUncheckedCreateNestedManyWithoutGameInput
    translations?: GameTranslationUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutVotesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutVotesInput, GameUncheckedCreateWithoutVotesInput>
  }

  export type GameUpsertWithoutVotesInput = {
    update: XOR<GameUpdateWithoutVotesInput, GameUncheckedUpdateWithoutVotesInput>
    create: XOR<GameCreateWithoutVotesInput, GameUncheckedCreateWithoutVotesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutVotesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutVotesInput, GameUncheckedUpdateWithoutVotesInput>
  }

  export type GameUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUpdateManyWithoutGameNestedInput
    tags?: GameTagUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: GameUpdatescreenshotsInput | string[]
    videos?: GameUpdatevideosInput | string[]
    embedUrl?: StringFieldUpdateOperationsInput | string
    gameUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dimensions?: JsonNullValueInput | InputJsonValue
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sourcePlatform?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePlatformId?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    developerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gameInfo?: NullableJsonNullValueInput | InputJsonValue
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCategories?: GameCategoryUncheckedUpdateManyWithoutGameNestedInput
    tags?: GameTagUncheckedUpdateManyWithoutGameNestedInput
    translations?: GameTranslationUncheckedUpdateManyWithoutGameNestedInput
  }

  export type CategoryTranslationCreateManyCategoryInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    slug: string
    icon?: string | null
    sortOrder?: number
    isEnabled?: boolean
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryCreateManyCategoryInput = {
    id?: string
    gameId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryCreateManyMainCategoryInput = {
    id?: string
    gameId: string
    categoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryTranslationUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
    subCategories?: CategoryUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
    subCategories?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    gameSubCategories?: GameCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    gameMainCategories?: GameCategoryUncheckedUpdateManyWithoutMainCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameCategoriesNestedInput
    mainCategory?: CategoryUpdateOneRequiredWithoutGameMainCategoriesNestedInput
  }

  export type GameCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUpdateWithoutMainCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutGameSubCategoriesNestedInput
  }

  export type GameCategoryUncheckedUpdateWithoutMainCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateManyWithoutMainCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTagCreateManyTagInput = {
    gameId: string
  }

  export type TagTranslationCreateManyTagInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTagUpdateWithoutTagInput = {
    game?: GameUpdateOneRequiredWithoutTagsNestedInput
  }

  export type GameTagUncheckedUpdateWithoutTagInput = {
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUncheckedUpdateManyWithoutTagInput = {
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TagTranslationUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTranslationUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryCreateManyGameInput = {
    id?: string
    categoryId: string
    mainCategoryId: string
    isPrimary?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameTagCreateManyGameInput = {
    tagId: string
  }

  export type GameTranslationCreateManyGameInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    keywords?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameVoteCreateManyGameInput = {
    id?: string
    userIp: string
    isLike: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCategoryUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutGameSubCategoriesNestedInput
    mainCategory?: CategoryUpdateOneRequiredWithoutGameMainCategoriesNestedInput
  }

  export type GameCategoryUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    mainCategoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTagUpdateWithoutGameInput = {
    tag?: TagUpdateOneRequiredWithoutGamesNestedInput
  }

  export type GameTagUncheckedUpdateWithoutGameInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type GameTagUncheckedUpdateManyWithoutGameInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type GameTranslationUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTranslationUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameTranslationUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    translationInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameVoteUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIp?: StringFieldUpdateOperationsInput | string
    isLike?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationCreateManyPageTypeInput = {
    id?: string
    locale: string
    title: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTypeTranslationUpdateWithoutPageTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationUncheckedUpdateWithoutPageTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTypeTranslationUncheckedUpdateManyWithoutPageTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    pageInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationCreateManyLanguageInput = {
    id?: string
    locale: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageTranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageTranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationCreateManySiteConfigInput = {
    id?: string
    locale: string
    siteName: string
    siteDescription?: string | null
    keywords?: SiteConfigTranslationCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigTranslationUpdateWithoutSiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationUncheckedUpdateWithoutSiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigTranslationUncheckedUpdateManyWithoutSiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SiteConfigTranslationUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}